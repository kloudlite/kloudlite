// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"strconv"
	"sync"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/99designs/gqlgen/plugin/federation/fedruntime"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
	"kloudlite.io/apps/container-registry/internal/app/graph/model"
	"kloudlite.io/apps/container-registry/internal/domain"
	"kloudlite.io/apps/container-registry/internal/domain/entities"
	"kloudlite.io/pkg/repos"
	"kloudlite.io/pkg/types"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Build() BuildResolver
	Credential() CredentialResolver
	GithubInstallation() GithubInstallationResolver
	GithubListRepository() GithubListRepositoryResolver
	GithubSearchRepository() GithubSearchRepositoryResolver
	Mutation() MutationResolver
	Query() QueryResolver
	Repository() RepositoryResolver
	Tag() TagResolver
	BuildIn() BuildInResolver
	CredentialIn() CredentialInResolver
}

type DirectiveRoot struct {
	HasAccount            func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	IsLoggedInAndVerified func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
}

type ComplexityRoot struct {
	Build struct {
		AccountName       func(childComplexity int) int
		CreatedBy         func(childComplexity int) int
		CreationTime      func(childComplexity int) int
		ID                func(childComplexity int) int
		LastUpdatedBy     func(childComplexity int) int
		MarkedForDeletion func(childComplexity int) int
		Name              func(childComplexity int) int
		RecordVersion     func(childComplexity int) int
		Repository        func(childComplexity int) int
		Source            func(childComplexity int) int
		Tag               func(childComplexity int) int
		UpdateTime        func(childComplexity int) int
	}

	BuildEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	BuildPaginatedRecords struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	CRCheckNameAvailabilityOutput struct {
		Result         func(childComplexity int) int
		SuggestedNames func(childComplexity int) int
	}

	Credential struct {
		Access            func(childComplexity int) int
		AccountName       func(childComplexity int) int
		CreatedBy         func(childComplexity int) int
		CreationTime      func(childComplexity int) int
		Expiration        func(childComplexity int) int
		ID                func(childComplexity int) int
		LastUpdatedBy     func(childComplexity int) int
		MarkedForDeletion func(childComplexity int) int
		Name              func(childComplexity int) int
		RecordVersion     func(childComplexity int) int
		UpdateTime        func(childComplexity int) int
		UserName          func(childComplexity int) int
	}

	CredentialEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	CredentialPaginatedRecords struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	CursorPagination struct {
		After         func(childComplexity int) int
		Before        func(childComplexity int) int
		First         func(childComplexity int) int
		Last          func(childComplexity int) int
		OrderBy       func(childComplexity int) int
		SortDirection func(childComplexity int) int
	}

	GithubBranch struct {
		Name      func(childComplexity int) int
		Protected func(childComplexity int) int
	}

	GithubInstallation struct {
		Account         func(childComplexity int) int
		AppID           func(childComplexity int) int
		ID              func(childComplexity int) int
		NodeID          func(childComplexity int) int
		RepositoriesURL func(childComplexity int) int
		TargetID        func(childComplexity int) int
		TargetType      func(childComplexity int) int
	}

	GithubListRepository struct {
		Repositories func(childComplexity int) int
		TotalCount   func(childComplexity int) int
	}

	GithubSearchRepository struct {
		IncompleteResults func(childComplexity int) int
		Repositories      func(childComplexity int) int
		Total             func(childComplexity int) int
	}

	Kloudlite_io__apps__container___registry__internal__domain__entities_Expiration struct {
		Unit  func(childComplexity int) int
		Value func(childComplexity int) int
	}

	Kloudlite_io__apps__container___registry__internal__domain__entities_GitSource struct {
		Branch     func(childComplexity int) int
		PullSecret func(childComplexity int) int
		Repository func(childComplexity int) int
	}

	Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository struct {
		Archived          func(childComplexity int) int
		CloneURL          func(childComplexity int) int
		CreatedAt         func(childComplexity int) int
		DefaultBranch     func(childComplexity int) int
		Description       func(childComplexity int) int
		Disabled          func(childComplexity int) int
		FullName          func(childComplexity int) int
		GitURL            func(childComplexity int) int
		GitignoreTemplate func(childComplexity int) int
		HTMLURL           func(childComplexity int) int
		ID                func(childComplexity int) int
		Language          func(childComplexity int) int
		MasterBranch      func(childComplexity int) int
		MirrorURL         func(childComplexity int) int
		Name              func(childComplexity int) int
		NodeID            func(childComplexity int) int
		Permissions       func(childComplexity int) int
		Private           func(childComplexity int) int
		PushedAt          func(childComplexity int) int
		Size              func(childComplexity int) int
		TeamID            func(childComplexity int) int
		URL               func(childComplexity int) int
		UpdatedAt         func(childComplexity int) int
		Visibility        func(childComplexity int) int
	}

	Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount struct {
		AvatarURL func(childComplexity int) int
		ID        func(childComplexity int) int
		Login     func(childComplexity int) int
		NodeID    func(childComplexity int) int
		Type      func(childComplexity int) int
	}

	Kloudlite_io__apps__container___registry__internal__domain__entities_RepoReference struct {
		Digest    func(childComplexity int) int
		MediaType func(childComplexity int) int
		Size      func(childComplexity int) int
	}

	Kloudlite_io__common_CreatedOrUpdatedBy struct {
		UserEmail func(childComplexity int) int
		UserID    func(childComplexity int) int
		UserName  func(childComplexity int) int
	}

	MatchFilter struct {
		Array     func(childComplexity int) int
		Exact     func(childComplexity int) int
		MatchType func(childComplexity int) int
		Regex     func(childComplexity int) int
	}

	Mutation struct {
		CrAddBuild     func(childComplexity int, build entities.Build) int
		CrCreateCred   func(childComplexity int, credential entities.Credential) int
		CrCreateRepo   func(childComplexity int, repository entities.Repository) int
		CrDeleteBuild  func(childComplexity int, id repos.ID) int
		CrDeleteCred   func(childComplexity int, username string) int
		CrDeleteRepo   func(childComplexity int, name string) int
		CrDeleteTag    func(childComplexity int, repoName string, digest string) int
		CrTriggerBuild func(childComplexity int, id repos.ID) int
		CrUpdateBuild  func(childComplexity int, id repos.ID, build entities.Build) int
	}

	PageInfo struct {
		EndCursor       func(childComplexity int) int
		HasNextPage     func(childComplexity int) int
		HasPreviousPage func(childComplexity int) int
		StartCursor     func(childComplexity int) int
	}

	Pagination struct {
		Page    func(childComplexity int) int
		PerPage func(childComplexity int) int
	}

	Query struct {
		CrCheckUserNameAvailability func(childComplexity int, name string) int
		CrGetBuild                  func(childComplexity int, id repos.ID) int
		CrGetCredToken              func(childComplexity int, username string) int
		CrListBuilds                func(childComplexity int, repoName string, search *model.SearchBuilds, pagination *repos.CursorPagination) int
		CrListCreds                 func(childComplexity int, search *model.SearchCreds, pagination *repos.CursorPagination) int
		CrListGithubBranches        func(childComplexity int, repoURL string, pagination *types.Pagination) int
		CrListGithubInstallations   func(childComplexity int, pagination *types.Pagination) int
		CrListGithubRepos           func(childComplexity int, installationID int, pagination *types.Pagination) int
		CrListRepos                 func(childComplexity int, search *model.SearchRepos, pagination *repos.CursorPagination) int
		CrListTags                  func(childComplexity int, repoName string, search *model.SearchRepos, pagination *repos.CursorPagination) int
		CrSearchGithubRepos         func(childComplexity int, organization string, search string, pagination *types.Pagination) int
		__resolve__service          func(childComplexity int) int
	}

	Repository struct {
		AccountName       func(childComplexity int) int
		CreatedBy         func(childComplexity int) int
		CreationTime      func(childComplexity int) int
		ID                func(childComplexity int) int
		LastUpdatedBy     func(childComplexity int) int
		MarkedForDeletion func(childComplexity int) int
		Name              func(childComplexity int) int
		RecordVersion     func(childComplexity int) int
		UpdateTime        func(childComplexity int) int
	}

	RepositoryEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	RepositoryPaginatedRecords struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	Tag struct {
		AccountName       func(childComplexity int) int
		Actor             func(childComplexity int) int
		CreationTime      func(childComplexity int) int
		Deleting          func(childComplexity int) int
		Digest            func(childComplexity int) int
		ID                func(childComplexity int) int
		Length            func(childComplexity int) int
		MarkedForDeletion func(childComplexity int) int
		MediaType         func(childComplexity int) int
		RecordVersion     func(childComplexity int) int
		References        func(childComplexity int) int
		Repository        func(childComplexity int) int
		Size              func(childComplexity int) int
		Tags              func(childComplexity int) int
		URL               func(childComplexity int) int
		UpdateTime        func(childComplexity int) int
	}

	TagEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	TagPaginatedRecords struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	_Service struct {
		SDL func(childComplexity int) int
	}
}

type BuildResolver interface {
	CreatedBy(ctx context.Context, obj *entities.Build) (*model.KloudliteIoCommonCreatedOrUpdatedBy, error)
	CreationTime(ctx context.Context, obj *entities.Build) (string, error)
	ID(ctx context.Context, obj *entities.Build) (string, error)
	LastUpdatedBy(ctx context.Context, obj *entities.Build) (*model.KloudliteIoCommonCreatedOrUpdatedBy, error)

	Source(ctx context.Context, obj *entities.Build) (*model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGitSource, error)

	UpdateTime(ctx context.Context, obj *entities.Build) (string, error)
}
type CredentialResolver interface {
	Access(ctx context.Context, obj *entities.Credential) (model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesRepoAccess, error)

	CreatedBy(ctx context.Context, obj *entities.Credential) (*model.KloudliteIoCommonCreatedOrUpdatedBy, error)
	CreationTime(ctx context.Context, obj *entities.Credential) (string, error)
	Expiration(ctx context.Context, obj *entities.Credential) (*model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesExpiration, error)
	ID(ctx context.Context, obj *entities.Credential) (string, error)
	LastUpdatedBy(ctx context.Context, obj *entities.Credential) (*model.KloudliteIoCommonCreatedOrUpdatedBy, error)

	UpdateTime(ctx context.Context, obj *entities.Credential) (string, error)
}
type GithubInstallationResolver interface {
	Account(ctx context.Context, obj *entities.GithubInstallation) (*model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubUserAccount, error)
}
type GithubListRepositoryResolver interface {
	Repositories(ctx context.Context, obj *entities.GithubListRepository) ([]*model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubRepository, error)
}
type GithubSearchRepositoryResolver interface {
	Repositories(ctx context.Context, obj *entities.GithubSearchRepository) ([]*model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubRepository, error)
}
type MutationResolver interface {
	CrCreateRepo(ctx context.Context, repository entities.Repository) (*entities.Repository, error)
	CrCreateCred(ctx context.Context, credential entities.Credential) (*entities.Credential, error)
	CrDeleteRepo(ctx context.Context, name string) (bool, error)
	CrDeleteCred(ctx context.Context, username string) (bool, error)
	CrDeleteTag(ctx context.Context, repoName string, digest string) (bool, error)
	CrAddBuild(ctx context.Context, build entities.Build) (*entities.Build, error)
	CrUpdateBuild(ctx context.Context, id repos.ID, build entities.Build) (*entities.Build, error)
	CrDeleteBuild(ctx context.Context, id repos.ID) (bool, error)
	CrTriggerBuild(ctx context.Context, id repos.ID) (bool, error)
}
type QueryResolver interface {
	CrListRepos(ctx context.Context, search *model.SearchRepos, pagination *repos.CursorPagination) (*model.RepositoryPaginatedRecords, error)
	CrListCreds(ctx context.Context, search *model.SearchCreds, pagination *repos.CursorPagination) (*model.CredentialPaginatedRecords, error)
	CrListTags(ctx context.Context, repoName string, search *model.SearchRepos, pagination *repos.CursorPagination) (*model.TagPaginatedRecords, error)
	CrGetCredToken(ctx context.Context, username string) (string, error)
	CrCheckUserNameAvailability(ctx context.Context, name string) (*domain.CheckNameAvailabilityOutput, error)
	CrGetBuild(ctx context.Context, id repos.ID) (*entities.Build, error)
	CrListBuilds(ctx context.Context, repoName string, search *model.SearchBuilds, pagination *repos.CursorPagination) (*model.BuildPaginatedRecords, error)
	CrListGithubInstallations(ctx context.Context, pagination *types.Pagination) ([]*entities.GithubInstallation, error)
	CrListGithubRepos(ctx context.Context, installationID int, pagination *types.Pagination) (*entities.GithubListRepository, error)
	CrSearchGithubRepos(ctx context.Context, organization string, search string, pagination *types.Pagination) (*entities.GithubSearchRepository, error)
	CrListGithubBranches(ctx context.Context, repoURL string, pagination *types.Pagination) ([]*entities.GithubBranch, error)
}
type RepositoryResolver interface {
	CreatedBy(ctx context.Context, obj *entities.Repository) (*model.KloudliteIoCommonCreatedOrUpdatedBy, error)
	CreationTime(ctx context.Context, obj *entities.Repository) (string, error)
	ID(ctx context.Context, obj *entities.Repository) (string, error)
	LastUpdatedBy(ctx context.Context, obj *entities.Repository) (*model.KloudliteIoCommonCreatedOrUpdatedBy, error)

	UpdateTime(ctx context.Context, obj *entities.Repository) (string, error)
}
type TagResolver interface {
	CreationTime(ctx context.Context, obj *entities.Tag) (string, error)

	ID(ctx context.Context, obj *entities.Tag) (string, error)

	References(ctx context.Context, obj *entities.Tag) ([]*model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesRepoReference, error)

	UpdateTime(ctx context.Context, obj *entities.Tag) (string, error)
}

type BuildInResolver interface {
	Source(ctx context.Context, obj *entities.Build, data *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGitSourceIn) error
}
type CredentialInResolver interface {
	Access(ctx context.Context, obj *entities.Credential, data model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesRepoAccess) error
	Expiration(ctx context.Context, obj *entities.Credential, data *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesExpirationIn) error
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec
	switch typeName + "." + field {

	case "Build.accountName":
		if e.complexity.Build.AccountName == nil {
			break
		}

		return e.complexity.Build.AccountName(childComplexity), true

	case "Build.createdBy":
		if e.complexity.Build.CreatedBy == nil {
			break
		}

		return e.complexity.Build.CreatedBy(childComplexity), true

	case "Build.creationTime":
		if e.complexity.Build.CreationTime == nil {
			break
		}

		return e.complexity.Build.CreationTime(childComplexity), true

	case "Build.id":
		if e.complexity.Build.ID == nil {
			break
		}

		return e.complexity.Build.ID(childComplexity), true

	case "Build.lastUpdatedBy":
		if e.complexity.Build.LastUpdatedBy == nil {
			break
		}

		return e.complexity.Build.LastUpdatedBy(childComplexity), true

	case "Build.markedForDeletion":
		if e.complexity.Build.MarkedForDeletion == nil {
			break
		}

		return e.complexity.Build.MarkedForDeletion(childComplexity), true

	case "Build.name":
		if e.complexity.Build.Name == nil {
			break
		}

		return e.complexity.Build.Name(childComplexity), true

	case "Build.recordVersion":
		if e.complexity.Build.RecordVersion == nil {
			break
		}

		return e.complexity.Build.RecordVersion(childComplexity), true

	case "Build.repository":
		if e.complexity.Build.Repository == nil {
			break
		}

		return e.complexity.Build.Repository(childComplexity), true

	case "Build.source":
		if e.complexity.Build.Source == nil {
			break
		}

		return e.complexity.Build.Source(childComplexity), true

	case "Build.tag":
		if e.complexity.Build.Tag == nil {
			break
		}

		return e.complexity.Build.Tag(childComplexity), true

	case "Build.updateTime":
		if e.complexity.Build.UpdateTime == nil {
			break
		}

		return e.complexity.Build.UpdateTime(childComplexity), true

	case "BuildEdge.cursor":
		if e.complexity.BuildEdge.Cursor == nil {
			break
		}

		return e.complexity.BuildEdge.Cursor(childComplexity), true

	case "BuildEdge.node":
		if e.complexity.BuildEdge.Node == nil {
			break
		}

		return e.complexity.BuildEdge.Node(childComplexity), true

	case "BuildPaginatedRecords.edges":
		if e.complexity.BuildPaginatedRecords.Edges == nil {
			break
		}

		return e.complexity.BuildPaginatedRecords.Edges(childComplexity), true

	case "BuildPaginatedRecords.pageInfo":
		if e.complexity.BuildPaginatedRecords.PageInfo == nil {
			break
		}

		return e.complexity.BuildPaginatedRecords.PageInfo(childComplexity), true

	case "BuildPaginatedRecords.totalCount":
		if e.complexity.BuildPaginatedRecords.TotalCount == nil {
			break
		}

		return e.complexity.BuildPaginatedRecords.TotalCount(childComplexity), true

	case "CRCheckNameAvailabilityOutput.result":
		if e.complexity.CRCheckNameAvailabilityOutput.Result == nil {
			break
		}

		return e.complexity.CRCheckNameAvailabilityOutput.Result(childComplexity), true

	case "CRCheckNameAvailabilityOutput.suggestedNames":
		if e.complexity.CRCheckNameAvailabilityOutput.SuggestedNames == nil {
			break
		}

		return e.complexity.CRCheckNameAvailabilityOutput.SuggestedNames(childComplexity), true

	case "Credential.access":
		if e.complexity.Credential.Access == nil {
			break
		}

		return e.complexity.Credential.Access(childComplexity), true

	case "Credential.accountName":
		if e.complexity.Credential.AccountName == nil {
			break
		}

		return e.complexity.Credential.AccountName(childComplexity), true

	case "Credential.createdBy":
		if e.complexity.Credential.CreatedBy == nil {
			break
		}

		return e.complexity.Credential.CreatedBy(childComplexity), true

	case "Credential.creationTime":
		if e.complexity.Credential.CreationTime == nil {
			break
		}

		return e.complexity.Credential.CreationTime(childComplexity), true

	case "Credential.expiration":
		if e.complexity.Credential.Expiration == nil {
			break
		}

		return e.complexity.Credential.Expiration(childComplexity), true

	case "Credential.id":
		if e.complexity.Credential.ID == nil {
			break
		}

		return e.complexity.Credential.ID(childComplexity), true

	case "Credential.lastUpdatedBy":
		if e.complexity.Credential.LastUpdatedBy == nil {
			break
		}

		return e.complexity.Credential.LastUpdatedBy(childComplexity), true

	case "Credential.markedForDeletion":
		if e.complexity.Credential.MarkedForDeletion == nil {
			break
		}

		return e.complexity.Credential.MarkedForDeletion(childComplexity), true

	case "Credential.name":
		if e.complexity.Credential.Name == nil {
			break
		}

		return e.complexity.Credential.Name(childComplexity), true

	case "Credential.recordVersion":
		if e.complexity.Credential.RecordVersion == nil {
			break
		}

		return e.complexity.Credential.RecordVersion(childComplexity), true

	case "Credential.updateTime":
		if e.complexity.Credential.UpdateTime == nil {
			break
		}

		return e.complexity.Credential.UpdateTime(childComplexity), true

	case "Credential.username":
		if e.complexity.Credential.UserName == nil {
			break
		}

		return e.complexity.Credential.UserName(childComplexity), true

	case "CredentialEdge.cursor":
		if e.complexity.CredentialEdge.Cursor == nil {
			break
		}

		return e.complexity.CredentialEdge.Cursor(childComplexity), true

	case "CredentialEdge.node":
		if e.complexity.CredentialEdge.Node == nil {
			break
		}

		return e.complexity.CredentialEdge.Node(childComplexity), true

	case "CredentialPaginatedRecords.edges":
		if e.complexity.CredentialPaginatedRecords.Edges == nil {
			break
		}

		return e.complexity.CredentialPaginatedRecords.Edges(childComplexity), true

	case "CredentialPaginatedRecords.pageInfo":
		if e.complexity.CredentialPaginatedRecords.PageInfo == nil {
			break
		}

		return e.complexity.CredentialPaginatedRecords.PageInfo(childComplexity), true

	case "CredentialPaginatedRecords.totalCount":
		if e.complexity.CredentialPaginatedRecords.TotalCount == nil {
			break
		}

		return e.complexity.CredentialPaginatedRecords.TotalCount(childComplexity), true

	case "CursorPagination.after":
		if e.complexity.CursorPagination.After == nil {
			break
		}

		return e.complexity.CursorPagination.After(childComplexity), true

	case "CursorPagination.before":
		if e.complexity.CursorPagination.Before == nil {
			break
		}

		return e.complexity.CursorPagination.Before(childComplexity), true

	case "CursorPagination.first":
		if e.complexity.CursorPagination.First == nil {
			break
		}

		return e.complexity.CursorPagination.First(childComplexity), true

	case "CursorPagination.last":
		if e.complexity.CursorPagination.Last == nil {
			break
		}

		return e.complexity.CursorPagination.Last(childComplexity), true

	case "CursorPagination.orderBy":
		if e.complexity.CursorPagination.OrderBy == nil {
			break
		}

		return e.complexity.CursorPagination.OrderBy(childComplexity), true

	case "CursorPagination.sortDirection":
		if e.complexity.CursorPagination.SortDirection == nil {
			break
		}

		return e.complexity.CursorPagination.SortDirection(childComplexity), true

	case "GithubBranch.name":
		if e.complexity.GithubBranch.Name == nil {
			break
		}

		return e.complexity.GithubBranch.Name(childComplexity), true

	case "GithubBranch.protected":
		if e.complexity.GithubBranch.Protected == nil {
			break
		}

		return e.complexity.GithubBranch.Protected(childComplexity), true

	case "GithubInstallation.account":
		if e.complexity.GithubInstallation.Account == nil {
			break
		}

		return e.complexity.GithubInstallation.Account(childComplexity), true

	case "GithubInstallation.app_id":
		if e.complexity.GithubInstallation.AppID == nil {
			break
		}

		return e.complexity.GithubInstallation.AppID(childComplexity), true

	case "GithubInstallation.id":
		if e.complexity.GithubInstallation.ID == nil {
			break
		}

		return e.complexity.GithubInstallation.ID(childComplexity), true

	case "GithubInstallation.node_id":
		if e.complexity.GithubInstallation.NodeID == nil {
			break
		}

		return e.complexity.GithubInstallation.NodeID(childComplexity), true

	case "GithubInstallation.repositories_url":
		if e.complexity.GithubInstallation.RepositoriesURL == nil {
			break
		}

		return e.complexity.GithubInstallation.RepositoriesURL(childComplexity), true

	case "GithubInstallation.target_id":
		if e.complexity.GithubInstallation.TargetID == nil {
			break
		}

		return e.complexity.GithubInstallation.TargetID(childComplexity), true

	case "GithubInstallation.target_type":
		if e.complexity.GithubInstallation.TargetType == nil {
			break
		}

		return e.complexity.GithubInstallation.TargetType(childComplexity), true

	case "GithubListRepository.repositories":
		if e.complexity.GithubListRepository.Repositories == nil {
			break
		}

		return e.complexity.GithubListRepository.Repositories(childComplexity), true

	case "GithubListRepository.total_count":
		if e.complexity.GithubListRepository.TotalCount == nil {
			break
		}

		return e.complexity.GithubListRepository.TotalCount(childComplexity), true

	case "GithubSearchRepository.incomplete_results":
		if e.complexity.GithubSearchRepository.IncompleteResults == nil {
			break
		}

		return e.complexity.GithubSearchRepository.IncompleteResults(childComplexity), true

	case "GithubSearchRepository.repositories":
		if e.complexity.GithubSearchRepository.Repositories == nil {
			break
		}

		return e.complexity.GithubSearchRepository.Repositories(childComplexity), true

	case "GithubSearchRepository.total":
		if e.complexity.GithubSearchRepository.Total == nil {
			break
		}

		return e.complexity.GithubSearchRepository.Total(childComplexity), true

	case "Kloudlite_io__apps__container___registry__internal__domain__entities_Expiration.unit":
		if e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_Expiration.Unit == nil {
			break
		}

		return e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_Expiration.Unit(childComplexity), true

	case "Kloudlite_io__apps__container___registry__internal__domain__entities_Expiration.value":
		if e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_Expiration.Value == nil {
			break
		}

		return e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_Expiration.Value(childComplexity), true

	case "Kloudlite_io__apps__container___registry__internal__domain__entities_GitSource.branch":
		if e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GitSource.Branch == nil {
			break
		}

		return e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GitSource.Branch(childComplexity), true

	case "Kloudlite_io__apps__container___registry__internal__domain__entities_GitSource.pullSecret":
		if e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GitSource.PullSecret == nil {
			break
		}

		return e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GitSource.PullSecret(childComplexity), true

	case "Kloudlite_io__apps__container___registry__internal__domain__entities_GitSource.repository":
		if e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GitSource.Repository == nil {
			break
		}

		return e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GitSource.Repository(childComplexity), true

	case "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.archived":
		if e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.Archived == nil {
			break
		}

		return e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.Archived(childComplexity), true

	case "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.clone_url":
		if e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.CloneURL == nil {
			break
		}

		return e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.CloneURL(childComplexity), true

	case "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.created_at":
		if e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.CreatedAt == nil {
			break
		}

		return e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.CreatedAt(childComplexity), true

	case "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.default_branch":
		if e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.DefaultBranch == nil {
			break
		}

		return e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.DefaultBranch(childComplexity), true

	case "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.description":
		if e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.Description == nil {
			break
		}

		return e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.Description(childComplexity), true

	case "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.disabled":
		if e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.Disabled == nil {
			break
		}

		return e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.Disabled(childComplexity), true

	case "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.full_name":
		if e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.FullName == nil {
			break
		}

		return e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.FullName(childComplexity), true

	case "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.git_url":
		if e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.GitURL == nil {
			break
		}

		return e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.GitURL(childComplexity), true

	case "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.gitignore_template":
		if e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.GitignoreTemplate == nil {
			break
		}

		return e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.GitignoreTemplate(childComplexity), true

	case "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.html_url":
		if e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.HTMLURL == nil {
			break
		}

		return e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.HTMLURL(childComplexity), true

	case "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.id":
		if e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.ID == nil {
			break
		}

		return e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.ID(childComplexity), true

	case "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.language":
		if e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.Language == nil {
			break
		}

		return e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.Language(childComplexity), true

	case "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.master_branch":
		if e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.MasterBranch == nil {
			break
		}

		return e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.MasterBranch(childComplexity), true

	case "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.mirror_url":
		if e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.MirrorURL == nil {
			break
		}

		return e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.MirrorURL(childComplexity), true

	case "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.name":
		if e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.Name == nil {
			break
		}

		return e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.Name(childComplexity), true

	case "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.node_id":
		if e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.NodeID == nil {
			break
		}

		return e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.NodeID(childComplexity), true

	case "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.permissions":
		if e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.Permissions == nil {
			break
		}

		return e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.Permissions(childComplexity), true

	case "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.private":
		if e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.Private == nil {
			break
		}

		return e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.Private(childComplexity), true

	case "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.pushed_at":
		if e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.PushedAt == nil {
			break
		}

		return e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.PushedAt(childComplexity), true

	case "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.size":
		if e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.Size == nil {
			break
		}

		return e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.Size(childComplexity), true

	case "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.team_id":
		if e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.TeamID == nil {
			break
		}

		return e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.TeamID(childComplexity), true

	case "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.url":
		if e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.URL == nil {
			break
		}

		return e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.URL(childComplexity), true

	case "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.updated_at":
		if e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.UpdatedAt == nil {
			break
		}

		return e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.UpdatedAt(childComplexity), true

	case "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.visibility":
		if e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.Visibility == nil {
			break
		}

		return e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.Visibility(childComplexity), true

	case "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount.avatar_url":
		if e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount.AvatarURL == nil {
			break
		}

		return e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount.AvatarURL(childComplexity), true

	case "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount.id":
		if e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount.ID == nil {
			break
		}

		return e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount.ID(childComplexity), true

	case "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount.login":
		if e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount.Login == nil {
			break
		}

		return e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount.Login(childComplexity), true

	case "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount.node_id":
		if e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount.NodeID == nil {
			break
		}

		return e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount.NodeID(childComplexity), true

	case "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount.type":
		if e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount.Type == nil {
			break
		}

		return e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount.Type(childComplexity), true

	case "Kloudlite_io__apps__container___registry__internal__domain__entities_RepoReference.digest":
		if e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_RepoReference.Digest == nil {
			break
		}

		return e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_RepoReference.Digest(childComplexity), true

	case "Kloudlite_io__apps__container___registry__internal__domain__entities_RepoReference.mediaType":
		if e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_RepoReference.MediaType == nil {
			break
		}

		return e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_RepoReference.MediaType(childComplexity), true

	case "Kloudlite_io__apps__container___registry__internal__domain__entities_RepoReference.size":
		if e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_RepoReference.Size == nil {
			break
		}

		return e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_RepoReference.Size(childComplexity), true

	case "Kloudlite_io__common_CreatedOrUpdatedBy.userEmail":
		if e.complexity.Kloudlite_io__common_CreatedOrUpdatedBy.UserEmail == nil {
			break
		}

		return e.complexity.Kloudlite_io__common_CreatedOrUpdatedBy.UserEmail(childComplexity), true

	case "Kloudlite_io__common_CreatedOrUpdatedBy.userId":
		if e.complexity.Kloudlite_io__common_CreatedOrUpdatedBy.UserID == nil {
			break
		}

		return e.complexity.Kloudlite_io__common_CreatedOrUpdatedBy.UserID(childComplexity), true

	case "Kloudlite_io__common_CreatedOrUpdatedBy.userName":
		if e.complexity.Kloudlite_io__common_CreatedOrUpdatedBy.UserName == nil {
			break
		}

		return e.complexity.Kloudlite_io__common_CreatedOrUpdatedBy.UserName(childComplexity), true

	case "MatchFilter.array":
		if e.complexity.MatchFilter.Array == nil {
			break
		}

		return e.complexity.MatchFilter.Array(childComplexity), true

	case "MatchFilter.exact":
		if e.complexity.MatchFilter.Exact == nil {
			break
		}

		return e.complexity.MatchFilter.Exact(childComplexity), true

	case "MatchFilter.matchType":
		if e.complexity.MatchFilter.MatchType == nil {
			break
		}

		return e.complexity.MatchFilter.MatchType(childComplexity), true

	case "MatchFilter.regex":
		if e.complexity.MatchFilter.Regex == nil {
			break
		}

		return e.complexity.MatchFilter.Regex(childComplexity), true

	case "Mutation.cr_addBuild":
		if e.complexity.Mutation.CrAddBuild == nil {
			break
		}

		args, err := ec.field_Mutation_cr_addBuild_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CrAddBuild(childComplexity, args["build"].(entities.Build)), true

	case "Mutation.cr_createCred":
		if e.complexity.Mutation.CrCreateCred == nil {
			break
		}

		args, err := ec.field_Mutation_cr_createCred_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CrCreateCred(childComplexity, args["credential"].(entities.Credential)), true

	case "Mutation.cr_createRepo":
		if e.complexity.Mutation.CrCreateRepo == nil {
			break
		}

		args, err := ec.field_Mutation_cr_createRepo_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CrCreateRepo(childComplexity, args["repository"].(entities.Repository)), true

	case "Mutation.cr_deleteBuild":
		if e.complexity.Mutation.CrDeleteBuild == nil {
			break
		}

		args, err := ec.field_Mutation_cr_deleteBuild_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CrDeleteBuild(childComplexity, args["id"].(repos.ID)), true

	case "Mutation.cr_deleteCred":
		if e.complexity.Mutation.CrDeleteCred == nil {
			break
		}

		args, err := ec.field_Mutation_cr_deleteCred_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CrDeleteCred(childComplexity, args["username"].(string)), true

	case "Mutation.cr_deleteRepo":
		if e.complexity.Mutation.CrDeleteRepo == nil {
			break
		}

		args, err := ec.field_Mutation_cr_deleteRepo_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CrDeleteRepo(childComplexity, args["name"].(string)), true

	case "Mutation.cr_deleteTag":
		if e.complexity.Mutation.CrDeleteTag == nil {
			break
		}

		args, err := ec.field_Mutation_cr_deleteTag_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CrDeleteTag(childComplexity, args["repoName"].(string), args["digest"].(string)), true

	case "Mutation.cr_triggerBuild":
		if e.complexity.Mutation.CrTriggerBuild == nil {
			break
		}

		args, err := ec.field_Mutation_cr_triggerBuild_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CrTriggerBuild(childComplexity, args["id"].(repos.ID)), true

	case "Mutation.cr_updateBuild":
		if e.complexity.Mutation.CrUpdateBuild == nil {
			break
		}

		args, err := ec.field_Mutation_cr_updateBuild_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CrUpdateBuild(childComplexity, args["id"].(repos.ID), args["build"].(entities.Build)), true

	case "PageInfo.endCursor":
		if e.complexity.PageInfo.EndCursor == nil {
			break
		}

		return e.complexity.PageInfo.EndCursor(childComplexity), true

	case "PageInfo.hasNextPage":
		if e.complexity.PageInfo.HasNextPage == nil {
			break
		}

		return e.complexity.PageInfo.HasNextPage(childComplexity), true

	case "PageInfo.hasPreviousPage":
		if e.complexity.PageInfo.HasPreviousPage == nil {
			break
		}

		return e.complexity.PageInfo.HasPreviousPage(childComplexity), true

	case "PageInfo.startCursor":
		if e.complexity.PageInfo.StartCursor == nil {
			break
		}

		return e.complexity.PageInfo.StartCursor(childComplexity), true

	case "Pagination.page":
		if e.complexity.Pagination.Page == nil {
			break
		}

		return e.complexity.Pagination.Page(childComplexity), true

	case "Pagination.per_page":
		if e.complexity.Pagination.PerPage == nil {
			break
		}

		return e.complexity.Pagination.PerPage(childComplexity), true

	case "Query.cr_checkUserNameAvailability":
		if e.complexity.Query.CrCheckUserNameAvailability == nil {
			break
		}

		args, err := ec.field_Query_cr_checkUserNameAvailability_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CrCheckUserNameAvailability(childComplexity, args["name"].(string)), true

	case "Query.cr_getBuild":
		if e.complexity.Query.CrGetBuild == nil {
			break
		}

		args, err := ec.field_Query_cr_getBuild_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CrGetBuild(childComplexity, args["id"].(repos.ID)), true

	case "Query.cr_getCredToken":
		if e.complexity.Query.CrGetCredToken == nil {
			break
		}

		args, err := ec.field_Query_cr_getCredToken_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CrGetCredToken(childComplexity, args["username"].(string)), true

	case "Query.cr_listBuilds":
		if e.complexity.Query.CrListBuilds == nil {
			break
		}

		args, err := ec.field_Query_cr_listBuilds_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CrListBuilds(childComplexity, args["repoName"].(string), args["search"].(*model.SearchBuilds), args["pagination"].(*repos.CursorPagination)), true

	case "Query.cr_listCreds":
		if e.complexity.Query.CrListCreds == nil {
			break
		}

		args, err := ec.field_Query_cr_listCreds_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CrListCreds(childComplexity, args["search"].(*model.SearchCreds), args["pagination"].(*repos.CursorPagination)), true

	case "Query.cr_listGithubBranches":
		if e.complexity.Query.CrListGithubBranches == nil {
			break
		}

		args, err := ec.field_Query_cr_listGithubBranches_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CrListGithubBranches(childComplexity, args["repoUrl"].(string), args["pagination"].(*types.Pagination)), true

	case "Query.cr_listGithubInstallations":
		if e.complexity.Query.CrListGithubInstallations == nil {
			break
		}

		args, err := ec.field_Query_cr_listGithubInstallations_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CrListGithubInstallations(childComplexity, args["pagination"].(*types.Pagination)), true

	case "Query.cr_listGithubRepos":
		if e.complexity.Query.CrListGithubRepos == nil {
			break
		}

		args, err := ec.field_Query_cr_listGithubRepos_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CrListGithubRepos(childComplexity, args["installationId"].(int), args["pagination"].(*types.Pagination)), true

	case "Query.cr_listRepos":
		if e.complexity.Query.CrListRepos == nil {
			break
		}

		args, err := ec.field_Query_cr_listRepos_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CrListRepos(childComplexity, args["search"].(*model.SearchRepos), args["pagination"].(*repos.CursorPagination)), true

	case "Query.cr_listTags":
		if e.complexity.Query.CrListTags == nil {
			break
		}

		args, err := ec.field_Query_cr_listTags_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CrListTags(childComplexity, args["repoName"].(string), args["search"].(*model.SearchRepos), args["pagination"].(*repos.CursorPagination)), true

	case "Query.cr_searchGithubRepos":
		if e.complexity.Query.CrSearchGithubRepos == nil {
			break
		}

		args, err := ec.field_Query_cr_searchGithubRepos_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CrSearchGithubRepos(childComplexity, args["organization"].(string), args["search"].(string), args["pagination"].(*types.Pagination)), true

	case "Query._service":
		if e.complexity.Query.__resolve__service == nil {
			break
		}

		return e.complexity.Query.__resolve__service(childComplexity), true

	case "Repository.accountName":
		if e.complexity.Repository.AccountName == nil {
			break
		}

		return e.complexity.Repository.AccountName(childComplexity), true

	case "Repository.createdBy":
		if e.complexity.Repository.CreatedBy == nil {
			break
		}

		return e.complexity.Repository.CreatedBy(childComplexity), true

	case "Repository.creationTime":
		if e.complexity.Repository.CreationTime == nil {
			break
		}

		return e.complexity.Repository.CreationTime(childComplexity), true

	case "Repository.id":
		if e.complexity.Repository.ID == nil {
			break
		}

		return e.complexity.Repository.ID(childComplexity), true

	case "Repository.lastUpdatedBy":
		if e.complexity.Repository.LastUpdatedBy == nil {
			break
		}

		return e.complexity.Repository.LastUpdatedBy(childComplexity), true

	case "Repository.markedForDeletion":
		if e.complexity.Repository.MarkedForDeletion == nil {
			break
		}

		return e.complexity.Repository.MarkedForDeletion(childComplexity), true

	case "Repository.name":
		if e.complexity.Repository.Name == nil {
			break
		}

		return e.complexity.Repository.Name(childComplexity), true

	case "Repository.recordVersion":
		if e.complexity.Repository.RecordVersion == nil {
			break
		}

		return e.complexity.Repository.RecordVersion(childComplexity), true

	case "Repository.updateTime":
		if e.complexity.Repository.UpdateTime == nil {
			break
		}

		return e.complexity.Repository.UpdateTime(childComplexity), true

	case "RepositoryEdge.cursor":
		if e.complexity.RepositoryEdge.Cursor == nil {
			break
		}

		return e.complexity.RepositoryEdge.Cursor(childComplexity), true

	case "RepositoryEdge.node":
		if e.complexity.RepositoryEdge.Node == nil {
			break
		}

		return e.complexity.RepositoryEdge.Node(childComplexity), true

	case "RepositoryPaginatedRecords.edges":
		if e.complexity.RepositoryPaginatedRecords.Edges == nil {
			break
		}

		return e.complexity.RepositoryPaginatedRecords.Edges(childComplexity), true

	case "RepositoryPaginatedRecords.pageInfo":
		if e.complexity.RepositoryPaginatedRecords.PageInfo == nil {
			break
		}

		return e.complexity.RepositoryPaginatedRecords.PageInfo(childComplexity), true

	case "RepositoryPaginatedRecords.totalCount":
		if e.complexity.RepositoryPaginatedRecords.TotalCount == nil {
			break
		}

		return e.complexity.RepositoryPaginatedRecords.TotalCount(childComplexity), true

	case "Tag.accountName":
		if e.complexity.Tag.AccountName == nil {
			break
		}

		return e.complexity.Tag.AccountName(childComplexity), true

	case "Tag.actor":
		if e.complexity.Tag.Actor == nil {
			break
		}

		return e.complexity.Tag.Actor(childComplexity), true

	case "Tag.creationTime":
		if e.complexity.Tag.CreationTime == nil {
			break
		}

		return e.complexity.Tag.CreationTime(childComplexity), true

	case "Tag.deleting":
		if e.complexity.Tag.Deleting == nil {
			break
		}

		return e.complexity.Tag.Deleting(childComplexity), true

	case "Tag.digest":
		if e.complexity.Tag.Digest == nil {
			break
		}

		return e.complexity.Tag.Digest(childComplexity), true

	case "Tag.id":
		if e.complexity.Tag.ID == nil {
			break
		}

		return e.complexity.Tag.ID(childComplexity), true

	case "Tag.length":
		if e.complexity.Tag.Length == nil {
			break
		}

		return e.complexity.Tag.Length(childComplexity), true

	case "Tag.markedForDeletion":
		if e.complexity.Tag.MarkedForDeletion == nil {
			break
		}

		return e.complexity.Tag.MarkedForDeletion(childComplexity), true

	case "Tag.mediaType":
		if e.complexity.Tag.MediaType == nil {
			break
		}

		return e.complexity.Tag.MediaType(childComplexity), true

	case "Tag.recordVersion":
		if e.complexity.Tag.RecordVersion == nil {
			break
		}

		return e.complexity.Tag.RecordVersion(childComplexity), true

	case "Tag.references":
		if e.complexity.Tag.References == nil {
			break
		}

		return e.complexity.Tag.References(childComplexity), true

	case "Tag.repository":
		if e.complexity.Tag.Repository == nil {
			break
		}

		return e.complexity.Tag.Repository(childComplexity), true

	case "Tag.size":
		if e.complexity.Tag.Size == nil {
			break
		}

		return e.complexity.Tag.Size(childComplexity), true

	case "Tag.tags":
		if e.complexity.Tag.Tags == nil {
			break
		}

		return e.complexity.Tag.Tags(childComplexity), true

	case "Tag.url":
		if e.complexity.Tag.URL == nil {
			break
		}

		return e.complexity.Tag.URL(childComplexity), true

	case "Tag.updateTime":
		if e.complexity.Tag.UpdateTime == nil {
			break
		}

		return e.complexity.Tag.UpdateTime(childComplexity), true

	case "TagEdge.cursor":
		if e.complexity.TagEdge.Cursor == nil {
			break
		}

		return e.complexity.TagEdge.Cursor(childComplexity), true

	case "TagEdge.node":
		if e.complexity.TagEdge.Node == nil {
			break
		}

		return e.complexity.TagEdge.Node(childComplexity), true

	case "TagPaginatedRecords.edges":
		if e.complexity.TagPaginatedRecords.Edges == nil {
			break
		}

		return e.complexity.TagPaginatedRecords.Edges(childComplexity), true

	case "TagPaginatedRecords.pageInfo":
		if e.complexity.TagPaginatedRecords.PageInfo == nil {
			break
		}

		return e.complexity.TagPaginatedRecords.PageInfo(childComplexity), true

	case "TagPaginatedRecords.totalCount":
		if e.complexity.TagPaginatedRecords.TotalCount == nil {
			break
		}

		return e.complexity.TagPaginatedRecords.TotalCount(childComplexity), true

	case "_Service.sdl":
		if e.complexity._Service.SDL == nil {
			break
		}

		return e.complexity._Service.SDL(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputBuildIn,
		ec.unmarshalInputCredentialIn,
		ec.unmarshalInputCursorPaginationIn,
		ec.unmarshalInputKloudlite_io__apps__container___registry__internal__domain__entities_ExpirationIn,
		ec.unmarshalInputKloudlite_io__apps__container___registry__internal__domain__entities_GitSourceIn,
		ec.unmarshalInputKloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccountIn,
		ec.unmarshalInputMatchFilterIn,
		ec.unmarshalInputPaginationIn,
		ec.unmarshalInputRepositoryIn,
		ec.unmarshalInputSearchBuilds,
		ec.unmarshalInputSearchCreds,
		ec.unmarshalInputSearchRepos,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Query(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schema.graphqls", Input: `directive @isLoggedInAndVerified on FIELD_DEFINITION
directive @hasAccount on FIELD_DEFINITION

input SearchRepos {
  text: MatchFilterIn
}

input  SearchCreds {
  text: MatchFilterIn
}

input  SearchBuilds {
  text: MatchFilterIn
}

type CRCheckNameAvailabilityOutput @shareable {
  result: Boolean!
  suggestedNames: [String!]
}

type Query {
  cr_listRepos(search:SearchRepos, pagination:CursorPaginationIn) : RepositoryPaginatedRecords @isLoggedInAndVerified @hasAccount
  cr_listCreds(search:SearchCreds, pagination:CursorPaginationIn) : CredentialPaginatedRecords @isLoggedInAndVerified @hasAccount
  cr_listTags(repoName:String!, search: SearchRepos, pagination:CursorPaginationIn) : TagPaginatedRecords @isLoggedInAndVerified @hasAccount

  cr_getCredToken(username:String!) : String! @isLoggedInAndVerified @hasAccount

  cr_checkUserNameAvailability(name:String!) :CRCheckNameAvailabilityOutput! @isLoggedInAndVerified @hasAccount

  cr_getBuild(id:ID!) : Build @isLoggedInAndVerified @hasAccount
  cr_listBuilds(repoName:String!, search:SearchBuilds, pagination:CursorPaginationIn) : BuildPaginatedRecords @isLoggedInAndVerified @hasAccount

  cr_listGithubInstallations(pagination:PaginationIn) : [GithubInstallation] @isLoggedInAndVerified @hasAccount
  cr_listGithubRepos(installationId:Int!, pagination:PaginationIn) : GithubListRepository @isLoggedInAndVerified @hasAccount
  cr_searchGithubRepos(organization:String!, search:String!, pagination:PaginationIn) : GithubSearchRepository @isLoggedInAndVerified @hasAccount
  cr_listGithubBranches(repoUrl:String!, pagination:PaginationIn) : [GithubBranch] @isLoggedInAndVerified @hasAccount
}

type Mutation {
  cr_createRepo(repository:RepositoryIn!) : Repository @isLoggedInAndVerified @hasAccount
  cr_createCred(credential: CredentialIn!) : Credential @isLoggedInAndVerified @hasAccount

  cr_deleteRepo(name:String!) :Boolean! @isLoggedInAndVerified @hasAccount
  cr_deleteCred(username:String!) :Boolean! @isLoggedInAndVerified @hasAccount
  cr_deleteTag(repoName:String!, digest:String!) :Boolean! @isLoggedInAndVerified @hasAccount


  cr_addBuild(build:BuildIn!) : Build @isLoggedInAndVerified @hasAccount
  cr_updateBuild(id:ID!, build:BuildIn!) : Build @isLoggedInAndVerified @hasAccount
  cr_deleteBuild(id:ID!) : Boolean! @isLoggedInAndVerified @hasAccount
  cr_triggerBuild(id:ID!) : Boolean! @isLoggedInAndVerified @hasAccount
}
`, BuiltIn: false},
	{Name: "../struct-to-graphql/build.graphqls", Input: `type Build @shareable {
  accountName: String!
  createdBy: Kloudlite_io__common_CreatedOrUpdatedBy!
  creationTime: Date!
  id: String!
  lastUpdatedBy: Kloudlite_io__common_CreatedOrUpdatedBy!
  markedForDeletion: Boolean
  name: String!
  recordVersion: Int!
  repository: String!
  source: Kloudlite_io__apps__container___registry__internal__domain__entities_GitSource!
  tag: String!
  updateTime: Date!
}

type BuildEdge @shareable {
  cursor: String!
  node: Build!
}

type BuildPaginatedRecords @shareable {
  edges: [BuildEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input BuildIn {
  name: String!
  repository: String!
  source: Kloudlite_io__apps__container___registry__internal__domain__entities_GitSourceIn!
  tag: String!
}

`, BuiltIn: false},
	{Name: "../struct-to-graphql/common-types.graphqls", Input: `type Kloudlite_io__apps__container___registry__internal__domain__entities_Expiration @shareable {
  unit: Kloudlite_io__apps__container___registry__internal__domain__entities_ExpirationUnit!
  value: Int!
}

type Kloudlite_io__apps__container___registry__internal__domain__entities_GitSource @shareable {
  branch: String!
  pullSecret: String
  repository: String!
}

type Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository @shareable {
  archived: Boolean
  clone_url: String
  created_at: Date
  default_branch: String
  description: String
  disabled: Boolean
  full_name: String
  git_url: String
  gitignore_template: String
  html_url: String
  id: Int
  language: String
  master_branch: String
  mirror_url: String
  name: String
  node_id: String
  permissions: Map
  private: Boolean
  pushed_at: Date
  size: Int
  team_id: Int
  updated_at: Date
  url: String
  visibility: String
}

type Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount @shareable {
  avatar_url: String
  id: Int
  login: String
  node_id: String
  type: String
}

type Kloudlite_io__apps__container___registry__internal__domain__entities_RepoReference @shareable {
  digest: String!
  mediaType: String!
  size: Int!
}

type Kloudlite_io__common_CreatedOrUpdatedBy @shareable {
  userEmail: String!
  userId: String!
  userName: String!
}

type PageInfo @shareable {
  endCursor: String
  hasNextPage: Boolean
  hasPreviousPage: Boolean
  startCursor: String
}

input Kloudlite_io__apps__container___registry__internal__domain__entities_ExpirationIn {
  unit: Kloudlite_io__apps__container___registry__internal__domain__entities_ExpirationUnit!
  value: Int!
}

input Kloudlite_io__apps__container___registry__internal__domain__entities_GitSourceIn {
  branch: String!
  pullSecret: String
  repository: String!
}

input Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccountIn {
  avatar_url: String
  id: Int
  login: String
  node_id: String
  type: String
}

enum Kloudlite_io__apps__container___registry__internal__domain__entities_ExpirationUnit {
  d
  h
  m
  w
  y
}

enum Kloudlite_io__apps__container___registry__internal__domain__entities_RepoAccess {
  read
  read_write
}

`, BuiltIn: false},
	{Name: "../struct-to-graphql/credential.graphqls", Input: `type Credential @shareable {
  access: Kloudlite_io__apps__container___registry__internal__domain__entities_RepoAccess!
  accountName: String!
  createdBy: Kloudlite_io__common_CreatedOrUpdatedBy!
  creationTime: Date!
  expiration: Kloudlite_io__apps__container___registry__internal__domain__entities_Expiration!
  id: String!
  lastUpdatedBy: Kloudlite_io__common_CreatedOrUpdatedBy!
  markedForDeletion: Boolean
  name: String!
  recordVersion: Int!
  updateTime: Date!
  username: String!
}

type CredentialEdge @shareable {
  cursor: String!
  node: Credential!
}

type CredentialPaginatedRecords @shareable {
  edges: [CredentialEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input CredentialIn {
  access: Kloudlite_io__apps__container___registry__internal__domain__entities_RepoAccess!
  expiration: Kloudlite_io__apps__container___registry__internal__domain__entities_ExpirationIn!
  name: String!
  username: String!
}

`, BuiltIn: false},
	{Name: "../struct-to-graphql/cursorpagination.graphqls", Input: `type CursorPagination @shareable {
  after: String
  before: String
  first: Int
  last: Int
  orderBy: String
  sortDirection: CursorPaginationSortDirection
}

input CursorPaginationIn {
  after: String
  before: String
  first: Int
  last: Int
  orderBy: String = "_id"
  sortDirection: CursorPaginationSortDirection = "ASC"
}

enum CursorPaginationSortDirection {
  ASC
  DESC
}

`, BuiltIn: false},
	{Name: "../struct-to-graphql/directives.graphqls", Input: `extend schema @link(url: "https://specs.apollo.dev/federation/v2.0", import: ["@key", "@shareable", "@external"])

directive @goField(
	forceResolver: Boolean
	name: String
) on INPUT_FIELD_DEFINITION | FIELD_DEFINITION
`, BuiltIn: false},
	{Name: "../struct-to-graphql/githubbranch.graphqls", Input: `type GithubBranch @shareable {
  name: String
  protected: Boolean
}

`, BuiltIn: false},
	{Name: "../struct-to-graphql/githubinstallation.graphqls", Input: `type GithubInstallation @shareable {
  account: Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount
  app_id: Int
  id: Int
  node_id: String
  repositories_url: String
  target_id: Int
  target_type: String
}

`, BuiltIn: false},
	{Name: "../struct-to-graphql/githublistrepository.graphqls", Input: `type GithubListRepository @shareable {
  repositories: [Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository]!
  total_count: Int
}

`, BuiltIn: false},
	{Name: "../struct-to-graphql/githubsearchrepository.graphqls", Input: `type GithubSearchRepository @shareable {
  incomplete_results: Boolean
  repositories: [Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository]!
  total: Int
}

`, BuiltIn: false},
	{Name: "../struct-to-graphql/matchfilter.graphqls", Input: `type MatchFilter @shareable {
  array: [Any!]
  exact: Any
  matchType: MatchFilterMatchType!
  regex: String
}

input MatchFilterIn {
  array: [Any!]
  exact: Any
  matchType: MatchFilterMatchType!
  regex: String
}

enum MatchFilterMatchType {
  array
  exact
  regex
}

`, BuiltIn: false},
	{Name: "../struct-to-graphql/pagination.graphqls", Input: `type Pagination @shareable {
  page: Int
  per_page: Int
}

input PaginationIn {
  page: Int
  per_page: Int
}

`, BuiltIn: false},
	{Name: "../struct-to-graphql/repository.graphqls", Input: `type Repository @shareable {
  accountName: String!
  createdBy: Kloudlite_io__common_CreatedOrUpdatedBy!
  creationTime: Date!
  id: String!
  lastUpdatedBy: Kloudlite_io__common_CreatedOrUpdatedBy!
  markedForDeletion: Boolean
  name: String!
  recordVersion: Int!
  updateTime: Date!
}

type RepositoryEdge @shareable {
  cursor: String!
  node: Repository!
}

type RepositoryPaginatedRecords @shareable {
  edges: [RepositoryEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input RepositoryIn {
  name: String!
}

`, BuiltIn: false},
	{Name: "../struct-to-graphql/scalars.graphqls", Input: `scalar Any
scalar Json
scalar Map
scalar Date
`, BuiltIn: false},
	{Name: "../struct-to-graphql/tag.graphqls", Input: `type Tag @shareable {
  accountName: String!
  actor: String!
  creationTime: Date!
  deleting: Boolean!
  digest: String!
  id: String!
  length: Int!
  markedForDeletion: Boolean
  mediaType: String!
  recordVersion: Int!
  references: [Kloudlite_io__apps__container___registry__internal__domain__entities_RepoReference!]!
  repository: String!
  size: Int!
  tags: [String!]!
  updateTime: Date!
  url: String!
}

type TagEdge @shareable {
  cursor: String!
  node: Tag!
}

type TagPaginatedRecords @shareable {
  edges: [TagEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

`, BuiltIn: false},
	{Name: "../../federation/directives.graphql", Input: `
	scalar _Any
	scalar _FieldSet
	directive @requires(fields: _FieldSet!) on FIELD_DEFINITION
	directive @provides(fields: _FieldSet!) on FIELD_DEFINITION
	directive @extends on OBJECT | INTERFACE

	directive @key(fields: _FieldSet!, resolvable: Boolean = true) repeatable on OBJECT | INTERFACE
	directive @external on FIELD_DEFINITION | OBJECT
	directive @link(import: [String!], url: String!) repeatable on SCHEMA
	directive @shareable on OBJECT | FIELD_DEFINITION
	directive @tag(name: String!) repeatable on FIELD_DEFINITION | INTERFACE | OBJECT | UNION | ARGUMENT_DEFINITION | SCALAR | ENUM | ENUM_VALUE | INPUT_OBJECT | INPUT_FIELD_DEFINITION
	directive @override(from: String!) on FIELD_DEFINITION
	directive @inaccessible on SCALAR | OBJECT | FIELD_DEFINITION | ARGUMENT_DEFINITION | INTERFACE | UNION | ENUM | ENUM_VALUE | INPUT_OBJECT | INPUT_FIELD_DEFINITION
`, BuiltIn: true},
	{Name: "../../federation/entity.graphql", Input: `
type _Service {
  sdl: String
}

extend type Query {
  _service: _Service!
}
`, BuiltIn: true},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) field_Mutation_cr_addBuild_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 entities.Build
	if tmp, ok := rawArgs["build"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("build"))
		arg0, err = ec.unmarshalNBuildIn2kloudliteioappscontainerregistryinternaldomainentitiesBuild(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["build"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_cr_createCred_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 entities.Credential
	if tmp, ok := rawArgs["credential"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("credential"))
		arg0, err = ec.unmarshalNCredentialIn2kloudliteioappscontainerregistryinternaldomainentitiesCredential(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["credential"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_cr_createRepo_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 entities.Repository
	if tmp, ok := rawArgs["repository"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("repository"))
		arg0, err = ec.unmarshalNRepositoryIn2kloudliteioappscontainerregistryinternaldomainentitiesRepository(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["repository"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_cr_deleteBuild_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 repos.ID
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2kloudliteiopkgreposID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_cr_deleteCred_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["username"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("username"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["username"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_cr_deleteRepo_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_cr_deleteTag_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["repoName"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("repoName"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["repoName"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["digest"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("digest"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["digest"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_cr_triggerBuild_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 repos.ID
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2kloudliteiopkgreposID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_cr_updateBuild_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 repos.ID
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2kloudliteiopkgreposID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 entities.Build
	if tmp, ok := rawArgs["build"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("build"))
		arg1, err = ec.unmarshalNBuildIn2kloudliteioappscontainerregistryinternaldomainentitiesBuild(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["build"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_cr_checkUserNameAvailability_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_cr_getBuild_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 repos.ID
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2kloudliteiopkgreposID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_cr_getCredToken_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["username"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("username"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["username"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_cr_listBuilds_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["repoName"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("repoName"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["repoName"] = arg0
	var arg1 *model.SearchBuilds
	if tmp, ok := rawArgs["search"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("search"))
		arg1, err = ec.unmarshalOSearchBuilds2kloudliteioappscontainerregistryinternalappgraphmodelSearchBuilds(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["search"] = arg1
	var arg2 *repos.CursorPagination
	if tmp, ok := rawArgs["pagination"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
		arg2, err = ec.unmarshalOCursorPaginationIn2kloudliteiopkgreposCursorPagination(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pagination"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_cr_listCreds_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.SearchCreds
	if tmp, ok := rawArgs["search"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("search"))
		arg0, err = ec.unmarshalOSearchCreds2kloudliteioappscontainerregistryinternalappgraphmodelSearchCreds(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["search"] = arg0
	var arg1 *repos.CursorPagination
	if tmp, ok := rawArgs["pagination"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
		arg1, err = ec.unmarshalOCursorPaginationIn2kloudliteiopkgreposCursorPagination(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pagination"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_cr_listGithubBranches_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["repoUrl"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("repoUrl"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["repoUrl"] = arg0
	var arg1 *types.Pagination
	if tmp, ok := rawArgs["pagination"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
		arg1, err = ec.unmarshalOPaginationIn2kloudliteiopkgtypesPagination(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pagination"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_cr_listGithubInstallations_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *types.Pagination
	if tmp, ok := rawArgs["pagination"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
		arg0, err = ec.unmarshalOPaginationIn2kloudliteiopkgtypesPagination(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pagination"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_cr_listGithubRepos_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["installationId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("installationId"))
		arg0, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["installationId"] = arg0
	var arg1 *types.Pagination
	if tmp, ok := rawArgs["pagination"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
		arg1, err = ec.unmarshalOPaginationIn2kloudliteiopkgtypesPagination(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pagination"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_cr_listRepos_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.SearchRepos
	if tmp, ok := rawArgs["search"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("search"))
		arg0, err = ec.unmarshalOSearchRepos2kloudliteioappscontainerregistryinternalappgraphmodelSearchRepos(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["search"] = arg0
	var arg1 *repos.CursorPagination
	if tmp, ok := rawArgs["pagination"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
		arg1, err = ec.unmarshalOCursorPaginationIn2kloudliteiopkgreposCursorPagination(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pagination"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_cr_listTags_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["repoName"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("repoName"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["repoName"] = arg0
	var arg1 *model.SearchRepos
	if tmp, ok := rawArgs["search"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("search"))
		arg1, err = ec.unmarshalOSearchRepos2kloudliteioappscontainerregistryinternalappgraphmodelSearchRepos(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["search"] = arg1
	var arg2 *repos.CursorPagination
	if tmp, ok := rawArgs["pagination"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
		arg2, err = ec.unmarshalOCursorPaginationIn2kloudliteiopkgreposCursorPagination(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pagination"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_cr_searchGithubRepos_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["organization"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("organization"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["organization"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["search"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("search"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["search"] = arg1
	var arg2 *types.Pagination
	if tmp, ok := rawArgs["pagination"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
		arg2, err = ec.unmarshalOPaginationIn2kloudliteiopkgtypesPagination(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pagination"] = arg2
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _Build_accountName(ctx context.Context, field graphql.CollectedField, obj *entities.Build) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Build_accountName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AccountName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Build_accountName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Build",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Build_createdBy(ctx context.Context, field graphql.CollectedField, obj *entities.Build) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Build_createdBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Build().CreatedBy(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.KloudliteIoCommonCreatedOrUpdatedBy)
	fc.Result = res
	return ec.marshalNKloudlite_io__common_CreatedOrUpdatedBy2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoCommonCreatedOrUpdatedBy(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Build_createdBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Build",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "userEmail":
				return ec.fieldContext_Kloudlite_io__common_CreatedOrUpdatedBy_userEmail(ctx, field)
			case "userId":
				return ec.fieldContext_Kloudlite_io__common_CreatedOrUpdatedBy_userId(ctx, field)
			case "userName":
				return ec.fieldContext_Kloudlite_io__common_CreatedOrUpdatedBy_userName(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Kloudlite_io__common_CreatedOrUpdatedBy", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Build_creationTime(ctx context.Context, field graphql.CollectedField, obj *entities.Build) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Build_creationTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Build().CreationTime(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNDate2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Build_creationTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Build",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Build_id(ctx context.Context, field graphql.CollectedField, obj *entities.Build) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Build_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Build().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Build_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Build",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Build_lastUpdatedBy(ctx context.Context, field graphql.CollectedField, obj *entities.Build) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Build_lastUpdatedBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Build().LastUpdatedBy(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.KloudliteIoCommonCreatedOrUpdatedBy)
	fc.Result = res
	return ec.marshalNKloudlite_io__common_CreatedOrUpdatedBy2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoCommonCreatedOrUpdatedBy(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Build_lastUpdatedBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Build",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "userEmail":
				return ec.fieldContext_Kloudlite_io__common_CreatedOrUpdatedBy_userEmail(ctx, field)
			case "userId":
				return ec.fieldContext_Kloudlite_io__common_CreatedOrUpdatedBy_userId(ctx, field)
			case "userName":
				return ec.fieldContext_Kloudlite_io__common_CreatedOrUpdatedBy_userName(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Kloudlite_io__common_CreatedOrUpdatedBy", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Build_markedForDeletion(ctx context.Context, field graphql.CollectedField, obj *entities.Build) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Build_markedForDeletion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MarkedForDeletion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Build_markedForDeletion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Build",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Build_name(ctx context.Context, field graphql.CollectedField, obj *entities.Build) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Build_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Build_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Build",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Build_recordVersion(ctx context.Context, field graphql.CollectedField, obj *entities.Build) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Build_recordVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RecordVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Build_recordVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Build",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Build_repository(ctx context.Context, field graphql.CollectedField, obj *entities.Build) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Build_repository(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Repository, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Build_repository(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Build",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Build_source(ctx context.Context, field graphql.CollectedField, obj *entities.Build) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Build_source(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Build().Source(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGitSource)
	fc.Result = res
	return ec.marshalNKloudlite_io__apps__container___registry__internal__domain__entities_GitSource2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoAppsContainerRegistryInternalDomainEntitiesGitSource(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Build_source(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Build",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "branch":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GitSource_branch(ctx, field)
			case "pullSecret":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GitSource_pullSecret(ctx, field)
			case "repository":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GitSource_repository(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Kloudlite_io__apps__container___registry__internal__domain__entities_GitSource", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Build_tag(ctx context.Context, field graphql.CollectedField, obj *entities.Build) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Build_tag(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tag, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Build_tag(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Build",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Build_updateTime(ctx context.Context, field graphql.CollectedField, obj *entities.Build) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Build_updateTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Build().UpdateTime(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNDate2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Build_updateTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Build",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *model.BuildEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BuildEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BuildEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildEdge_node(ctx context.Context, field graphql.CollectedField, obj *model.BuildEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BuildEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*entities.Build)
	fc.Result = res
	return ec.marshalNBuild2kloudliteioappscontainerregistryinternaldomainentitiesBuild(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BuildEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "accountName":
				return ec.fieldContext_Build_accountName(ctx, field)
			case "createdBy":
				return ec.fieldContext_Build_createdBy(ctx, field)
			case "creationTime":
				return ec.fieldContext_Build_creationTime(ctx, field)
			case "id":
				return ec.fieldContext_Build_id(ctx, field)
			case "lastUpdatedBy":
				return ec.fieldContext_Build_lastUpdatedBy(ctx, field)
			case "markedForDeletion":
				return ec.fieldContext_Build_markedForDeletion(ctx, field)
			case "name":
				return ec.fieldContext_Build_name(ctx, field)
			case "recordVersion":
				return ec.fieldContext_Build_recordVersion(ctx, field)
			case "repository":
				return ec.fieldContext_Build_repository(ctx, field)
			case "source":
				return ec.fieldContext_Build_source(ctx, field)
			case "tag":
				return ec.fieldContext_Build_tag(ctx, field)
			case "updateTime":
				return ec.fieldContext_Build_updateTime(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Build", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildPaginatedRecords_edges(ctx context.Context, field graphql.CollectedField, obj *model.BuildPaginatedRecords) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BuildPaginatedRecords_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.BuildEdge)
	fc.Result = res
	return ec.marshalNBuildEdge2kloudliteioappscontainerregistryinternalappgraphmodelBuildEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BuildPaginatedRecords_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildPaginatedRecords",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cursor":
				return ec.fieldContext_BuildEdge_cursor(ctx, field)
			case "node":
				return ec.fieldContext_BuildEdge_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BuildEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildPaginatedRecords_pageInfo(ctx context.Context, field graphql.CollectedField, obj *model.BuildPaginatedRecords) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BuildPaginatedRecords_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2kloudliteioappscontainerregistryinternalappgraphmodelPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BuildPaginatedRecords_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildPaginatedRecords",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildPaginatedRecords_totalCount(ctx context.Context, field graphql.CollectedField, obj *model.BuildPaginatedRecords) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BuildPaginatedRecords_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BuildPaginatedRecords_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildPaginatedRecords",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CRCheckNameAvailabilityOutput_result(ctx context.Context, field graphql.CollectedField, obj *domain.CheckNameAvailabilityOutput) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CRCheckNameAvailabilityOutput_result(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Result, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CRCheckNameAvailabilityOutput_result(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CRCheckNameAvailabilityOutput",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CRCheckNameAvailabilityOutput_suggestedNames(ctx context.Context, field graphql.CollectedField, obj *domain.CheckNameAvailabilityOutput) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CRCheckNameAvailabilityOutput_suggestedNames(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SuggestedNames, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CRCheckNameAvailabilityOutput_suggestedNames(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CRCheckNameAvailabilityOutput",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Credential_access(ctx context.Context, field graphql.CollectedField, obj *entities.Credential) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Credential_access(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Credential().Access(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesRepoAccess)
	fc.Result = res
	return ec.marshalNKloudlite_io__apps__container___registry__internal__domain__entities_RepoAccess2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoAppsContainerRegistryInternalDomainEntitiesRepoAccess(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Credential_access(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Credential",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Kloudlite_io__apps__container___registry__internal__domain__entities_RepoAccess does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Credential_accountName(ctx context.Context, field graphql.CollectedField, obj *entities.Credential) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Credential_accountName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AccountName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Credential_accountName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Credential",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Credential_createdBy(ctx context.Context, field graphql.CollectedField, obj *entities.Credential) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Credential_createdBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Credential().CreatedBy(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.KloudliteIoCommonCreatedOrUpdatedBy)
	fc.Result = res
	return ec.marshalNKloudlite_io__common_CreatedOrUpdatedBy2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoCommonCreatedOrUpdatedBy(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Credential_createdBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Credential",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "userEmail":
				return ec.fieldContext_Kloudlite_io__common_CreatedOrUpdatedBy_userEmail(ctx, field)
			case "userId":
				return ec.fieldContext_Kloudlite_io__common_CreatedOrUpdatedBy_userId(ctx, field)
			case "userName":
				return ec.fieldContext_Kloudlite_io__common_CreatedOrUpdatedBy_userName(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Kloudlite_io__common_CreatedOrUpdatedBy", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Credential_creationTime(ctx context.Context, field graphql.CollectedField, obj *entities.Credential) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Credential_creationTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Credential().CreationTime(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNDate2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Credential_creationTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Credential",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Credential_expiration(ctx context.Context, field graphql.CollectedField, obj *entities.Credential) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Credential_expiration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Credential().Expiration(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesExpiration)
	fc.Result = res
	return ec.marshalNKloudlite_io__apps__container___registry__internal__domain__entities_Expiration2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoAppsContainerRegistryInternalDomainEntitiesExpiration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Credential_expiration(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Credential",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "unit":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_Expiration_unit(ctx, field)
			case "value":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_Expiration_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Kloudlite_io__apps__container___registry__internal__domain__entities_Expiration", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Credential_id(ctx context.Context, field graphql.CollectedField, obj *entities.Credential) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Credential_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Credential().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Credential_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Credential",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Credential_lastUpdatedBy(ctx context.Context, field graphql.CollectedField, obj *entities.Credential) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Credential_lastUpdatedBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Credential().LastUpdatedBy(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.KloudliteIoCommonCreatedOrUpdatedBy)
	fc.Result = res
	return ec.marshalNKloudlite_io__common_CreatedOrUpdatedBy2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoCommonCreatedOrUpdatedBy(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Credential_lastUpdatedBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Credential",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "userEmail":
				return ec.fieldContext_Kloudlite_io__common_CreatedOrUpdatedBy_userEmail(ctx, field)
			case "userId":
				return ec.fieldContext_Kloudlite_io__common_CreatedOrUpdatedBy_userId(ctx, field)
			case "userName":
				return ec.fieldContext_Kloudlite_io__common_CreatedOrUpdatedBy_userName(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Kloudlite_io__common_CreatedOrUpdatedBy", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Credential_markedForDeletion(ctx context.Context, field graphql.CollectedField, obj *entities.Credential) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Credential_markedForDeletion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MarkedForDeletion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Credential_markedForDeletion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Credential",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Credential_name(ctx context.Context, field graphql.CollectedField, obj *entities.Credential) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Credential_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Credential_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Credential",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Credential_recordVersion(ctx context.Context, field graphql.CollectedField, obj *entities.Credential) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Credential_recordVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RecordVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Credential_recordVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Credential",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Credential_updateTime(ctx context.Context, field graphql.CollectedField, obj *entities.Credential) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Credential_updateTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Credential().UpdateTime(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNDate2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Credential_updateTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Credential",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Credential_username(ctx context.Context, field graphql.CollectedField, obj *entities.Credential) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Credential_username(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Credential_username(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Credential",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CredentialEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *model.CredentialEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CredentialEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CredentialEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CredentialEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CredentialEdge_node(ctx context.Context, field graphql.CollectedField, obj *model.CredentialEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CredentialEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*entities.Credential)
	fc.Result = res
	return ec.marshalNCredential2kloudliteioappscontainerregistryinternaldomainentitiesCredential(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CredentialEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CredentialEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "access":
				return ec.fieldContext_Credential_access(ctx, field)
			case "accountName":
				return ec.fieldContext_Credential_accountName(ctx, field)
			case "createdBy":
				return ec.fieldContext_Credential_createdBy(ctx, field)
			case "creationTime":
				return ec.fieldContext_Credential_creationTime(ctx, field)
			case "expiration":
				return ec.fieldContext_Credential_expiration(ctx, field)
			case "id":
				return ec.fieldContext_Credential_id(ctx, field)
			case "lastUpdatedBy":
				return ec.fieldContext_Credential_lastUpdatedBy(ctx, field)
			case "markedForDeletion":
				return ec.fieldContext_Credential_markedForDeletion(ctx, field)
			case "name":
				return ec.fieldContext_Credential_name(ctx, field)
			case "recordVersion":
				return ec.fieldContext_Credential_recordVersion(ctx, field)
			case "updateTime":
				return ec.fieldContext_Credential_updateTime(ctx, field)
			case "username":
				return ec.fieldContext_Credential_username(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Credential", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CredentialPaginatedRecords_edges(ctx context.Context, field graphql.CollectedField, obj *model.CredentialPaginatedRecords) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CredentialPaginatedRecords_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.CredentialEdge)
	fc.Result = res
	return ec.marshalNCredentialEdge2kloudliteioappscontainerregistryinternalappgraphmodelCredentialEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CredentialPaginatedRecords_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CredentialPaginatedRecords",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cursor":
				return ec.fieldContext_CredentialEdge_cursor(ctx, field)
			case "node":
				return ec.fieldContext_CredentialEdge_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CredentialEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CredentialPaginatedRecords_pageInfo(ctx context.Context, field graphql.CollectedField, obj *model.CredentialPaginatedRecords) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CredentialPaginatedRecords_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2kloudliteioappscontainerregistryinternalappgraphmodelPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CredentialPaginatedRecords_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CredentialPaginatedRecords",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CredentialPaginatedRecords_totalCount(ctx context.Context, field graphql.CollectedField, obj *model.CredentialPaginatedRecords) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CredentialPaginatedRecords_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CredentialPaginatedRecords_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CredentialPaginatedRecords",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CursorPagination_after(ctx context.Context, field graphql.CollectedField, obj *repos.CursorPagination) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CursorPagination_after(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.After, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CursorPagination_after(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CursorPagination",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CursorPagination_before(ctx context.Context, field graphql.CollectedField, obj *repos.CursorPagination) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CursorPagination_before(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Before, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CursorPagination_before(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CursorPagination",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CursorPagination_first(ctx context.Context, field graphql.CollectedField, obj *repos.CursorPagination) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CursorPagination_first(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.First, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int64)
	fc.Result = res
	return ec.marshalOInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CursorPagination_first(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CursorPagination",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CursorPagination_last(ctx context.Context, field graphql.CollectedField, obj *repos.CursorPagination) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CursorPagination_last(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Last, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int64)
	fc.Result = res
	return ec.marshalOInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CursorPagination_last(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CursorPagination",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CursorPagination_orderBy(ctx context.Context, field graphql.CollectedField, obj *repos.CursorPagination) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CursorPagination_orderBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OrderBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CursorPagination_orderBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CursorPagination",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CursorPagination_sortDirection(ctx context.Context, field graphql.CollectedField, obj *repos.CursorPagination) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CursorPagination_sortDirection(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SortDirection, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(repos.SortDirection)
	fc.Result = res
	return ec.marshalOCursorPaginationSortDirection2kloudliteiopkgreposSortDirection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CursorPagination_sortDirection(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CursorPagination",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CursorPaginationSortDirection does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubBranch_name(ctx context.Context, field graphql.CollectedField, obj *entities.GithubBranch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubBranch_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubBranch_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubBranch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubBranch_protected(ctx context.Context, field graphql.CollectedField, obj *entities.GithubBranch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubBranch_protected(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Protected, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubBranch_protected(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubBranch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubInstallation_account(ctx context.Context, field graphql.CollectedField, obj *entities.GithubInstallation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubInstallation_account(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.GithubInstallation().Account(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubUserAccount)
	fc.Result = res
	return ec.marshalOKloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubUserAccount(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubInstallation_account(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubInstallation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "avatar_url":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount_avatar_url(ctx, field)
			case "id":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount_id(ctx, field)
			case "login":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount_login(ctx, field)
			case "node_id":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount_node_id(ctx, field)
			case "type":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount_type(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubInstallation_app_id(ctx context.Context, field graphql.CollectedField, obj *entities.GithubInstallation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubInstallation_app_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AppID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int64)
	fc.Result = res
	return ec.marshalOInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubInstallation_app_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubInstallation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubInstallation_id(ctx context.Context, field graphql.CollectedField, obj *entities.GithubInstallation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubInstallation_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int64)
	fc.Result = res
	return ec.marshalOInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubInstallation_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubInstallation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubInstallation_node_id(ctx context.Context, field graphql.CollectedField, obj *entities.GithubInstallation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubInstallation_node_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NodeID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubInstallation_node_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubInstallation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubInstallation_repositories_url(ctx context.Context, field graphql.CollectedField, obj *entities.GithubInstallation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubInstallation_repositories_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RepositoriesURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubInstallation_repositories_url(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubInstallation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubInstallation_target_id(ctx context.Context, field graphql.CollectedField, obj *entities.GithubInstallation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubInstallation_target_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TargetID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int64)
	fc.Result = res
	return ec.marshalOInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubInstallation_target_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubInstallation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubInstallation_target_type(ctx context.Context, field graphql.CollectedField, obj *entities.GithubInstallation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubInstallation_target_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TargetType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubInstallation_target_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubInstallation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubListRepository_repositories(ctx context.Context, field graphql.CollectedField, obj *entities.GithubListRepository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubListRepository_repositories(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.GithubListRepository().Repositories(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubRepository)
	fc.Result = res
	return ec.marshalNKloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubRepository(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubListRepository_repositories(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubListRepository",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "archived":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_archived(ctx, field)
			case "clone_url":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_clone_url(ctx, field)
			case "created_at":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_created_at(ctx, field)
			case "default_branch":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_default_branch(ctx, field)
			case "description":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_description(ctx, field)
			case "disabled":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_disabled(ctx, field)
			case "full_name":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_full_name(ctx, field)
			case "git_url":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_git_url(ctx, field)
			case "gitignore_template":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_gitignore_template(ctx, field)
			case "html_url":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_html_url(ctx, field)
			case "id":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_id(ctx, field)
			case "language":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_language(ctx, field)
			case "master_branch":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_master_branch(ctx, field)
			case "mirror_url":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_mirror_url(ctx, field)
			case "name":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_name(ctx, field)
			case "node_id":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_node_id(ctx, field)
			case "permissions":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_permissions(ctx, field)
			case "private":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_private(ctx, field)
			case "pushed_at":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_pushed_at(ctx, field)
			case "size":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_size(ctx, field)
			case "team_id":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_team_id(ctx, field)
			case "updated_at":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_updated_at(ctx, field)
			case "url":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_url(ctx, field)
			case "visibility":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_visibility(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubListRepository_total_count(ctx context.Context, field graphql.CollectedField, obj *entities.GithubListRepository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubListRepository_total_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubListRepository_total_count(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubListRepository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubSearchRepository_incomplete_results(ctx context.Context, field graphql.CollectedField, obj *entities.GithubSearchRepository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubSearchRepository_incomplete_results(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IncompleteResults, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubSearchRepository_incomplete_results(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubSearchRepository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubSearchRepository_repositories(ctx context.Context, field graphql.CollectedField, obj *entities.GithubSearchRepository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubSearchRepository_repositories(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.GithubSearchRepository().Repositories(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubRepository)
	fc.Result = res
	return ec.marshalNKloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubRepository(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubSearchRepository_repositories(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubSearchRepository",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "archived":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_archived(ctx, field)
			case "clone_url":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_clone_url(ctx, field)
			case "created_at":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_created_at(ctx, field)
			case "default_branch":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_default_branch(ctx, field)
			case "description":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_description(ctx, field)
			case "disabled":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_disabled(ctx, field)
			case "full_name":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_full_name(ctx, field)
			case "git_url":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_git_url(ctx, field)
			case "gitignore_template":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_gitignore_template(ctx, field)
			case "html_url":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_html_url(ctx, field)
			case "id":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_id(ctx, field)
			case "language":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_language(ctx, field)
			case "master_branch":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_master_branch(ctx, field)
			case "mirror_url":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_mirror_url(ctx, field)
			case "name":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_name(ctx, field)
			case "node_id":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_node_id(ctx, field)
			case "permissions":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_permissions(ctx, field)
			case "private":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_private(ctx, field)
			case "pushed_at":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_pushed_at(ctx, field)
			case "size":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_size(ctx, field)
			case "team_id":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_team_id(ctx, field)
			case "updated_at":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_updated_at(ctx, field)
			case "url":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_url(ctx, field)
			case "visibility":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_visibility(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubSearchRepository_total(ctx context.Context, field graphql.CollectedField, obj *entities.GithubSearchRepository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubSearchRepository_total(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubSearchRepository_total(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubSearchRepository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_Expiration_unit(ctx context.Context, field graphql.CollectedField, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesExpiration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_Expiration_unit(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Unit, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesExpirationUnit)
	fc.Result = res
	return ec.marshalNKloudlite_io__apps__container___registry__internal__domain__entities_ExpirationUnit2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoAppsContainerRegistryInternalDomainEntitiesExpirationUnit(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_Expiration_unit(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Kloudlite_io__apps__container___registry__internal__domain__entities_Expiration",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Kloudlite_io__apps__container___registry__internal__domain__entities_ExpirationUnit does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_Expiration_value(ctx context.Context, field graphql.CollectedField, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesExpiration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_Expiration_value(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_Expiration_value(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Kloudlite_io__apps__container___registry__internal__domain__entities_Expiration",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_GitSource_branch(ctx context.Context, field graphql.CollectedField, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGitSource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GitSource_branch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Branch, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GitSource_branch(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Kloudlite_io__apps__container___registry__internal__domain__entities_GitSource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_GitSource_pullSecret(ctx context.Context, field graphql.CollectedField, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGitSource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GitSource_pullSecret(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PullSecret, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GitSource_pullSecret(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Kloudlite_io__apps__container___registry__internal__domain__entities_GitSource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_GitSource_repository(ctx context.Context, field graphql.CollectedField, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGitSource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GitSource_repository(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Repository, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GitSource_repository(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Kloudlite_io__apps__container___registry__internal__domain__entities_GitSource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_archived(ctx context.Context, field graphql.CollectedField, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubRepository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_archived(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Archived, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_archived(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_clone_url(ctx context.Context, field graphql.CollectedField, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubRepository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_clone_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CloneURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_clone_url(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_created_at(ctx context.Context, field graphql.CollectedField, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubRepository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_created_at(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalODate2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_created_at(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_default_branch(ctx context.Context, field graphql.CollectedField, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubRepository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_default_branch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultBranch, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_default_branch(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_description(ctx context.Context, field graphql.CollectedField, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubRepository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_disabled(ctx context.Context, field graphql.CollectedField, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubRepository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_disabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Disabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_disabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_full_name(ctx context.Context, field graphql.CollectedField, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubRepository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_full_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FullName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_full_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_git_url(ctx context.Context, field graphql.CollectedField, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubRepository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_git_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GitURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_git_url(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_gitignore_template(ctx context.Context, field graphql.CollectedField, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubRepository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_gitignore_template(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GitignoreTemplate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_gitignore_template(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_html_url(ctx context.Context, field graphql.CollectedField, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubRepository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_html_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HTMLURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_html_url(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_id(ctx context.Context, field graphql.CollectedField, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubRepository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_language(ctx context.Context, field graphql.CollectedField, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubRepository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_language(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Language, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_language(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_master_branch(ctx context.Context, field graphql.CollectedField, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubRepository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_master_branch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MasterBranch, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_master_branch(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_mirror_url(ctx context.Context, field graphql.CollectedField, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubRepository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_mirror_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MirrorURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_mirror_url(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_name(ctx context.Context, field graphql.CollectedField, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubRepository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_node_id(ctx context.Context, field graphql.CollectedField, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubRepository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_node_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NodeID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_node_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_permissions(ctx context.Context, field graphql.CollectedField, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubRepository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_permissions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Permissions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_permissions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_private(ctx context.Context, field graphql.CollectedField, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubRepository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_private(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Private, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_private(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_pushed_at(ctx context.Context, field graphql.CollectedField, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubRepository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_pushed_at(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PushedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalODate2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_pushed_at(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_size(ctx context.Context, field graphql.CollectedField, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubRepository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_size(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Size, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_size(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_team_id(ctx context.Context, field graphql.CollectedField, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubRepository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_team_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TeamID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_team_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_updated_at(ctx context.Context, field graphql.CollectedField, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubRepository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_updated_at(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalODate2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_updated_at(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_url(ctx context.Context, field graphql.CollectedField, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubRepository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_url(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_visibility(ctx context.Context, field graphql.CollectedField, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubRepository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_visibility(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Visibility, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_visibility(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount_avatar_url(ctx context.Context, field graphql.CollectedField, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubUserAccount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount_avatar_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AvatarURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount_avatar_url(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount_id(ctx context.Context, field graphql.CollectedField, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubUserAccount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount_login(ctx context.Context, field graphql.CollectedField, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubUserAccount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount_login(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Login, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount_login(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount_node_id(ctx context.Context, field graphql.CollectedField, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubUserAccount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount_node_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NodeID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount_node_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount_type(ctx context.Context, field graphql.CollectedField, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubUserAccount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_RepoReference_digest(ctx context.Context, field graphql.CollectedField, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesRepoReference) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_RepoReference_digest(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Digest, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_RepoReference_digest(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Kloudlite_io__apps__container___registry__internal__domain__entities_RepoReference",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_RepoReference_mediaType(ctx context.Context, field graphql.CollectedField, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesRepoReference) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_RepoReference_mediaType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MediaType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_RepoReference_mediaType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Kloudlite_io__apps__container___registry__internal__domain__entities_RepoReference",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_RepoReference_size(ctx context.Context, field graphql.CollectedField, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesRepoReference) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_RepoReference_size(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Size, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_RepoReference_size(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Kloudlite_io__apps__container___registry__internal__domain__entities_RepoReference",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Kloudlite_io__common_CreatedOrUpdatedBy_userEmail(ctx context.Context, field graphql.CollectedField, obj *model.KloudliteIoCommonCreatedOrUpdatedBy) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Kloudlite_io__common_CreatedOrUpdatedBy_userEmail(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserEmail, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Kloudlite_io__common_CreatedOrUpdatedBy_userEmail(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Kloudlite_io__common_CreatedOrUpdatedBy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Kloudlite_io__common_CreatedOrUpdatedBy_userId(ctx context.Context, field graphql.CollectedField, obj *model.KloudliteIoCommonCreatedOrUpdatedBy) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Kloudlite_io__common_CreatedOrUpdatedBy_userId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Kloudlite_io__common_CreatedOrUpdatedBy_userId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Kloudlite_io__common_CreatedOrUpdatedBy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Kloudlite_io__common_CreatedOrUpdatedBy_userName(ctx context.Context, field graphql.CollectedField, obj *model.KloudliteIoCommonCreatedOrUpdatedBy) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Kloudlite_io__common_CreatedOrUpdatedBy_userName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Kloudlite_io__common_CreatedOrUpdatedBy_userName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Kloudlite_io__common_CreatedOrUpdatedBy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchFilter_array(ctx context.Context, field graphql.CollectedField, obj *repos.MatchFilter) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchFilter_array(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Array, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]any)
	fc.Result = res
	return ec.marshalOAny2interface(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchFilter_array(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchFilter",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Any does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchFilter_exact(ctx context.Context, field graphql.CollectedField, obj *repos.MatchFilter) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchFilter_exact(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Exact, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(any)
	fc.Result = res
	return ec.marshalOAny2interface(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchFilter_exact(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchFilter",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Any does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchFilter_matchType(ctx context.Context, field graphql.CollectedField, obj *repos.MatchFilter) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchFilter_matchType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MatchType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(repos.MatchType)
	fc.Result = res
	return ec.marshalNMatchFilterMatchType2kloudliteiopkgreposMatchType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchFilter_matchType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchFilter",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MatchFilterMatchType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchFilter_regex(ctx context.Context, field graphql.CollectedField, obj *repos.MatchFilter) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchFilter_regex(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Regex, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchFilter_regex(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchFilter",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_cr_createRepo(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_cr_createRepo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CrCreateRepo(rctx, fc.Args["repository"].(entities.Repository))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedInAndVerified == nil {
				return nil, errors.New("directive isLoggedInAndVerified is not implemented")
			}
			return ec.directives.IsLoggedInAndVerified(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.HasAccount == nil {
				return nil, errors.New("directive hasAccount is not implemented")
			}
			return ec.directives.HasAccount(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*entities.Repository); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *kloudlite.io/apps/container-registry/internal/domain/entities.Repository`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*entities.Repository)
	fc.Result = res
	return ec.marshalORepository2kloudliteioappscontainerregistryinternaldomainentitiesRepository(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_cr_createRepo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "accountName":
				return ec.fieldContext_Repository_accountName(ctx, field)
			case "createdBy":
				return ec.fieldContext_Repository_createdBy(ctx, field)
			case "creationTime":
				return ec.fieldContext_Repository_creationTime(ctx, field)
			case "id":
				return ec.fieldContext_Repository_id(ctx, field)
			case "lastUpdatedBy":
				return ec.fieldContext_Repository_lastUpdatedBy(ctx, field)
			case "markedForDeletion":
				return ec.fieldContext_Repository_markedForDeletion(ctx, field)
			case "name":
				return ec.fieldContext_Repository_name(ctx, field)
			case "recordVersion":
				return ec.fieldContext_Repository_recordVersion(ctx, field)
			case "updateTime":
				return ec.fieldContext_Repository_updateTime(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Repository", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_cr_createRepo_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_cr_createCred(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_cr_createCred(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CrCreateCred(rctx, fc.Args["credential"].(entities.Credential))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedInAndVerified == nil {
				return nil, errors.New("directive isLoggedInAndVerified is not implemented")
			}
			return ec.directives.IsLoggedInAndVerified(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.HasAccount == nil {
				return nil, errors.New("directive hasAccount is not implemented")
			}
			return ec.directives.HasAccount(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*entities.Credential); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *kloudlite.io/apps/container-registry/internal/domain/entities.Credential`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*entities.Credential)
	fc.Result = res
	return ec.marshalOCredential2kloudliteioappscontainerregistryinternaldomainentitiesCredential(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_cr_createCred(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "access":
				return ec.fieldContext_Credential_access(ctx, field)
			case "accountName":
				return ec.fieldContext_Credential_accountName(ctx, field)
			case "createdBy":
				return ec.fieldContext_Credential_createdBy(ctx, field)
			case "creationTime":
				return ec.fieldContext_Credential_creationTime(ctx, field)
			case "expiration":
				return ec.fieldContext_Credential_expiration(ctx, field)
			case "id":
				return ec.fieldContext_Credential_id(ctx, field)
			case "lastUpdatedBy":
				return ec.fieldContext_Credential_lastUpdatedBy(ctx, field)
			case "markedForDeletion":
				return ec.fieldContext_Credential_markedForDeletion(ctx, field)
			case "name":
				return ec.fieldContext_Credential_name(ctx, field)
			case "recordVersion":
				return ec.fieldContext_Credential_recordVersion(ctx, field)
			case "updateTime":
				return ec.fieldContext_Credential_updateTime(ctx, field)
			case "username":
				return ec.fieldContext_Credential_username(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Credential", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_cr_createCred_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_cr_deleteRepo(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_cr_deleteRepo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CrDeleteRepo(rctx, fc.Args["name"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedInAndVerified == nil {
				return nil, errors.New("directive isLoggedInAndVerified is not implemented")
			}
			return ec.directives.IsLoggedInAndVerified(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.HasAccount == nil {
				return nil, errors.New("directive hasAccount is not implemented")
			}
			return ec.directives.HasAccount(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_cr_deleteRepo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_cr_deleteRepo_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_cr_deleteCred(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_cr_deleteCred(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CrDeleteCred(rctx, fc.Args["username"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedInAndVerified == nil {
				return nil, errors.New("directive isLoggedInAndVerified is not implemented")
			}
			return ec.directives.IsLoggedInAndVerified(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.HasAccount == nil {
				return nil, errors.New("directive hasAccount is not implemented")
			}
			return ec.directives.HasAccount(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_cr_deleteCred(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_cr_deleteCred_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_cr_deleteTag(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_cr_deleteTag(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CrDeleteTag(rctx, fc.Args["repoName"].(string), fc.Args["digest"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedInAndVerified == nil {
				return nil, errors.New("directive isLoggedInAndVerified is not implemented")
			}
			return ec.directives.IsLoggedInAndVerified(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.HasAccount == nil {
				return nil, errors.New("directive hasAccount is not implemented")
			}
			return ec.directives.HasAccount(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_cr_deleteTag(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_cr_deleteTag_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_cr_addBuild(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_cr_addBuild(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CrAddBuild(rctx, fc.Args["build"].(entities.Build))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedInAndVerified == nil {
				return nil, errors.New("directive isLoggedInAndVerified is not implemented")
			}
			return ec.directives.IsLoggedInAndVerified(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.HasAccount == nil {
				return nil, errors.New("directive hasAccount is not implemented")
			}
			return ec.directives.HasAccount(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*entities.Build); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *kloudlite.io/apps/container-registry/internal/domain/entities.Build`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*entities.Build)
	fc.Result = res
	return ec.marshalOBuild2kloudliteioappscontainerregistryinternaldomainentitiesBuild(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_cr_addBuild(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "accountName":
				return ec.fieldContext_Build_accountName(ctx, field)
			case "createdBy":
				return ec.fieldContext_Build_createdBy(ctx, field)
			case "creationTime":
				return ec.fieldContext_Build_creationTime(ctx, field)
			case "id":
				return ec.fieldContext_Build_id(ctx, field)
			case "lastUpdatedBy":
				return ec.fieldContext_Build_lastUpdatedBy(ctx, field)
			case "markedForDeletion":
				return ec.fieldContext_Build_markedForDeletion(ctx, field)
			case "name":
				return ec.fieldContext_Build_name(ctx, field)
			case "recordVersion":
				return ec.fieldContext_Build_recordVersion(ctx, field)
			case "repository":
				return ec.fieldContext_Build_repository(ctx, field)
			case "source":
				return ec.fieldContext_Build_source(ctx, field)
			case "tag":
				return ec.fieldContext_Build_tag(ctx, field)
			case "updateTime":
				return ec.fieldContext_Build_updateTime(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Build", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_cr_addBuild_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_cr_updateBuild(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_cr_updateBuild(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CrUpdateBuild(rctx, fc.Args["id"].(repos.ID), fc.Args["build"].(entities.Build))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedInAndVerified == nil {
				return nil, errors.New("directive isLoggedInAndVerified is not implemented")
			}
			return ec.directives.IsLoggedInAndVerified(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.HasAccount == nil {
				return nil, errors.New("directive hasAccount is not implemented")
			}
			return ec.directives.HasAccount(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*entities.Build); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *kloudlite.io/apps/container-registry/internal/domain/entities.Build`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*entities.Build)
	fc.Result = res
	return ec.marshalOBuild2kloudliteioappscontainerregistryinternaldomainentitiesBuild(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_cr_updateBuild(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "accountName":
				return ec.fieldContext_Build_accountName(ctx, field)
			case "createdBy":
				return ec.fieldContext_Build_createdBy(ctx, field)
			case "creationTime":
				return ec.fieldContext_Build_creationTime(ctx, field)
			case "id":
				return ec.fieldContext_Build_id(ctx, field)
			case "lastUpdatedBy":
				return ec.fieldContext_Build_lastUpdatedBy(ctx, field)
			case "markedForDeletion":
				return ec.fieldContext_Build_markedForDeletion(ctx, field)
			case "name":
				return ec.fieldContext_Build_name(ctx, field)
			case "recordVersion":
				return ec.fieldContext_Build_recordVersion(ctx, field)
			case "repository":
				return ec.fieldContext_Build_repository(ctx, field)
			case "source":
				return ec.fieldContext_Build_source(ctx, field)
			case "tag":
				return ec.fieldContext_Build_tag(ctx, field)
			case "updateTime":
				return ec.fieldContext_Build_updateTime(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Build", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_cr_updateBuild_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_cr_deleteBuild(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_cr_deleteBuild(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CrDeleteBuild(rctx, fc.Args["id"].(repos.ID))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedInAndVerified == nil {
				return nil, errors.New("directive isLoggedInAndVerified is not implemented")
			}
			return ec.directives.IsLoggedInAndVerified(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.HasAccount == nil {
				return nil, errors.New("directive hasAccount is not implemented")
			}
			return ec.directives.HasAccount(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_cr_deleteBuild(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_cr_deleteBuild_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_cr_triggerBuild(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_cr_triggerBuild(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CrTriggerBuild(rctx, fc.Args["id"].(repos.ID))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedInAndVerified == nil {
				return nil, errors.New("directive isLoggedInAndVerified is not implemented")
			}
			return ec.directives.IsLoggedInAndVerified(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.HasAccount == nil {
				return nil, errors.New("directive hasAccount is not implemented")
			}
			return ec.directives.HasAccount(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_cr_triggerBuild(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_cr_triggerBuild_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_endCursor(ctx context.Context, field graphql.CollectedField, obj *model.PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_endCursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndCursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_endCursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_hasNextPage(ctx context.Context, field graphql.CollectedField, obj *model.PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_hasNextPage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasNextPage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_hasNextPage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_hasPreviousPage(ctx context.Context, field graphql.CollectedField, obj *model.PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasPreviousPage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_hasPreviousPage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_startCursor(ctx context.Context, field graphql.CollectedField, obj *model.PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_startCursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartCursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_startCursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Pagination_page(ctx context.Context, field graphql.CollectedField, obj *types.Pagination) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Pagination_page(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Page, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Pagination_page(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Pagination",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Pagination_per_page(ctx context.Context, field graphql.CollectedField, obj *types.Pagination) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Pagination_per_page(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PerPage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Pagination_per_page(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Pagination",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_cr_listRepos(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_cr_listRepos(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().CrListRepos(rctx, fc.Args["search"].(*model.SearchRepos), fc.Args["pagination"].(*repos.CursorPagination))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedInAndVerified == nil {
				return nil, errors.New("directive isLoggedInAndVerified is not implemented")
			}
			return ec.directives.IsLoggedInAndVerified(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.HasAccount == nil {
				return nil, errors.New("directive hasAccount is not implemented")
			}
			return ec.directives.HasAccount(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.RepositoryPaginatedRecords); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *kloudlite.io/apps/container-registry/internal/app/graph/model.RepositoryPaginatedRecords`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.RepositoryPaginatedRecords)
	fc.Result = res
	return ec.marshalORepositoryPaginatedRecords2kloudliteioappscontainerregistryinternalappgraphmodelRepositoryPaginatedRecords(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_cr_listRepos(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_RepositoryPaginatedRecords_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_RepositoryPaginatedRecords_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_RepositoryPaginatedRecords_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RepositoryPaginatedRecords", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_cr_listRepos_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_cr_listCreds(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_cr_listCreds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().CrListCreds(rctx, fc.Args["search"].(*model.SearchCreds), fc.Args["pagination"].(*repos.CursorPagination))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedInAndVerified == nil {
				return nil, errors.New("directive isLoggedInAndVerified is not implemented")
			}
			return ec.directives.IsLoggedInAndVerified(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.HasAccount == nil {
				return nil, errors.New("directive hasAccount is not implemented")
			}
			return ec.directives.HasAccount(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.CredentialPaginatedRecords); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *kloudlite.io/apps/container-registry/internal/app/graph/model.CredentialPaginatedRecords`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.CredentialPaginatedRecords)
	fc.Result = res
	return ec.marshalOCredentialPaginatedRecords2kloudliteioappscontainerregistryinternalappgraphmodelCredentialPaginatedRecords(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_cr_listCreds(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_CredentialPaginatedRecords_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_CredentialPaginatedRecords_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_CredentialPaginatedRecords_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CredentialPaginatedRecords", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_cr_listCreds_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_cr_listTags(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_cr_listTags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().CrListTags(rctx, fc.Args["repoName"].(string), fc.Args["search"].(*model.SearchRepos), fc.Args["pagination"].(*repos.CursorPagination))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedInAndVerified == nil {
				return nil, errors.New("directive isLoggedInAndVerified is not implemented")
			}
			return ec.directives.IsLoggedInAndVerified(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.HasAccount == nil {
				return nil, errors.New("directive hasAccount is not implemented")
			}
			return ec.directives.HasAccount(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.TagPaginatedRecords); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *kloudlite.io/apps/container-registry/internal/app/graph/model.TagPaginatedRecords`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.TagPaginatedRecords)
	fc.Result = res
	return ec.marshalOTagPaginatedRecords2kloudliteioappscontainerregistryinternalappgraphmodelTagPaginatedRecords(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_cr_listTags(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_TagPaginatedRecords_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_TagPaginatedRecords_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_TagPaginatedRecords_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TagPaginatedRecords", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_cr_listTags_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_cr_getCredToken(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_cr_getCredToken(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().CrGetCredToken(rctx, fc.Args["username"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedInAndVerified == nil {
				return nil, errors.New("directive isLoggedInAndVerified is not implemented")
			}
			return ec.directives.IsLoggedInAndVerified(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.HasAccount == nil {
				return nil, errors.New("directive hasAccount is not implemented")
			}
			return ec.directives.HasAccount(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_cr_getCredToken(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_cr_getCredToken_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_cr_checkUserNameAvailability(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_cr_checkUserNameAvailability(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().CrCheckUserNameAvailability(rctx, fc.Args["name"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedInAndVerified == nil {
				return nil, errors.New("directive isLoggedInAndVerified is not implemented")
			}
			return ec.directives.IsLoggedInAndVerified(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.HasAccount == nil {
				return nil, errors.New("directive hasAccount is not implemented")
			}
			return ec.directives.HasAccount(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*domain.CheckNameAvailabilityOutput); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *kloudlite.io/apps/container-registry/internal/domain.CheckNameAvailabilityOutput`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*domain.CheckNameAvailabilityOutput)
	fc.Result = res
	return ec.marshalNCRCheckNameAvailabilityOutput2kloudliteioappscontainerregistryinternaldomainCheckNameAvailabilityOutput(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_cr_checkUserNameAvailability(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "result":
				return ec.fieldContext_CRCheckNameAvailabilityOutput_result(ctx, field)
			case "suggestedNames":
				return ec.fieldContext_CRCheckNameAvailabilityOutput_suggestedNames(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CRCheckNameAvailabilityOutput", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_cr_checkUserNameAvailability_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_cr_getBuild(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_cr_getBuild(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().CrGetBuild(rctx, fc.Args["id"].(repos.ID))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedInAndVerified == nil {
				return nil, errors.New("directive isLoggedInAndVerified is not implemented")
			}
			return ec.directives.IsLoggedInAndVerified(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.HasAccount == nil {
				return nil, errors.New("directive hasAccount is not implemented")
			}
			return ec.directives.HasAccount(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*entities.Build); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *kloudlite.io/apps/container-registry/internal/domain/entities.Build`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*entities.Build)
	fc.Result = res
	return ec.marshalOBuild2kloudliteioappscontainerregistryinternaldomainentitiesBuild(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_cr_getBuild(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "accountName":
				return ec.fieldContext_Build_accountName(ctx, field)
			case "createdBy":
				return ec.fieldContext_Build_createdBy(ctx, field)
			case "creationTime":
				return ec.fieldContext_Build_creationTime(ctx, field)
			case "id":
				return ec.fieldContext_Build_id(ctx, field)
			case "lastUpdatedBy":
				return ec.fieldContext_Build_lastUpdatedBy(ctx, field)
			case "markedForDeletion":
				return ec.fieldContext_Build_markedForDeletion(ctx, field)
			case "name":
				return ec.fieldContext_Build_name(ctx, field)
			case "recordVersion":
				return ec.fieldContext_Build_recordVersion(ctx, field)
			case "repository":
				return ec.fieldContext_Build_repository(ctx, field)
			case "source":
				return ec.fieldContext_Build_source(ctx, field)
			case "tag":
				return ec.fieldContext_Build_tag(ctx, field)
			case "updateTime":
				return ec.fieldContext_Build_updateTime(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Build", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_cr_getBuild_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_cr_listBuilds(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_cr_listBuilds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().CrListBuilds(rctx, fc.Args["repoName"].(string), fc.Args["search"].(*model.SearchBuilds), fc.Args["pagination"].(*repos.CursorPagination))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedInAndVerified == nil {
				return nil, errors.New("directive isLoggedInAndVerified is not implemented")
			}
			return ec.directives.IsLoggedInAndVerified(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.HasAccount == nil {
				return nil, errors.New("directive hasAccount is not implemented")
			}
			return ec.directives.HasAccount(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.BuildPaginatedRecords); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *kloudlite.io/apps/container-registry/internal/app/graph/model.BuildPaginatedRecords`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.BuildPaginatedRecords)
	fc.Result = res
	return ec.marshalOBuildPaginatedRecords2kloudliteioappscontainerregistryinternalappgraphmodelBuildPaginatedRecords(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_cr_listBuilds(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_BuildPaginatedRecords_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_BuildPaginatedRecords_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_BuildPaginatedRecords_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BuildPaginatedRecords", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_cr_listBuilds_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_cr_listGithubInstallations(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_cr_listGithubInstallations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().CrListGithubInstallations(rctx, fc.Args["pagination"].(*types.Pagination))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedInAndVerified == nil {
				return nil, errors.New("directive isLoggedInAndVerified is not implemented")
			}
			return ec.directives.IsLoggedInAndVerified(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.HasAccount == nil {
				return nil, errors.New("directive hasAccount is not implemented")
			}
			return ec.directives.HasAccount(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*entities.GithubInstallation); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*kloudlite.io/apps/container-registry/internal/domain/entities.GithubInstallation`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*entities.GithubInstallation)
	fc.Result = res
	return ec.marshalOGithubInstallation2kloudliteioappscontainerregistryinternaldomainentitiesGithubInstallation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_cr_listGithubInstallations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "account":
				return ec.fieldContext_GithubInstallation_account(ctx, field)
			case "app_id":
				return ec.fieldContext_GithubInstallation_app_id(ctx, field)
			case "id":
				return ec.fieldContext_GithubInstallation_id(ctx, field)
			case "node_id":
				return ec.fieldContext_GithubInstallation_node_id(ctx, field)
			case "repositories_url":
				return ec.fieldContext_GithubInstallation_repositories_url(ctx, field)
			case "target_id":
				return ec.fieldContext_GithubInstallation_target_id(ctx, field)
			case "target_type":
				return ec.fieldContext_GithubInstallation_target_type(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubInstallation", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_cr_listGithubInstallations_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_cr_listGithubRepos(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_cr_listGithubRepos(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().CrListGithubRepos(rctx, fc.Args["installationId"].(int), fc.Args["pagination"].(*types.Pagination))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedInAndVerified == nil {
				return nil, errors.New("directive isLoggedInAndVerified is not implemented")
			}
			return ec.directives.IsLoggedInAndVerified(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.HasAccount == nil {
				return nil, errors.New("directive hasAccount is not implemented")
			}
			return ec.directives.HasAccount(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*entities.GithubListRepository); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *kloudlite.io/apps/container-registry/internal/domain/entities.GithubListRepository`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*entities.GithubListRepository)
	fc.Result = res
	return ec.marshalOGithubListRepository2kloudliteioappscontainerregistryinternaldomainentitiesGithubListRepository(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_cr_listGithubRepos(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "repositories":
				return ec.fieldContext_GithubListRepository_repositories(ctx, field)
			case "total_count":
				return ec.fieldContext_GithubListRepository_total_count(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubListRepository", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_cr_listGithubRepos_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_cr_searchGithubRepos(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_cr_searchGithubRepos(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().CrSearchGithubRepos(rctx, fc.Args["organization"].(string), fc.Args["search"].(string), fc.Args["pagination"].(*types.Pagination))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedInAndVerified == nil {
				return nil, errors.New("directive isLoggedInAndVerified is not implemented")
			}
			return ec.directives.IsLoggedInAndVerified(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.HasAccount == nil {
				return nil, errors.New("directive hasAccount is not implemented")
			}
			return ec.directives.HasAccount(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*entities.GithubSearchRepository); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *kloudlite.io/apps/container-registry/internal/domain/entities.GithubSearchRepository`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*entities.GithubSearchRepository)
	fc.Result = res
	return ec.marshalOGithubSearchRepository2kloudliteioappscontainerregistryinternaldomainentitiesGithubSearchRepository(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_cr_searchGithubRepos(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "incomplete_results":
				return ec.fieldContext_GithubSearchRepository_incomplete_results(ctx, field)
			case "repositories":
				return ec.fieldContext_GithubSearchRepository_repositories(ctx, field)
			case "total":
				return ec.fieldContext_GithubSearchRepository_total(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubSearchRepository", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_cr_searchGithubRepos_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_cr_listGithubBranches(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_cr_listGithubBranches(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().CrListGithubBranches(rctx, fc.Args["repoUrl"].(string), fc.Args["pagination"].(*types.Pagination))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedInAndVerified == nil {
				return nil, errors.New("directive isLoggedInAndVerified is not implemented")
			}
			return ec.directives.IsLoggedInAndVerified(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.HasAccount == nil {
				return nil, errors.New("directive hasAccount is not implemented")
			}
			return ec.directives.HasAccount(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*entities.GithubBranch); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*kloudlite.io/apps/container-registry/internal/domain/entities.GithubBranch`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*entities.GithubBranch)
	fc.Result = res
	return ec.marshalOGithubBranch2kloudliteioappscontainerregistryinternaldomainentitiesGithubBranch(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_cr_listGithubBranches(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_GithubBranch_name(ctx, field)
			case "protected":
				return ec.fieldContext_GithubBranch_protected(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubBranch", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_cr_listGithubBranches_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query__service(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query__service(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.__resolve__service(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(fedruntime.Service)
	fc.Result = res
	return ec.marshalN_Service2githubcom99designsgqlgenpluginfederationfedruntimeService(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query__service(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "sdl":
				return ec.fieldContext__Service_sdl(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type _Service", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___schema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___schema(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Repository_accountName(ctx context.Context, field graphql.CollectedField, obj *entities.Repository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Repository_accountName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AccountName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Repository_accountName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Repository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Repository_createdBy(ctx context.Context, field graphql.CollectedField, obj *entities.Repository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Repository_createdBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Repository().CreatedBy(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.KloudliteIoCommonCreatedOrUpdatedBy)
	fc.Result = res
	return ec.marshalNKloudlite_io__common_CreatedOrUpdatedBy2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoCommonCreatedOrUpdatedBy(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Repository_createdBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Repository",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "userEmail":
				return ec.fieldContext_Kloudlite_io__common_CreatedOrUpdatedBy_userEmail(ctx, field)
			case "userId":
				return ec.fieldContext_Kloudlite_io__common_CreatedOrUpdatedBy_userId(ctx, field)
			case "userName":
				return ec.fieldContext_Kloudlite_io__common_CreatedOrUpdatedBy_userName(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Kloudlite_io__common_CreatedOrUpdatedBy", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Repository_creationTime(ctx context.Context, field graphql.CollectedField, obj *entities.Repository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Repository_creationTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Repository().CreationTime(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNDate2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Repository_creationTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Repository",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Repository_id(ctx context.Context, field graphql.CollectedField, obj *entities.Repository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Repository_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Repository().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Repository_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Repository",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Repository_lastUpdatedBy(ctx context.Context, field graphql.CollectedField, obj *entities.Repository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Repository_lastUpdatedBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Repository().LastUpdatedBy(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.KloudliteIoCommonCreatedOrUpdatedBy)
	fc.Result = res
	return ec.marshalNKloudlite_io__common_CreatedOrUpdatedBy2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoCommonCreatedOrUpdatedBy(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Repository_lastUpdatedBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Repository",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "userEmail":
				return ec.fieldContext_Kloudlite_io__common_CreatedOrUpdatedBy_userEmail(ctx, field)
			case "userId":
				return ec.fieldContext_Kloudlite_io__common_CreatedOrUpdatedBy_userId(ctx, field)
			case "userName":
				return ec.fieldContext_Kloudlite_io__common_CreatedOrUpdatedBy_userName(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Kloudlite_io__common_CreatedOrUpdatedBy", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Repository_markedForDeletion(ctx context.Context, field graphql.CollectedField, obj *entities.Repository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Repository_markedForDeletion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MarkedForDeletion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Repository_markedForDeletion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Repository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Repository_name(ctx context.Context, field graphql.CollectedField, obj *entities.Repository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Repository_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Repository_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Repository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Repository_recordVersion(ctx context.Context, field graphql.CollectedField, obj *entities.Repository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Repository_recordVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RecordVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Repository_recordVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Repository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Repository_updateTime(ctx context.Context, field graphql.CollectedField, obj *entities.Repository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Repository_updateTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Repository().UpdateTime(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNDate2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Repository_updateTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Repository",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepositoryEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *model.RepositoryEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepositoryEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepositoryEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepositoryEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepositoryEdge_node(ctx context.Context, field graphql.CollectedField, obj *model.RepositoryEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepositoryEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*entities.Repository)
	fc.Result = res
	return ec.marshalNRepository2kloudliteioappscontainerregistryinternaldomainentitiesRepository(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepositoryEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepositoryEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "accountName":
				return ec.fieldContext_Repository_accountName(ctx, field)
			case "createdBy":
				return ec.fieldContext_Repository_createdBy(ctx, field)
			case "creationTime":
				return ec.fieldContext_Repository_creationTime(ctx, field)
			case "id":
				return ec.fieldContext_Repository_id(ctx, field)
			case "lastUpdatedBy":
				return ec.fieldContext_Repository_lastUpdatedBy(ctx, field)
			case "markedForDeletion":
				return ec.fieldContext_Repository_markedForDeletion(ctx, field)
			case "name":
				return ec.fieldContext_Repository_name(ctx, field)
			case "recordVersion":
				return ec.fieldContext_Repository_recordVersion(ctx, field)
			case "updateTime":
				return ec.fieldContext_Repository_updateTime(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Repository", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepositoryPaginatedRecords_edges(ctx context.Context, field graphql.CollectedField, obj *model.RepositoryPaginatedRecords) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepositoryPaginatedRecords_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.RepositoryEdge)
	fc.Result = res
	return ec.marshalNRepositoryEdge2kloudliteioappscontainerregistryinternalappgraphmodelRepositoryEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepositoryPaginatedRecords_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepositoryPaginatedRecords",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cursor":
				return ec.fieldContext_RepositoryEdge_cursor(ctx, field)
			case "node":
				return ec.fieldContext_RepositoryEdge_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RepositoryEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepositoryPaginatedRecords_pageInfo(ctx context.Context, field graphql.CollectedField, obj *model.RepositoryPaginatedRecords) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepositoryPaginatedRecords_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2kloudliteioappscontainerregistryinternalappgraphmodelPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepositoryPaginatedRecords_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepositoryPaginatedRecords",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepositoryPaginatedRecords_totalCount(ctx context.Context, field graphql.CollectedField, obj *model.RepositoryPaginatedRecords) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepositoryPaginatedRecords_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepositoryPaginatedRecords_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepositoryPaginatedRecords",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Tag_accountName(ctx context.Context, field graphql.CollectedField, obj *entities.Tag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Tag_accountName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AccountName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Tag_accountName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Tag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Tag_actor(ctx context.Context, field graphql.CollectedField, obj *entities.Tag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Tag_actor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Actor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Tag_actor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Tag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Tag_creationTime(ctx context.Context, field graphql.CollectedField, obj *entities.Tag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Tag_creationTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Tag().CreationTime(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNDate2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Tag_creationTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Tag",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Tag_deleting(ctx context.Context, field graphql.CollectedField, obj *entities.Tag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Tag_deleting(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Deleting, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Tag_deleting(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Tag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Tag_digest(ctx context.Context, field graphql.CollectedField, obj *entities.Tag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Tag_digest(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Digest, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Tag_digest(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Tag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Tag_id(ctx context.Context, field graphql.CollectedField, obj *entities.Tag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Tag_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Tag().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Tag_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Tag",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Tag_length(ctx context.Context, field graphql.CollectedField, obj *entities.Tag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Tag_length(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Length, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Tag_length(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Tag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Tag_markedForDeletion(ctx context.Context, field graphql.CollectedField, obj *entities.Tag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Tag_markedForDeletion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MarkedForDeletion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Tag_markedForDeletion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Tag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Tag_mediaType(ctx context.Context, field graphql.CollectedField, obj *entities.Tag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Tag_mediaType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MediaType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Tag_mediaType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Tag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Tag_recordVersion(ctx context.Context, field graphql.CollectedField, obj *entities.Tag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Tag_recordVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RecordVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Tag_recordVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Tag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Tag_references(ctx context.Context, field graphql.CollectedField, obj *entities.Tag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Tag_references(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Tag().References(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesRepoReference)
	fc.Result = res
	return ec.marshalNKloudlite_io__apps__container___registry__internal__domain__entities_RepoReference2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoAppsContainerRegistryInternalDomainEntitiesRepoReference(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Tag_references(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Tag",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "digest":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_RepoReference_digest(ctx, field)
			case "mediaType":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_RepoReference_mediaType(ctx, field)
			case "size":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_RepoReference_size(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Kloudlite_io__apps__container___registry__internal__domain__entities_RepoReference", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Tag_repository(ctx context.Context, field graphql.CollectedField, obj *entities.Tag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Tag_repository(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Repository, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Tag_repository(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Tag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Tag_size(ctx context.Context, field graphql.CollectedField, obj *entities.Tag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Tag_size(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Size, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Tag_size(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Tag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Tag_tags(ctx context.Context, field graphql.CollectedField, obj *entities.Tag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Tag_tags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tags, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Tag_tags(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Tag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Tag_updateTime(ctx context.Context, field graphql.CollectedField, obj *entities.Tag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Tag_updateTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Tag().UpdateTime(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNDate2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Tag_updateTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Tag",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Tag_url(ctx context.Context, field graphql.CollectedField, obj *entities.Tag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Tag_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Tag_url(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Tag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TagEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *model.TagEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TagEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TagEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TagEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TagEdge_node(ctx context.Context, field graphql.CollectedField, obj *model.TagEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TagEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*entities.Tag)
	fc.Result = res
	return ec.marshalNTag2kloudliteioappscontainerregistryinternaldomainentitiesTag(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TagEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TagEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "accountName":
				return ec.fieldContext_Tag_accountName(ctx, field)
			case "actor":
				return ec.fieldContext_Tag_actor(ctx, field)
			case "creationTime":
				return ec.fieldContext_Tag_creationTime(ctx, field)
			case "deleting":
				return ec.fieldContext_Tag_deleting(ctx, field)
			case "digest":
				return ec.fieldContext_Tag_digest(ctx, field)
			case "id":
				return ec.fieldContext_Tag_id(ctx, field)
			case "length":
				return ec.fieldContext_Tag_length(ctx, field)
			case "markedForDeletion":
				return ec.fieldContext_Tag_markedForDeletion(ctx, field)
			case "mediaType":
				return ec.fieldContext_Tag_mediaType(ctx, field)
			case "recordVersion":
				return ec.fieldContext_Tag_recordVersion(ctx, field)
			case "references":
				return ec.fieldContext_Tag_references(ctx, field)
			case "repository":
				return ec.fieldContext_Tag_repository(ctx, field)
			case "size":
				return ec.fieldContext_Tag_size(ctx, field)
			case "tags":
				return ec.fieldContext_Tag_tags(ctx, field)
			case "updateTime":
				return ec.fieldContext_Tag_updateTime(ctx, field)
			case "url":
				return ec.fieldContext_Tag_url(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Tag", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TagPaginatedRecords_edges(ctx context.Context, field graphql.CollectedField, obj *model.TagPaginatedRecords) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TagPaginatedRecords_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.TagEdge)
	fc.Result = res
	return ec.marshalNTagEdge2kloudliteioappscontainerregistryinternalappgraphmodelTagEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TagPaginatedRecords_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TagPaginatedRecords",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cursor":
				return ec.fieldContext_TagEdge_cursor(ctx, field)
			case "node":
				return ec.fieldContext_TagEdge_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TagEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TagPaginatedRecords_pageInfo(ctx context.Context, field graphql.CollectedField, obj *model.TagPaginatedRecords) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TagPaginatedRecords_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2kloudliteioappscontainerregistryinternalappgraphmodelPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TagPaginatedRecords_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TagPaginatedRecords",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TagPaginatedRecords_totalCount(ctx context.Context, field graphql.CollectedField, obj *model.TagPaginatedRecords) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TagPaginatedRecords_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TagPaginatedRecords_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TagPaginatedRecords",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) __Service_sdl(ctx context.Context, field graphql.CollectedField, obj *fedruntime.Service) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext__Service_sdl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SDL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext__Service_sdl(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "_Service",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_locations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_isRepeatable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRepeatable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_defaultValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_types(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_queryType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_queryType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_mutationType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_mutationType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_subscriptionType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_directives(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_directives(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_kind(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_fields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_interfaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_interfaces(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_possibleTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_enumValues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_inputFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_inputFields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_ofType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_ofType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_specifiedByURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpecifiedByURL(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputBuildIn(ctx context.Context, obj interface{}) (entities.Build, error) {
	var it entities.Build
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "repository", "source", "tag"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "repository":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("repository"))
			it.Repository, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "source":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("source"))
			data, err := ec.unmarshalNKloudlite_io__apps__container___registry__internal__domain__entities_GitSourceIn2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoAppsContainerRegistryInternalDomainEntitiesGitSourceIn(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.BuildIn().Source(ctx, &it, data); err != nil {
				return it, err
			}
		case "tag":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tag"))
			it.Tag, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCredentialIn(ctx context.Context, obj interface{}) (entities.Credential, error) {
	var it entities.Credential
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"access", "expiration", "name", "username"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "access":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("access"))
			data, err := ec.unmarshalNKloudlite_io__apps__container___registry__internal__domain__entities_RepoAccess2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoAppsContainerRegistryInternalDomainEntitiesRepoAccess(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.CredentialIn().Access(ctx, &it, data); err != nil {
				return it, err
			}
		case "expiration":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expiration"))
			data, err := ec.unmarshalNKloudlite_io__apps__container___registry__internal__domain__entities_ExpirationIn2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoAppsContainerRegistryInternalDomainEntitiesExpirationIn(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.CredentialIn().Expiration(ctx, &it, data); err != nil {
				return it, err
			}
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "username":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("username"))
			it.UserName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCursorPaginationIn(ctx context.Context, obj interface{}) (repos.CursorPagination, error) {
	var it repos.CursorPagination
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["orderBy"]; !present {
		asMap["orderBy"] = "_id"
	}
	if _, present := asMap["sortDirection"]; !present {
		asMap["sortDirection"] = "ASC"
	}

	fieldsInOrder := [...]string{"after", "before", "first", "last", "orderBy", "sortDirection"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "after":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
			it.After, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "before":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
			it.Before, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "first":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
			it.First, err = ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
		case "last":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
			it.Last, err = ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
		case "orderBy":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
			it.OrderBy, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "sortDirection":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sortDirection"))
			it.SortDirection, err = ec.unmarshalOCursorPaginationSortDirection2kloudliteiopkgreposSortDirection(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputKloudlite_io__apps__container___registry__internal__domain__entities_ExpirationIn(ctx context.Context, obj interface{}) (model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesExpirationIn, error) {
	var it model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesExpirationIn
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"unit", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "unit":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("unit"))
			it.Unit, err = ec.unmarshalNKloudlite_io__apps__container___registry__internal__domain__entities_ExpirationUnit2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoAppsContainerRegistryInternalDomainEntitiesExpirationUnit(ctx, v)
			if err != nil {
				return it, err
			}
		case "value":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			it.Value, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputKloudlite_io__apps__container___registry__internal__domain__entities_GitSourceIn(ctx context.Context, obj interface{}) (model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGitSourceIn, error) {
	var it model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGitSourceIn
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"branch", "pullSecret", "repository"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "branch":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("branch"))
			it.Branch, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "pullSecret":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pullSecret"))
			it.PullSecret, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "repository":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("repository"))
			it.Repository, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputKloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccountIn(ctx context.Context, obj interface{}) (model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubUserAccountIn, error) {
	var it model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubUserAccountIn
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"avatar_url", "id", "login", "node_id", "type"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "avatar_url":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatar_url"))
			it.AvatarURL, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "login":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("login"))
			it.Login, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "node_id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("node_id"))
			it.NodeID, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "type":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			it.Type, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMatchFilterIn(ctx context.Context, obj interface{}) (repos.MatchFilter, error) {
	var it repos.MatchFilter
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"array", "exact", "matchType", "regex"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "array":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("array"))
			it.Array, err = ec.unmarshalOAny2interface(ctx, v)
			if err != nil {
				return it, err
			}
		case "exact":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("exact"))
			it.Exact, err = ec.unmarshalOAny2interface(ctx, v)
			if err != nil {
				return it, err
			}
		case "matchType":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("matchType"))
			it.MatchType, err = ec.unmarshalNMatchFilterMatchType2kloudliteiopkgreposMatchType(ctx, v)
			if err != nil {
				return it, err
			}
		case "regex":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("regex"))
			it.Regex, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPaginationIn(ctx context.Context, obj interface{}) (types.Pagination, error) {
	var it types.Pagination
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"page", "per_page"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "page":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
			it.Page, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "per_page":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("per_page"))
			it.PerPage, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRepositoryIn(ctx context.Context, obj interface{}) (entities.Repository, error) {
	var it entities.Repository
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSearchBuilds(ctx context.Context, obj interface{}) (model.SearchBuilds, error) {
	var it model.SearchBuilds
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"text"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "text":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("text"))
			it.Text, err = ec.unmarshalOMatchFilterIn2kloudliteiopkgreposMatchFilter(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSearchCreds(ctx context.Context, obj interface{}) (model.SearchCreds, error) {
	var it model.SearchCreds
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"text"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "text":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("text"))
			it.Text, err = ec.unmarshalOMatchFilterIn2kloudliteiopkgreposMatchFilter(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSearchRepos(ctx context.Context, obj interface{}) (model.SearchRepos, error) {
	var it model.SearchRepos
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"text"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "text":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("text"))
			it.Text, err = ec.unmarshalOMatchFilterIn2kloudliteiopkgreposMatchFilter(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var buildImplementors = []string{"Build"}

func (ec *executionContext) _Build(ctx context.Context, sel ast.SelectionSet, obj *entities.Build) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, buildImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Build")
		case "accountName":

			out.Values[i] = ec._Build_accountName(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "createdBy":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Build_createdBy(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "creationTime":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Build_creationTime(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "id":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Build_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "lastUpdatedBy":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Build_lastUpdatedBy(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "markedForDeletion":

			out.Values[i] = ec._Build_markedForDeletion(ctx, field, obj)

		case "name":

			out.Values[i] = ec._Build_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "recordVersion":

			out.Values[i] = ec._Build_recordVersion(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "repository":

			out.Values[i] = ec._Build_repository(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "source":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Build_source(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "tag":

			out.Values[i] = ec._Build_tag(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "updateTime":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Build_updateTime(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var buildEdgeImplementors = []string{"BuildEdge"}

func (ec *executionContext) _BuildEdge(ctx context.Context, sel ast.SelectionSet, obj *model.BuildEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, buildEdgeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BuildEdge")
		case "cursor":

			out.Values[i] = ec._BuildEdge_cursor(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "node":

			out.Values[i] = ec._BuildEdge_node(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var buildPaginatedRecordsImplementors = []string{"BuildPaginatedRecords"}

func (ec *executionContext) _BuildPaginatedRecords(ctx context.Context, sel ast.SelectionSet, obj *model.BuildPaginatedRecords) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, buildPaginatedRecordsImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BuildPaginatedRecords")
		case "edges":

			out.Values[i] = ec._BuildPaginatedRecords_edges(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "pageInfo":

			out.Values[i] = ec._BuildPaginatedRecords_pageInfo(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalCount":

			out.Values[i] = ec._BuildPaginatedRecords_totalCount(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var cRCheckNameAvailabilityOutputImplementors = []string{"CRCheckNameAvailabilityOutput"}

func (ec *executionContext) _CRCheckNameAvailabilityOutput(ctx context.Context, sel ast.SelectionSet, obj *domain.CheckNameAvailabilityOutput) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, cRCheckNameAvailabilityOutputImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CRCheckNameAvailabilityOutput")
		case "result":

			out.Values[i] = ec._CRCheckNameAvailabilityOutput_result(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "suggestedNames":

			out.Values[i] = ec._CRCheckNameAvailabilityOutput_suggestedNames(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var credentialImplementors = []string{"Credential"}

func (ec *executionContext) _Credential(ctx context.Context, sel ast.SelectionSet, obj *entities.Credential) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, credentialImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Credential")
		case "access":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Credential_access(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "accountName":

			out.Values[i] = ec._Credential_accountName(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "createdBy":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Credential_createdBy(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "creationTime":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Credential_creationTime(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "expiration":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Credential_expiration(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "id":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Credential_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "lastUpdatedBy":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Credential_lastUpdatedBy(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "markedForDeletion":

			out.Values[i] = ec._Credential_markedForDeletion(ctx, field, obj)

		case "name":

			out.Values[i] = ec._Credential_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "recordVersion":

			out.Values[i] = ec._Credential_recordVersion(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "updateTime":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Credential_updateTime(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "username":

			out.Values[i] = ec._Credential_username(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var credentialEdgeImplementors = []string{"CredentialEdge"}

func (ec *executionContext) _CredentialEdge(ctx context.Context, sel ast.SelectionSet, obj *model.CredentialEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, credentialEdgeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CredentialEdge")
		case "cursor":

			out.Values[i] = ec._CredentialEdge_cursor(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "node":

			out.Values[i] = ec._CredentialEdge_node(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var credentialPaginatedRecordsImplementors = []string{"CredentialPaginatedRecords"}

func (ec *executionContext) _CredentialPaginatedRecords(ctx context.Context, sel ast.SelectionSet, obj *model.CredentialPaginatedRecords) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, credentialPaginatedRecordsImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CredentialPaginatedRecords")
		case "edges":

			out.Values[i] = ec._CredentialPaginatedRecords_edges(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "pageInfo":

			out.Values[i] = ec._CredentialPaginatedRecords_pageInfo(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalCount":

			out.Values[i] = ec._CredentialPaginatedRecords_totalCount(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var cursorPaginationImplementors = []string{"CursorPagination"}

func (ec *executionContext) _CursorPagination(ctx context.Context, sel ast.SelectionSet, obj *repos.CursorPagination) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, cursorPaginationImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CursorPagination")
		case "after":

			out.Values[i] = ec._CursorPagination_after(ctx, field, obj)

		case "before":

			out.Values[i] = ec._CursorPagination_before(ctx, field, obj)

		case "first":

			out.Values[i] = ec._CursorPagination_first(ctx, field, obj)

		case "last":

			out.Values[i] = ec._CursorPagination_last(ctx, field, obj)

		case "orderBy":

			out.Values[i] = ec._CursorPagination_orderBy(ctx, field, obj)

		case "sortDirection":

			out.Values[i] = ec._CursorPagination_sortDirection(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var githubBranchImplementors = []string{"GithubBranch"}

func (ec *executionContext) _GithubBranch(ctx context.Context, sel ast.SelectionSet, obj *entities.GithubBranch) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, githubBranchImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GithubBranch")
		case "name":

			out.Values[i] = ec._GithubBranch_name(ctx, field, obj)

		case "protected":

			out.Values[i] = ec._GithubBranch_protected(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var githubInstallationImplementors = []string{"GithubInstallation"}

func (ec *executionContext) _GithubInstallation(ctx context.Context, sel ast.SelectionSet, obj *entities.GithubInstallation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, githubInstallationImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GithubInstallation")
		case "account":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GithubInstallation_account(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "app_id":

			out.Values[i] = ec._GithubInstallation_app_id(ctx, field, obj)

		case "id":

			out.Values[i] = ec._GithubInstallation_id(ctx, field, obj)

		case "node_id":

			out.Values[i] = ec._GithubInstallation_node_id(ctx, field, obj)

		case "repositories_url":

			out.Values[i] = ec._GithubInstallation_repositories_url(ctx, field, obj)

		case "target_id":

			out.Values[i] = ec._GithubInstallation_target_id(ctx, field, obj)

		case "target_type":

			out.Values[i] = ec._GithubInstallation_target_type(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var githubListRepositoryImplementors = []string{"GithubListRepository"}

func (ec *executionContext) _GithubListRepository(ctx context.Context, sel ast.SelectionSet, obj *entities.GithubListRepository) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, githubListRepositoryImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GithubListRepository")
		case "repositories":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GithubListRepository_repositories(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "total_count":

			out.Values[i] = ec._GithubListRepository_total_count(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var githubSearchRepositoryImplementors = []string{"GithubSearchRepository"}

func (ec *executionContext) _GithubSearchRepository(ctx context.Context, sel ast.SelectionSet, obj *entities.GithubSearchRepository) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, githubSearchRepositoryImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GithubSearchRepository")
		case "incomplete_results":

			out.Values[i] = ec._GithubSearchRepository_incomplete_results(ctx, field, obj)

		case "repositories":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GithubSearchRepository_repositories(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "total":

			out.Values[i] = ec._GithubSearchRepository_total(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var kloudlite_io__apps__container___registry__internal__domain__entities_ExpirationImplementors = []string{"Kloudlite_io__apps__container___registry__internal__domain__entities_Expiration"}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_Expiration(ctx context.Context, sel ast.SelectionSet, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesExpiration) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, kloudlite_io__apps__container___registry__internal__domain__entities_ExpirationImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Kloudlite_io__apps__container___registry__internal__domain__entities_Expiration")
		case "unit":

			out.Values[i] = ec._Kloudlite_io__apps__container___registry__internal__domain__entities_Expiration_unit(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "value":

			out.Values[i] = ec._Kloudlite_io__apps__container___registry__internal__domain__entities_Expiration_value(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var kloudlite_io__apps__container___registry__internal__domain__entities_GitSourceImplementors = []string{"Kloudlite_io__apps__container___registry__internal__domain__entities_GitSource"}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_GitSource(ctx context.Context, sel ast.SelectionSet, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGitSource) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, kloudlite_io__apps__container___registry__internal__domain__entities_GitSourceImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Kloudlite_io__apps__container___registry__internal__domain__entities_GitSource")
		case "branch":

			out.Values[i] = ec._Kloudlite_io__apps__container___registry__internal__domain__entities_GitSource_branch(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "pullSecret":

			out.Values[i] = ec._Kloudlite_io__apps__container___registry__internal__domain__entities_GitSource_pullSecret(ctx, field, obj)

		case "repository":

			out.Values[i] = ec._Kloudlite_io__apps__container___registry__internal__domain__entities_GitSource_repository(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepositoryImplementors = []string{"Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository"}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository(ctx context.Context, sel ast.SelectionSet, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubRepository) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepositoryImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository")
		case "archived":

			out.Values[i] = ec._Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_archived(ctx, field, obj)

		case "clone_url":

			out.Values[i] = ec._Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_clone_url(ctx, field, obj)

		case "created_at":

			out.Values[i] = ec._Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_created_at(ctx, field, obj)

		case "default_branch":

			out.Values[i] = ec._Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_default_branch(ctx, field, obj)

		case "description":

			out.Values[i] = ec._Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_description(ctx, field, obj)

		case "disabled":

			out.Values[i] = ec._Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_disabled(ctx, field, obj)

		case "full_name":

			out.Values[i] = ec._Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_full_name(ctx, field, obj)

		case "git_url":

			out.Values[i] = ec._Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_git_url(ctx, field, obj)

		case "gitignore_template":

			out.Values[i] = ec._Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_gitignore_template(ctx, field, obj)

		case "html_url":

			out.Values[i] = ec._Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_html_url(ctx, field, obj)

		case "id":

			out.Values[i] = ec._Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_id(ctx, field, obj)

		case "language":

			out.Values[i] = ec._Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_language(ctx, field, obj)

		case "master_branch":

			out.Values[i] = ec._Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_master_branch(ctx, field, obj)

		case "mirror_url":

			out.Values[i] = ec._Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_mirror_url(ctx, field, obj)

		case "name":

			out.Values[i] = ec._Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_name(ctx, field, obj)

		case "node_id":

			out.Values[i] = ec._Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_node_id(ctx, field, obj)

		case "permissions":

			out.Values[i] = ec._Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_permissions(ctx, field, obj)

		case "private":

			out.Values[i] = ec._Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_private(ctx, field, obj)

		case "pushed_at":

			out.Values[i] = ec._Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_pushed_at(ctx, field, obj)

		case "size":

			out.Values[i] = ec._Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_size(ctx, field, obj)

		case "team_id":

			out.Values[i] = ec._Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_team_id(ctx, field, obj)

		case "updated_at":

			out.Values[i] = ec._Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_updated_at(ctx, field, obj)

		case "url":

			out.Values[i] = ec._Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_url(ctx, field, obj)

		case "visibility":

			out.Values[i] = ec._Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_visibility(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccountImplementors = []string{"Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount"}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount(ctx context.Context, sel ast.SelectionSet, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubUserAccount) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccountImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount")
		case "avatar_url":

			out.Values[i] = ec._Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount_avatar_url(ctx, field, obj)

		case "id":

			out.Values[i] = ec._Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount_id(ctx, field, obj)

		case "login":

			out.Values[i] = ec._Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount_login(ctx, field, obj)

		case "node_id":

			out.Values[i] = ec._Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount_node_id(ctx, field, obj)

		case "type":

			out.Values[i] = ec._Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount_type(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var kloudlite_io__apps__container___registry__internal__domain__entities_RepoReferenceImplementors = []string{"Kloudlite_io__apps__container___registry__internal__domain__entities_RepoReference"}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_RepoReference(ctx context.Context, sel ast.SelectionSet, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesRepoReference) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, kloudlite_io__apps__container___registry__internal__domain__entities_RepoReferenceImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Kloudlite_io__apps__container___registry__internal__domain__entities_RepoReference")
		case "digest":

			out.Values[i] = ec._Kloudlite_io__apps__container___registry__internal__domain__entities_RepoReference_digest(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "mediaType":

			out.Values[i] = ec._Kloudlite_io__apps__container___registry__internal__domain__entities_RepoReference_mediaType(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "size":

			out.Values[i] = ec._Kloudlite_io__apps__container___registry__internal__domain__entities_RepoReference_size(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var kloudlite_io__common_CreatedOrUpdatedByImplementors = []string{"Kloudlite_io__common_CreatedOrUpdatedBy"}

func (ec *executionContext) _Kloudlite_io__common_CreatedOrUpdatedBy(ctx context.Context, sel ast.SelectionSet, obj *model.KloudliteIoCommonCreatedOrUpdatedBy) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, kloudlite_io__common_CreatedOrUpdatedByImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Kloudlite_io__common_CreatedOrUpdatedBy")
		case "userEmail":

			out.Values[i] = ec._Kloudlite_io__common_CreatedOrUpdatedBy_userEmail(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "userId":

			out.Values[i] = ec._Kloudlite_io__common_CreatedOrUpdatedBy_userId(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "userName":

			out.Values[i] = ec._Kloudlite_io__common_CreatedOrUpdatedBy_userName(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var matchFilterImplementors = []string{"MatchFilter"}

func (ec *executionContext) _MatchFilter(ctx context.Context, sel ast.SelectionSet, obj *repos.MatchFilter) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, matchFilterImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MatchFilter")
		case "array":

			out.Values[i] = ec._MatchFilter_array(ctx, field, obj)

		case "exact":

			out.Values[i] = ec._MatchFilter_exact(ctx, field, obj)

		case "matchType":

			out.Values[i] = ec._MatchFilter_matchType(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "regex":

			out.Values[i] = ec._MatchFilter_regex(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "cr_createRepo":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_cr_createRepo(ctx, field)
			})

		case "cr_createCred":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_cr_createCred(ctx, field)
			})

		case "cr_deleteRepo":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_cr_deleteRepo(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "cr_deleteCred":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_cr_deleteCred(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "cr_deleteTag":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_cr_deleteTag(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "cr_addBuild":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_cr_addBuild(ctx, field)
			})

		case "cr_updateBuild":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_cr_updateBuild(ctx, field)
			})

		case "cr_deleteBuild":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_cr_deleteBuild(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "cr_triggerBuild":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_cr_triggerBuild(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var pageInfoImplementors = []string{"PageInfo"}

func (ec *executionContext) _PageInfo(ctx context.Context, sel ast.SelectionSet, obj *model.PageInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, pageInfoImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PageInfo")
		case "endCursor":

			out.Values[i] = ec._PageInfo_endCursor(ctx, field, obj)

		case "hasNextPage":

			out.Values[i] = ec._PageInfo_hasNextPage(ctx, field, obj)

		case "hasPreviousPage":

			out.Values[i] = ec._PageInfo_hasPreviousPage(ctx, field, obj)

		case "startCursor":

			out.Values[i] = ec._PageInfo_startCursor(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var paginationImplementors = []string{"Pagination"}

func (ec *executionContext) _Pagination(ctx context.Context, sel ast.SelectionSet, obj *types.Pagination) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, paginationImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Pagination")
		case "page":

			out.Values[i] = ec._Pagination_page(ctx, field, obj)

		case "per_page":

			out.Values[i] = ec._Pagination_per_page(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "cr_listRepos":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_cr_listRepos(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "cr_listCreds":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_cr_listCreds(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "cr_listTags":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_cr_listTags(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "cr_getCredToken":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_cr_getCredToken(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "cr_checkUserNameAvailability":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_cr_checkUserNameAvailability(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "cr_getBuild":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_cr_getBuild(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "cr_listBuilds":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_cr_listBuilds(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "cr_listGithubInstallations":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_cr_listGithubInstallations(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "cr_listGithubRepos":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_cr_listGithubRepos(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "cr_searchGithubRepos":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_cr_searchGithubRepos(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "cr_listGithubBranches":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_cr_listGithubBranches(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "_service":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query__service(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "__type":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})

		case "__schema":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var repositoryImplementors = []string{"Repository"}

func (ec *executionContext) _Repository(ctx context.Context, sel ast.SelectionSet, obj *entities.Repository) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, repositoryImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Repository")
		case "accountName":

			out.Values[i] = ec._Repository_accountName(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "createdBy":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Repository_createdBy(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "creationTime":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Repository_creationTime(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "id":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Repository_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "lastUpdatedBy":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Repository_lastUpdatedBy(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "markedForDeletion":

			out.Values[i] = ec._Repository_markedForDeletion(ctx, field, obj)

		case "name":

			out.Values[i] = ec._Repository_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "recordVersion":

			out.Values[i] = ec._Repository_recordVersion(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "updateTime":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Repository_updateTime(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var repositoryEdgeImplementors = []string{"RepositoryEdge"}

func (ec *executionContext) _RepositoryEdge(ctx context.Context, sel ast.SelectionSet, obj *model.RepositoryEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, repositoryEdgeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RepositoryEdge")
		case "cursor":

			out.Values[i] = ec._RepositoryEdge_cursor(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "node":

			out.Values[i] = ec._RepositoryEdge_node(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var repositoryPaginatedRecordsImplementors = []string{"RepositoryPaginatedRecords"}

func (ec *executionContext) _RepositoryPaginatedRecords(ctx context.Context, sel ast.SelectionSet, obj *model.RepositoryPaginatedRecords) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, repositoryPaginatedRecordsImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RepositoryPaginatedRecords")
		case "edges":

			out.Values[i] = ec._RepositoryPaginatedRecords_edges(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "pageInfo":

			out.Values[i] = ec._RepositoryPaginatedRecords_pageInfo(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalCount":

			out.Values[i] = ec._RepositoryPaginatedRecords_totalCount(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var tagImplementors = []string{"Tag"}

func (ec *executionContext) _Tag(ctx context.Context, sel ast.SelectionSet, obj *entities.Tag) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, tagImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Tag")
		case "accountName":

			out.Values[i] = ec._Tag_accountName(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "actor":

			out.Values[i] = ec._Tag_actor(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "creationTime":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Tag_creationTime(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "deleting":

			out.Values[i] = ec._Tag_deleting(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "digest":

			out.Values[i] = ec._Tag_digest(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "id":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Tag_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "length":

			out.Values[i] = ec._Tag_length(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "markedForDeletion":

			out.Values[i] = ec._Tag_markedForDeletion(ctx, field, obj)

		case "mediaType":

			out.Values[i] = ec._Tag_mediaType(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "recordVersion":

			out.Values[i] = ec._Tag_recordVersion(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "references":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Tag_references(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "repository":

			out.Values[i] = ec._Tag_repository(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "size":

			out.Values[i] = ec._Tag_size(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "tags":

			out.Values[i] = ec._Tag_tags(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "updateTime":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Tag_updateTime(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "url":

			out.Values[i] = ec._Tag_url(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var tagEdgeImplementors = []string{"TagEdge"}

func (ec *executionContext) _TagEdge(ctx context.Context, sel ast.SelectionSet, obj *model.TagEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, tagEdgeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TagEdge")
		case "cursor":

			out.Values[i] = ec._TagEdge_cursor(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "node":

			out.Values[i] = ec._TagEdge_node(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var tagPaginatedRecordsImplementors = []string{"TagPaginatedRecords"}

func (ec *executionContext) _TagPaginatedRecords(ctx context.Context, sel ast.SelectionSet, obj *model.TagPaginatedRecords) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, tagPaginatedRecordsImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TagPaginatedRecords")
		case "edges":

			out.Values[i] = ec._TagPaginatedRecords_edges(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "pageInfo":

			out.Values[i] = ec._TagPaginatedRecords_pageInfo(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalCount":

			out.Values[i] = ec._TagPaginatedRecords_totalCount(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var _ServiceImplementors = []string{"_Service"}

func (ec *executionContext) __Service(ctx context.Context, sel ast.SelectionSet, obj *fedruntime.Service) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, _ServiceImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("_Service")
		case "sdl":

			out.Values[i] = ec.__Service_sdl(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":

			out.Values[i] = ec.___Directive_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___Directive_description(ctx, field, obj)

		case "locations":

			out.Values[i] = ec.___Directive_locations(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "args":

			out.Values[i] = ec.___Directive_args(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isRepeatable":

			out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":

			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)

		case "isDeprecated":

			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":

			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":

			out.Values[i] = ec.___Field_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___Field_description(ctx, field, obj)

		case "args":

			out.Values[i] = ec.___Field_args(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "type":

			out.Values[i] = ec.___Field_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isDeprecated":

			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":

			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":

			out.Values[i] = ec.___InputValue_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___InputValue_description(ctx, field, obj)

		case "type":

			out.Values[i] = ec.___InputValue_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "defaultValue":

			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":

			out.Values[i] = ec.___Schema_description(ctx, field, obj)

		case "types":

			out.Values[i] = ec.___Schema_types(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "queryType":

			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "mutationType":

			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)

		case "subscriptionType":

			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)

		case "directives":

			out.Values[i] = ec.___Schema_directives(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":

			out.Values[i] = ec.___Type_kind(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":

			out.Values[i] = ec.___Type_name(ctx, field, obj)

		case "description":

			out.Values[i] = ec.___Type_description(ctx, field, obj)

		case "fields":

			out.Values[i] = ec.___Type_fields(ctx, field, obj)

		case "interfaces":

			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)

		case "possibleTypes":

			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)

		case "enumValues":

			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)

		case "inputFields":

			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)

		case "ofType":

			out.Values[i] = ec.___Type_ofType(ctx, field, obj)

		case "specifiedByURL":

			out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) unmarshalNAny2interface(ctx context.Context, v interface{}) (any, error) {
	res, err := graphql.UnmarshalAny(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAny2interface(ctx context.Context, sel ast.SelectionSet, v any) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	res := graphql.MarshalAny(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNBuild2kloudliteioappscontainerregistryinternaldomainentitiesBuild(ctx context.Context, sel ast.SelectionSet, v *entities.Build) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Build(ctx, sel, v)
}

func (ec *executionContext) marshalNBuildEdge2kloudliteioappscontainerregistryinternalappgraphmodelBuildEdge(ctx context.Context, sel ast.SelectionSet, v []*model.BuildEdge) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNBuildEdge2kloudliteioappscontainerregistryinternalappgraphmodelBuildEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNBuildEdge2kloudliteioappscontainerregistryinternalappgraphmodelBuildEdge(ctx context.Context, sel ast.SelectionSet, v *model.BuildEdge) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._BuildEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalNBuildIn2kloudliteioappscontainerregistryinternaldomainentitiesBuild(ctx context.Context, v interface{}) (entities.Build, error) {
	res, err := ec.unmarshalInputBuildIn(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCRCheckNameAvailabilityOutput2kloudliteioappscontainerregistryinternaldomainCheckNameAvailabilityOutput(ctx context.Context, sel ast.SelectionSet, v domain.CheckNameAvailabilityOutput) graphql.Marshaler {
	return ec._CRCheckNameAvailabilityOutput(ctx, sel, &v)
}

func (ec *executionContext) marshalNCRCheckNameAvailabilityOutput2kloudliteioappscontainerregistryinternaldomainCheckNameAvailabilityOutput(ctx context.Context, sel ast.SelectionSet, v *domain.CheckNameAvailabilityOutput) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CRCheckNameAvailabilityOutput(ctx, sel, v)
}

func (ec *executionContext) marshalNCredential2kloudliteioappscontainerregistryinternaldomainentitiesCredential(ctx context.Context, sel ast.SelectionSet, v *entities.Credential) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Credential(ctx, sel, v)
}

func (ec *executionContext) marshalNCredentialEdge2kloudliteioappscontainerregistryinternalappgraphmodelCredentialEdge(ctx context.Context, sel ast.SelectionSet, v []*model.CredentialEdge) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCredentialEdge2kloudliteioappscontainerregistryinternalappgraphmodelCredentialEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNCredentialEdge2kloudliteioappscontainerregistryinternalappgraphmodelCredentialEdge(ctx context.Context, sel ast.SelectionSet, v *model.CredentialEdge) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CredentialEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCredentialIn2kloudliteioappscontainerregistryinternaldomainentitiesCredential(ctx context.Context, v interface{}) (entities.Credential, error) {
	res, err := ec.unmarshalInputCredentialIn(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNDate2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDate2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNID2kloudliteiopkgreposID(ctx context.Context, v interface{}) (repos.ID, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := repos.ID(tmp)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNID2kloudliteiopkgreposID(ctx context.Context, sel ast.SelectionSet, v repos.ID) graphql.Marshaler {
	res := graphql.MarshalString(string(v))
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v interface{}) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNKloudlite_io__apps__container___registry__internal__domain__entities_Expiration2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoAppsContainerRegistryInternalDomainEntitiesExpiration(ctx context.Context, sel ast.SelectionSet, v model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesExpiration) graphql.Marshaler {
	return ec._Kloudlite_io__apps__container___registry__internal__domain__entities_Expiration(ctx, sel, &v)
}

func (ec *executionContext) marshalNKloudlite_io__apps__container___registry__internal__domain__entities_Expiration2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoAppsContainerRegistryInternalDomainEntitiesExpiration(ctx context.Context, sel ast.SelectionSet, v *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesExpiration) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Kloudlite_io__apps__container___registry__internal__domain__entities_Expiration(ctx, sel, v)
}

func (ec *executionContext) unmarshalNKloudlite_io__apps__container___registry__internal__domain__entities_ExpirationIn2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoAppsContainerRegistryInternalDomainEntitiesExpirationIn(ctx context.Context, v interface{}) (model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesExpirationIn, error) {
	res, err := ec.unmarshalInputKloudlite_io__apps__container___registry__internal__domain__entities_ExpirationIn(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNKloudlite_io__apps__container___registry__internal__domain__entities_ExpirationIn2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoAppsContainerRegistryInternalDomainEntitiesExpirationIn(ctx context.Context, v interface{}) (*model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesExpirationIn, error) {
	res, err := ec.unmarshalInputKloudlite_io__apps__container___registry__internal__domain__entities_ExpirationIn(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNKloudlite_io__apps__container___registry__internal__domain__entities_ExpirationUnit2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoAppsContainerRegistryInternalDomainEntitiesExpirationUnit(ctx context.Context, v interface{}) (model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesExpirationUnit, error) {
	var res model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesExpirationUnit
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNKloudlite_io__apps__container___registry__internal__domain__entities_ExpirationUnit2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoAppsContainerRegistryInternalDomainEntitiesExpirationUnit(ctx context.Context, sel ast.SelectionSet, v model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesExpirationUnit) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNKloudlite_io__apps__container___registry__internal__domain__entities_GitSource2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoAppsContainerRegistryInternalDomainEntitiesGitSource(ctx context.Context, sel ast.SelectionSet, v model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGitSource) graphql.Marshaler {
	return ec._Kloudlite_io__apps__container___registry__internal__domain__entities_GitSource(ctx, sel, &v)
}

func (ec *executionContext) marshalNKloudlite_io__apps__container___registry__internal__domain__entities_GitSource2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoAppsContainerRegistryInternalDomainEntitiesGitSource(ctx context.Context, sel ast.SelectionSet, v *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGitSource) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Kloudlite_io__apps__container___registry__internal__domain__entities_GitSource(ctx, sel, v)
}

func (ec *executionContext) unmarshalNKloudlite_io__apps__container___registry__internal__domain__entities_GitSourceIn2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoAppsContainerRegistryInternalDomainEntitiesGitSourceIn(ctx context.Context, v interface{}) (model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGitSourceIn, error) {
	res, err := ec.unmarshalInputKloudlite_io__apps__container___registry__internal__domain__entities_GitSourceIn(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNKloudlite_io__apps__container___registry__internal__domain__entities_GitSourceIn2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoAppsContainerRegistryInternalDomainEntitiesGitSourceIn(ctx context.Context, v interface{}) (*model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGitSourceIn, error) {
	res, err := ec.unmarshalInputKloudlite_io__apps__container___registry__internal__domain__entities_GitSourceIn(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNKloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubRepository(ctx context.Context, sel ast.SelectionSet, v []*model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubRepository) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOKloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubRepository(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) unmarshalNKloudlite_io__apps__container___registry__internal__domain__entities_RepoAccess2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoAppsContainerRegistryInternalDomainEntitiesRepoAccess(ctx context.Context, v interface{}) (model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesRepoAccess, error) {
	var res model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesRepoAccess
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNKloudlite_io__apps__container___registry__internal__domain__entities_RepoAccess2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoAppsContainerRegistryInternalDomainEntitiesRepoAccess(ctx context.Context, sel ast.SelectionSet, v model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesRepoAccess) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNKloudlite_io__apps__container___registry__internal__domain__entities_RepoReference2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoAppsContainerRegistryInternalDomainEntitiesRepoReference(ctx context.Context, sel ast.SelectionSet, v []*model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesRepoReference) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNKloudlite_io__apps__container___registry__internal__domain__entities_RepoReference2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoAppsContainerRegistryInternalDomainEntitiesRepoReference(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNKloudlite_io__apps__container___registry__internal__domain__entities_RepoReference2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoAppsContainerRegistryInternalDomainEntitiesRepoReference(ctx context.Context, sel ast.SelectionSet, v *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesRepoReference) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Kloudlite_io__apps__container___registry__internal__domain__entities_RepoReference(ctx, sel, v)
}

func (ec *executionContext) marshalNKloudlite_io__common_CreatedOrUpdatedBy2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoCommonCreatedOrUpdatedBy(ctx context.Context, sel ast.SelectionSet, v model.KloudliteIoCommonCreatedOrUpdatedBy) graphql.Marshaler {
	return ec._Kloudlite_io__common_CreatedOrUpdatedBy(ctx, sel, &v)
}

func (ec *executionContext) marshalNKloudlite_io__common_CreatedOrUpdatedBy2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoCommonCreatedOrUpdatedBy(ctx context.Context, sel ast.SelectionSet, v *model.KloudliteIoCommonCreatedOrUpdatedBy) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Kloudlite_io__common_CreatedOrUpdatedBy(ctx, sel, v)
}

func (ec *executionContext) unmarshalNMatchFilterMatchType2kloudliteiopkgreposMatchType(ctx context.Context, v interface{}) (repos.MatchType, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := repos.MatchType(tmp)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMatchFilterMatchType2kloudliteiopkgreposMatchType(ctx context.Context, sel ast.SelectionSet, v repos.MatchType) graphql.Marshaler {
	res := graphql.MarshalString(string(v))
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNPageInfo2kloudliteioappscontainerregistryinternalappgraphmodelPageInfo(ctx context.Context, sel ast.SelectionSet, v *model.PageInfo) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PageInfo(ctx, sel, v)
}

func (ec *executionContext) marshalNRepository2kloudliteioappscontainerregistryinternaldomainentitiesRepository(ctx context.Context, sel ast.SelectionSet, v *entities.Repository) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Repository(ctx, sel, v)
}

func (ec *executionContext) marshalNRepositoryEdge2kloudliteioappscontainerregistryinternalappgraphmodelRepositoryEdge(ctx context.Context, sel ast.SelectionSet, v []*model.RepositoryEdge) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRepositoryEdge2kloudliteioappscontainerregistryinternalappgraphmodelRepositoryEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNRepositoryEdge2kloudliteioappscontainerregistryinternalappgraphmodelRepositoryEdge(ctx context.Context, sel ast.SelectionSet, v *model.RepositoryEdge) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RepositoryEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalNRepositoryIn2kloudliteioappscontainerregistryinternaldomainentitiesRepository(ctx context.Context, v interface{}) (entities.Repository, error) {
	res, err := ec.unmarshalInputRepositoryIn(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTag2kloudliteioappscontainerregistryinternaldomainentitiesTag(ctx context.Context, sel ast.SelectionSet, v *entities.Tag) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Tag(ctx, sel, v)
}

func (ec *executionContext) marshalNTagEdge2kloudliteioappscontainerregistryinternalappgraphmodelTagEdge(ctx context.Context, sel ast.SelectionSet, v []*model.TagEdge) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTagEdge2kloudliteioappscontainerregistryinternalappgraphmodelTagEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTagEdge2kloudliteioappscontainerregistryinternalappgraphmodelTagEdge(ctx context.Context, sel ast.SelectionSet, v *model.TagEdge) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TagEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalN_FieldSet2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN_FieldSet2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalN_Service2githubcom99designsgqlgenpluginfederationfedruntimeService(ctx context.Context, sel ast.SelectionSet, v fedruntime.Service) graphql.Marshaler {
	return ec.__Service(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalOAny2interface(ctx context.Context, v interface{}) (any, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalAny(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOAny2interface(ctx context.Context, sel ast.SelectionSet, v any) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalAny(v)
	return res
}

func (ec *executionContext) unmarshalOAny2interface(ctx context.Context, v interface{}) ([]any, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]any, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNAny2interface(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOAny2interface(ctx context.Context, sel ast.SelectionSet, v []any) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNAny2interface(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalBoolean(*v)
	return res
}

func (ec *executionContext) marshalOBuild2kloudliteioappscontainerregistryinternaldomainentitiesBuild(ctx context.Context, sel ast.SelectionSet, v *entities.Build) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Build(ctx, sel, v)
}

func (ec *executionContext) marshalOBuildPaginatedRecords2kloudliteioappscontainerregistryinternalappgraphmodelBuildPaginatedRecords(ctx context.Context, sel ast.SelectionSet, v *model.BuildPaginatedRecords) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._BuildPaginatedRecords(ctx, sel, v)
}

func (ec *executionContext) marshalOCredential2kloudliteioappscontainerregistryinternaldomainentitiesCredential(ctx context.Context, sel ast.SelectionSet, v *entities.Credential) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Credential(ctx, sel, v)
}

func (ec *executionContext) marshalOCredentialPaginatedRecords2kloudliteioappscontainerregistryinternalappgraphmodelCredentialPaginatedRecords(ctx context.Context, sel ast.SelectionSet, v *model.CredentialPaginatedRecords) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CredentialPaginatedRecords(ctx, sel, v)
}

func (ec *executionContext) unmarshalOCursorPaginationIn2kloudliteiopkgreposCursorPagination(ctx context.Context, v interface{}) (*repos.CursorPagination, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCursorPaginationIn(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOCursorPaginationSortDirection2kloudliteiopkgreposSortDirection(ctx context.Context, v interface{}) (repos.SortDirection, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := repos.SortDirection(tmp)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOCursorPaginationSortDirection2kloudliteiopkgreposSortDirection(ctx context.Context, sel ast.SelectionSet, v repos.SortDirection) graphql.Marshaler {
	res := graphql.MarshalString(string(v))
	return res
}

func (ec *executionContext) unmarshalODate2string(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalODate2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) marshalOGithubBranch2kloudliteioappscontainerregistryinternaldomainentitiesGithubBranch(ctx context.Context, sel ast.SelectionSet, v []*entities.GithubBranch) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOGithubBranch2kloudliteioappscontainerregistryinternaldomainentitiesGithubBranch(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOGithubBranch2kloudliteioappscontainerregistryinternaldomainentitiesGithubBranch(ctx context.Context, sel ast.SelectionSet, v *entities.GithubBranch) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GithubBranch(ctx, sel, v)
}

func (ec *executionContext) marshalOGithubInstallation2kloudliteioappscontainerregistryinternaldomainentitiesGithubInstallation(ctx context.Context, sel ast.SelectionSet, v []*entities.GithubInstallation) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOGithubInstallation2kloudliteioappscontainerregistryinternaldomainentitiesGithubInstallation(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOGithubInstallation2kloudliteioappscontainerregistryinternaldomainentitiesGithubInstallation(ctx context.Context, sel ast.SelectionSet, v *entities.GithubInstallation) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GithubInstallation(ctx, sel, v)
}

func (ec *executionContext) marshalOGithubListRepository2kloudliteioappscontainerregistryinternaldomainentitiesGithubListRepository(ctx context.Context, sel ast.SelectionSet, v *entities.GithubListRepository) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GithubListRepository(ctx, sel, v)
}

func (ec *executionContext) marshalOGithubSearchRepository2kloudliteioappscontainerregistryinternaldomainentitiesGithubSearchRepository(ctx context.Context, sel ast.SelectionSet, v *entities.GithubSearchRepository) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GithubSearchRepository(ctx, sel, v)
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v interface{}) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	return res
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalInt(*v)
	return res
}

func (ec *executionContext) unmarshalOInt2int64(ctx context.Context, v interface{}) (*int64, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt64(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2int64(ctx context.Context, sel ast.SelectionSet, v *int64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalInt64(*v)
	return res
}

func (ec *executionContext) marshalOKloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubRepository(ctx context.Context, sel ast.SelectionSet, v *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubRepository) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository(ctx, sel, v)
}

func (ec *executionContext) marshalOKloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubUserAccount(ctx context.Context, sel ast.SelectionSet, v *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubUserAccount) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount(ctx, sel, v)
}

func (ec *executionContext) unmarshalOMap2map(ctx context.Context, v interface{}) (map[string]interface{}, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalMap(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOMap2map(ctx context.Context, sel ast.SelectionSet, v map[string]interface{}) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalMap(v)
	return res
}

func (ec *executionContext) unmarshalOMatchFilterIn2kloudliteiopkgreposMatchFilter(ctx context.Context, v interface{}) (*repos.MatchFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputMatchFilterIn(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOPaginationIn2kloudliteiopkgtypesPagination(ctx context.Context, v interface{}) (*types.Pagination, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputPaginationIn(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalORepository2kloudliteioappscontainerregistryinternaldomainentitiesRepository(ctx context.Context, sel ast.SelectionSet, v *entities.Repository) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Repository(ctx, sel, v)
}

func (ec *executionContext) marshalORepositoryPaginatedRecords2kloudliteioappscontainerregistryinternalappgraphmodelRepositoryPaginatedRecords(ctx context.Context, sel ast.SelectionSet, v *model.RepositoryPaginatedRecords) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._RepositoryPaginatedRecords(ctx, sel, v)
}

func (ec *executionContext) unmarshalOSearchBuilds2kloudliteioappscontainerregistryinternalappgraphmodelSearchBuilds(ctx context.Context, v interface{}) (*model.SearchBuilds, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputSearchBuilds(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOSearchCreds2kloudliteioappscontainerregistryinternalappgraphmodelSearchCreds(ctx context.Context, v interface{}) (*model.SearchCreds, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputSearchCreds(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOSearchRepos2kloudliteioappscontainerregistryinternalappgraphmodelSearchRepos(ctx context.Context, v interface{}) (*model.SearchRepos, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputSearchRepos(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	return res
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) marshalOTagPaginatedRecords2kloudliteioappscontainerregistryinternalappgraphmodelTagPaginatedRecords(ctx context.Context, sel ast.SelectionSet, v *model.TagPaginatedRecords) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TagPaginatedRecords(ctx, sel, v)
}

func (ec *executionContext) marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
