// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"strconv"
	"sync"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/99designs/gqlgen/plugin/federation/fedruntime"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
	"kloudlite.io/apps/container-registry/internal/app/graph/model"
	"kloudlite.io/apps/container-registry/internal/domain"
	"kloudlite.io/apps/container-registry/internal/domain/entities"
	"kloudlite.io/pkg/repos"
	"kloudlite.io/pkg/types"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Build() BuildResolver
	BuildCacheKey() BuildCacheKeyResolver
	Credential() CredentialResolver
	Digest() DigestResolver
	GithubInstallation() GithubInstallationResolver
	GithubListRepository() GithubListRepositoryResolver
	GithubSearchRepository() GithubSearchRepositoryResolver
	GitlabProject() GitlabProjectResolver
	Mutation() MutationResolver
	Query() QueryResolver
	Repository() RepositoryResolver
	BuildCacheKeyIn() BuildCacheKeyInResolver
	BuildIn() BuildInResolver
	CredentialIn() CredentialInResolver
}

type DirectiveRoot struct {
	HasAccount            func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	IsLoggedInAndVerified func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
}

type ComplexityRoot struct {
	Build struct {
		AccountName       func(childComplexity int) int
		BuildCacheId      func(childComplexity int) int
		BuildData         func(childComplexity int) int
		CreatedBy         func(childComplexity int) int
		CreationTime      func(childComplexity int) int
		CredUser          func(childComplexity int) int
		ErrorMessages     func(childComplexity int) int
		ID                func(childComplexity int) int
		LastUpdatedBy     func(childComplexity int) int
		MarkedForDeletion func(childComplexity int) int
		Name              func(childComplexity int) int
		RecordVersion     func(childComplexity int) int
		Repository        func(childComplexity int) int
		Source            func(childComplexity int) int
		Status            func(childComplexity int) int
		Tags              func(childComplexity int) int
		UpdateTime        func(childComplexity int) int
	}

	BuildCacheKey struct {
		AccountName       func(childComplexity int) int
		CreatedBy         func(childComplexity int) int
		CreationTime      func(childComplexity int) int
		DisplayName       func(childComplexity int) int
		ID                func(childComplexity int) int
		LastUpdatedBy     func(childComplexity int) int
		MarkedForDeletion func(childComplexity int) int
		Name              func(childComplexity int) int
		RecordVersion     func(childComplexity int) int
		UpdateTime        func(childComplexity int) int
		VolumeSizeInGb    func(childComplexity int) int
	}

	BuildCacheKeyEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	BuildCacheKeyPaginatedRecords struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	BuildEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	BuildPaginatedRecords struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	CRCheckNameAvailabilityOutput struct {
		Result         func(childComplexity int) int
		SuggestedNames func(childComplexity int) int
	}

	Credential struct {
		Access            func(childComplexity int) int
		AccountName       func(childComplexity int) int
		CreatedBy         func(childComplexity int) int
		CreationTime      func(childComplexity int) int
		Expiration        func(childComplexity int) int
		ID                func(childComplexity int) int
		LastUpdatedBy     func(childComplexity int) int
		MarkedForDeletion func(childComplexity int) int
		Name              func(childComplexity int) int
		RecordVersion     func(childComplexity int) int
		UpdateTime        func(childComplexity int) int
		UserName          func(childComplexity int) int
	}

	CredentialEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	CredentialPaginatedRecords struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	CursorPagination struct {
		After         func(childComplexity int) int
		Before        func(childComplexity int) int
		First         func(childComplexity int) int
		Last          func(childComplexity int) int
		OrderBy       func(childComplexity int) int
		SortDirection func(childComplexity int) int
	}

	Digest struct {
		AccountName       func(childComplexity int) int
		Actor             func(childComplexity int) int
		CreationTime      func(childComplexity int) int
		Deleting          func(childComplexity int) int
		Digest            func(childComplexity int) int
		ID                func(childComplexity int) int
		Length            func(childComplexity int) int
		MarkedForDeletion func(childComplexity int) int
		MediaType         func(childComplexity int) int
		RecordVersion     func(childComplexity int) int
		Repository        func(childComplexity int) int
		Size              func(childComplexity int) int
		Tags              func(childComplexity int) int
		URL               func(childComplexity int) int
		UpdateTime        func(childComplexity int) int
	}

	DigestEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	DigestPaginatedRecords struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	GitBranch struct {
		Name      func(childComplexity int) int
		Protected func(childComplexity int) int
	}

	GithubBranch struct {
		Name      func(childComplexity int) int
		Protected func(childComplexity int) int
	}

	GithubInstallation struct {
		Account         func(childComplexity int) int
		AppID           func(childComplexity int) int
		ID              func(childComplexity int) int
		NodeID          func(childComplexity int) int
		RepositoriesURL func(childComplexity int) int
		TargetID        func(childComplexity int) int
		TargetType      func(childComplexity int) int
	}

	GithubListRepository struct {
		Repositories func(childComplexity int) int
		TotalCount   func(childComplexity int) int
	}

	GithubSearchRepository struct {
		IncompleteResults func(childComplexity int) int
		Repositories      func(childComplexity int) int
		Total             func(childComplexity int) int
	}

	GitlabBranch struct {
		CanPush            func(childComplexity int) int
		Default            func(childComplexity int) int
		DevelopersCanMerge func(childComplexity int) int
		DevelopersCanPush  func(childComplexity int) int
		Merged             func(childComplexity int) int
		Name               func(childComplexity int) int
		Protected          func(childComplexity int) int
		WebURL             func(childComplexity int) int
	}

	GitlabGroup struct {
		AvatarUrl func(childComplexity int) int
		FullName  func(childComplexity int) int
		Id        func(childComplexity int) int
	}

	GitlabProject struct {
		Archived          func(childComplexity int) int
		AvatarURL         func(childComplexity int) int
		CreatedAt         func(childComplexity int) int
		CreatorID         func(childComplexity int) int
		DefaultBranch     func(childComplexity int) int
		Description       func(childComplexity int) int
		EmptyRepo         func(childComplexity int) int
		HTTPURLToRepo     func(childComplexity int) int
		ID                func(childComplexity int) int
		LastActivityAt    func(childComplexity int) int
		Name              func(childComplexity int) int
		NameWithNamespace func(childComplexity int) int
		Path              func(childComplexity int) int
		PathWithNamespace func(childComplexity int) int
		Public            func(childComplexity int) int
		SSHURLToRepo      func(childComplexity int) int
		TagList           func(childComplexity int) int
		Topics            func(childComplexity int) int
		WebURL            func(childComplexity int) int
	}

	Kloudlite_io__apps__container___registry__internal__domain__entities_BuildOptions struct {
		BuildArgs         func(childComplexity int) int
		BuildContexts     func(childComplexity int) int
		ContextDir        func(childComplexity int) int
		DockerfileContent func(childComplexity int) int
		DockerfilePath    func(childComplexity int) int
		TargetPlatforms   func(childComplexity int) int
	}

	Kloudlite_io__apps__container___registry__internal__domain__entities_Expiration struct {
		Unit  func(childComplexity int) int
		Value func(childComplexity int) int
	}

	Kloudlite_io__apps__container___registry__internal__domain__entities_GitSource struct {
		Branch     func(childComplexity int) int
		Provider   func(childComplexity int) int
		Repository func(childComplexity int) int
		WebhookID  func(childComplexity int) int
	}

	Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository struct {
		Archived          func(childComplexity int) int
		CloneURL          func(childComplexity int) int
		CreatedAt         func(childComplexity int) int
		DefaultBranch     func(childComplexity int) int
		Description       func(childComplexity int) int
		Disabled          func(childComplexity int) int
		FullName          func(childComplexity int) int
		GitURL            func(childComplexity int) int
		GitignoreTemplate func(childComplexity int) int
		HTMLURL           func(childComplexity int) int
		ID                func(childComplexity int) int
		Language          func(childComplexity int) int
		MasterBranch      func(childComplexity int) int
		MirrorURL         func(childComplexity int) int
		Name              func(childComplexity int) int
		NodeID            func(childComplexity int) int
		Permissions       func(childComplexity int) int
		Private           func(childComplexity int) int
		PushedAt          func(childComplexity int) int
		Size              func(childComplexity int) int
		TeamID            func(childComplexity int) int
		URL               func(childComplexity int) int
		UpdatedAt         func(childComplexity int) int
		Visibility        func(childComplexity int) int
	}

	Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount struct {
		AvatarURL func(childComplexity int) int
		ID        func(childComplexity int) int
		Login     func(childComplexity int) int
		NodeID    func(childComplexity int) int
		Type      func(childComplexity int) int
	}

	Kloudlite_io__common_CreatedOrUpdatedBy struct {
		UserEmail func(childComplexity int) int
		UserID    func(childComplexity int) int
		UserName  func(childComplexity int) int
	}

	MatchFilter struct {
		Array     func(childComplexity int) int
		Exact     func(childComplexity int) int
		MatchType func(childComplexity int) int
		Regex     func(childComplexity int) int
	}

	Mutation struct {
		CrAddBuild                 func(childComplexity int, build entities.Build) int
		CrAddBuildCacheKey         func(childComplexity int, buildCacheKey entities.BuildCacheKey) int
		CrCreateCred               func(childComplexity int, credential entities.Credential) int
		CrCreateRepo               func(childComplexity int, repository entities.Repository) int
		CrDeleteBuild              func(childComplexity int, id repos.ID) int
		CrDeleteBuildCacheKey      func(childComplexity int, id repos.ID) int
		CrDeleteCred               func(childComplexity int, username string) int
		CrDeleteDigest             func(childComplexity int, repoName string, digest string) int
		CrDeleteRepo               func(childComplexity int, name string) int
		CrListBuildsByBuildCacheID func(childComplexity int, buildCacheKeyID repos.ID, pagination *repos.CursorPagination) int
		CrTriggerBuild             func(childComplexity int, id repos.ID) int
		CrUpdateBuild              func(childComplexity int, id repos.ID, build entities.Build) int
		CrUpdateBuildCacheKey      func(childComplexity int, id repos.ID, buildCacheKey entities.BuildCacheKey) int
	}

	PageInfo struct {
		EndCursor       func(childComplexity int) int
		HasNextPage     func(childComplexity int) int
		HasPreviousPage func(childComplexity int) int
		StartCursor     func(childComplexity int) int
	}

	Pagination struct {
		Page    func(childComplexity int) int
		PerPage func(childComplexity int) int
	}

	Query struct {
		CrCheckUserNameAvailability func(childComplexity int, name string) int
		CrGetBuild                  func(childComplexity int, id repos.ID) int
		CrGetCredToken              func(childComplexity int, username string) int
		CrListBuildCacheKeys        func(childComplexity int, pq *repos.CursorPagination, search *model.SearchBuildCacheKeys) int
		CrListBuilds                func(childComplexity int, repoName string, search *model.SearchBuilds, pagination *repos.CursorPagination) int
		CrListCreds                 func(childComplexity int, search *model.SearchCreds, pagination *repos.CursorPagination) int
		CrListDigests               func(childComplexity int, repoName string, search *model.SearchRepos, pagination *repos.CursorPagination) int
		CrListGithubBranches        func(childComplexity int, repoURL string, pagination *types.Pagination) int
		CrListGithubInstallations   func(childComplexity int, pagination *types.Pagination) int
		CrListGithubRepos           func(childComplexity int, installationID int, pagination *types.Pagination) int
		CrListGitlabBranches        func(childComplexity int, repoID string, query *string, pagination *types.Pagination) int
		CrListGitlabGroups          func(childComplexity int, query *string, pagination *types.Pagination) int
		CrListGitlabRepositories    func(childComplexity int, groupID string, query *string, pagination *types.Pagination) int
		CrListRepos                 func(childComplexity int, search *model.SearchRepos, pagination *repos.CursorPagination) int
		CrSearchGithubRepos         func(childComplexity int, organization string, search string, pagination *types.Pagination) int
		__resolve__service          func(childComplexity int) int
	}

	Repository struct {
		AccountName       func(childComplexity int) int
		CreatedBy         func(childComplexity int) int
		CreationTime      func(childComplexity int) int
		ID                func(childComplexity int) int
		LastUpdatedBy     func(childComplexity int) int
		MarkedForDeletion func(childComplexity int) int
		Name              func(childComplexity int) int
		RecordVersion     func(childComplexity int) int
		UpdateTime        func(childComplexity int) int
	}

	RepositoryEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	RepositoryPaginatedRecords struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	_Service struct {
		SDL func(childComplexity int) int
	}
}

type BuildResolver interface {
	BuildData(ctx context.Context, obj *entities.Build) (*model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesBuildOptions, error)
	CreatedBy(ctx context.Context, obj *entities.Build) (*model.KloudliteIoCommonCreatedOrUpdatedBy, error)
	CreationTime(ctx context.Context, obj *entities.Build) (string, error)
	CredUser(ctx context.Context, obj *entities.Build) (*model.KloudliteIoCommonCreatedOrUpdatedBy, error)
	ErrorMessages(ctx context.Context, obj *entities.Build) (map[string]interface{}, error)
	ID(ctx context.Context, obj *entities.Build) (string, error)
	LastUpdatedBy(ctx context.Context, obj *entities.Build) (*model.KloudliteIoCommonCreatedOrUpdatedBy, error)

	Source(ctx context.Context, obj *entities.Build) (*model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGitSource, error)
	Status(ctx context.Context, obj *entities.Build) (model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesBuildStatus, error)

	UpdateTime(ctx context.Context, obj *entities.Build) (string, error)
}
type BuildCacheKeyResolver interface {
	CreatedBy(ctx context.Context, obj *entities.BuildCacheKey) (*model.KloudliteIoCommonCreatedOrUpdatedBy, error)
	CreationTime(ctx context.Context, obj *entities.BuildCacheKey) (string, error)

	ID(ctx context.Context, obj *entities.BuildCacheKey) (string, error)
	LastUpdatedBy(ctx context.Context, obj *entities.BuildCacheKey) (*model.KloudliteIoCommonCreatedOrUpdatedBy, error)

	UpdateTime(ctx context.Context, obj *entities.BuildCacheKey) (string, error)
	VolumeSizeInGb(ctx context.Context, obj *entities.BuildCacheKey) (float64, error)
}
type CredentialResolver interface {
	Access(ctx context.Context, obj *entities.Credential) (model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesRepoAccess, error)

	CreatedBy(ctx context.Context, obj *entities.Credential) (*model.KloudliteIoCommonCreatedOrUpdatedBy, error)
	CreationTime(ctx context.Context, obj *entities.Credential) (string, error)
	Expiration(ctx context.Context, obj *entities.Credential) (*model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesExpiration, error)
	ID(ctx context.Context, obj *entities.Credential) (string, error)
	LastUpdatedBy(ctx context.Context, obj *entities.Credential) (*model.KloudliteIoCommonCreatedOrUpdatedBy, error)

	UpdateTime(ctx context.Context, obj *entities.Credential) (string, error)
}
type DigestResolver interface {
	CreationTime(ctx context.Context, obj *entities.Digest) (string, error)

	ID(ctx context.Context, obj *entities.Digest) (string, error)

	UpdateTime(ctx context.Context, obj *entities.Digest) (string, error)
}
type GithubInstallationResolver interface {
	Account(ctx context.Context, obj *entities.GithubInstallation) (*model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubUserAccount, error)
}
type GithubListRepositoryResolver interface {
	Repositories(ctx context.Context, obj *entities.GithubListRepository) ([]*model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubRepository, error)
}
type GithubSearchRepositoryResolver interface {
	Repositories(ctx context.Context, obj *entities.GithubSearchRepository) ([]*model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubRepository, error)
}
type GitlabProjectResolver interface {
	CreatedAt(ctx context.Context, obj *entities.GitlabProject) (*string, error)

	LastActivityAt(ctx context.Context, obj *entities.GitlabProject) (*string, error)
}
type MutationResolver interface {
	CrCreateRepo(ctx context.Context, repository entities.Repository) (*entities.Repository, error)
	CrCreateCred(ctx context.Context, credential entities.Credential) (*entities.Credential, error)
	CrDeleteRepo(ctx context.Context, name string) (bool, error)
	CrDeleteCred(ctx context.Context, username string) (bool, error)
	CrDeleteDigest(ctx context.Context, repoName string, digest string) (bool, error)
	CrAddBuild(ctx context.Context, build entities.Build) (*entities.Build, error)
	CrUpdateBuild(ctx context.Context, id repos.ID, build entities.Build) (*entities.Build, error)
	CrDeleteBuild(ctx context.Context, id repos.ID) (bool, error)
	CrTriggerBuild(ctx context.Context, id repos.ID) (bool, error)
	CrAddBuildCacheKey(ctx context.Context, buildCacheKey entities.BuildCacheKey) (*entities.BuildCacheKey, error)
	CrDeleteBuildCacheKey(ctx context.Context, id repos.ID) (bool, error)
	CrUpdateBuildCacheKey(ctx context.Context, id repos.ID, buildCacheKey entities.BuildCacheKey) (*entities.BuildCacheKey, error)
	CrListBuildsByBuildCacheID(ctx context.Context, buildCacheKeyID repos.ID, pagination *repos.CursorPagination) (*model.BuildPaginatedRecords, error)
}
type QueryResolver interface {
	CrListRepos(ctx context.Context, search *model.SearchRepos, pagination *repos.CursorPagination) (*model.RepositoryPaginatedRecords, error)
	CrListCreds(ctx context.Context, search *model.SearchCreds, pagination *repos.CursorPagination) (*model.CredentialPaginatedRecords, error)
	CrListDigests(ctx context.Context, repoName string, search *model.SearchRepos, pagination *repos.CursorPagination) (*model.DigestPaginatedRecords, error)
	CrGetCredToken(ctx context.Context, username string) (string, error)
	CrCheckUserNameAvailability(ctx context.Context, name string) (*domain.CheckNameAvailabilityOutput, error)
	CrGetBuild(ctx context.Context, id repos.ID) (*entities.Build, error)
	CrListBuilds(ctx context.Context, repoName string, search *model.SearchBuilds, pagination *repos.CursorPagination) (*model.BuildPaginatedRecords, error)
	CrListGithubInstallations(ctx context.Context, pagination *types.Pagination) ([]*entities.GithubInstallation, error)
	CrListGithubRepos(ctx context.Context, installationID int, pagination *types.Pagination) (*entities.GithubListRepository, error)
	CrSearchGithubRepos(ctx context.Context, organization string, search string, pagination *types.Pagination) (*entities.GithubSearchRepository, error)
	CrListGithubBranches(ctx context.Context, repoURL string, pagination *types.Pagination) ([]*entities.GitBranch, error)
	CrListGitlabGroups(ctx context.Context, query *string, pagination *types.Pagination) ([]*entities.GitlabGroup, error)
	CrListGitlabRepositories(ctx context.Context, groupID string, query *string, pagination *types.Pagination) ([]*entities.GitlabProject, error)
	CrListGitlabBranches(ctx context.Context, repoID string, query *string, pagination *types.Pagination) ([]*entities.GitBranch, error)
	CrListBuildCacheKeys(ctx context.Context, pq *repos.CursorPagination, search *model.SearchBuildCacheKeys) (*model.BuildCacheKeyPaginatedRecords, error)
}
type RepositoryResolver interface {
	CreatedBy(ctx context.Context, obj *entities.Repository) (*model.KloudliteIoCommonCreatedOrUpdatedBy, error)
	CreationTime(ctx context.Context, obj *entities.Repository) (string, error)
	ID(ctx context.Context, obj *entities.Repository) (string, error)
	LastUpdatedBy(ctx context.Context, obj *entities.Repository) (*model.KloudliteIoCommonCreatedOrUpdatedBy, error)

	UpdateTime(ctx context.Context, obj *entities.Repository) (string, error)
}

type BuildCacheKeyInResolver interface {
	VolumeSizeInGb(ctx context.Context, obj *entities.BuildCacheKey, data float64) error
}
type BuildInResolver interface {
	BuildData(ctx context.Context, obj *entities.Build, data *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesBuildOptionsIn) error

	Source(ctx context.Context, obj *entities.Build, data *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGitSourceIn) error
}
type CredentialInResolver interface {
	Access(ctx context.Context, obj *entities.Credential, data model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesRepoAccess) error
	Expiration(ctx context.Context, obj *entities.Credential, data *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesExpirationIn) error
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec
	switch typeName + "." + field {

	case "Build.accountName":
		if e.complexity.Build.AccountName == nil {
			break
		}

		return e.complexity.Build.AccountName(childComplexity), true

	case "Build.buildCacheId":
		if e.complexity.Build.BuildCacheId == nil {
			break
		}

		return e.complexity.Build.BuildCacheId(childComplexity), true

	case "Build.buildData":
		if e.complexity.Build.BuildData == nil {
			break
		}

		return e.complexity.Build.BuildData(childComplexity), true

	case "Build.createdBy":
		if e.complexity.Build.CreatedBy == nil {
			break
		}

		return e.complexity.Build.CreatedBy(childComplexity), true

	case "Build.creationTime":
		if e.complexity.Build.CreationTime == nil {
			break
		}

		return e.complexity.Build.CreationTime(childComplexity), true

	case "Build.credUser":
		if e.complexity.Build.CredUser == nil {
			break
		}

		return e.complexity.Build.CredUser(childComplexity), true

	case "Build.errorMessages":
		if e.complexity.Build.ErrorMessages == nil {
			break
		}

		return e.complexity.Build.ErrorMessages(childComplexity), true

	case "Build.id":
		if e.complexity.Build.ID == nil {
			break
		}

		return e.complexity.Build.ID(childComplexity), true

	case "Build.lastUpdatedBy":
		if e.complexity.Build.LastUpdatedBy == nil {
			break
		}

		return e.complexity.Build.LastUpdatedBy(childComplexity), true

	case "Build.markedForDeletion":
		if e.complexity.Build.MarkedForDeletion == nil {
			break
		}

		return e.complexity.Build.MarkedForDeletion(childComplexity), true

	case "Build.name":
		if e.complexity.Build.Name == nil {
			break
		}

		return e.complexity.Build.Name(childComplexity), true

	case "Build.recordVersion":
		if e.complexity.Build.RecordVersion == nil {
			break
		}

		return e.complexity.Build.RecordVersion(childComplexity), true

	case "Build.repository":
		if e.complexity.Build.Repository == nil {
			break
		}

		return e.complexity.Build.Repository(childComplexity), true

	case "Build.source":
		if e.complexity.Build.Source == nil {
			break
		}

		return e.complexity.Build.Source(childComplexity), true

	case "Build.status":
		if e.complexity.Build.Status == nil {
			break
		}

		return e.complexity.Build.Status(childComplexity), true

	case "Build.tags":
		if e.complexity.Build.Tags == nil {
			break
		}

		return e.complexity.Build.Tags(childComplexity), true

	case "Build.updateTime":
		if e.complexity.Build.UpdateTime == nil {
			break
		}

		return e.complexity.Build.UpdateTime(childComplexity), true

	case "BuildCacheKey.accountName":
		if e.complexity.BuildCacheKey.AccountName == nil {
			break
		}

		return e.complexity.BuildCacheKey.AccountName(childComplexity), true

	case "BuildCacheKey.createdBy":
		if e.complexity.BuildCacheKey.CreatedBy == nil {
			break
		}

		return e.complexity.BuildCacheKey.CreatedBy(childComplexity), true

	case "BuildCacheKey.creationTime":
		if e.complexity.BuildCacheKey.CreationTime == nil {
			break
		}

		return e.complexity.BuildCacheKey.CreationTime(childComplexity), true

	case "BuildCacheKey.displayName":
		if e.complexity.BuildCacheKey.DisplayName == nil {
			break
		}

		return e.complexity.BuildCacheKey.DisplayName(childComplexity), true

	case "BuildCacheKey.id":
		if e.complexity.BuildCacheKey.ID == nil {
			break
		}

		return e.complexity.BuildCacheKey.ID(childComplexity), true

	case "BuildCacheKey.lastUpdatedBy":
		if e.complexity.BuildCacheKey.LastUpdatedBy == nil {
			break
		}

		return e.complexity.BuildCacheKey.LastUpdatedBy(childComplexity), true

	case "BuildCacheKey.markedForDeletion":
		if e.complexity.BuildCacheKey.MarkedForDeletion == nil {
			break
		}

		return e.complexity.BuildCacheKey.MarkedForDeletion(childComplexity), true

	case "BuildCacheKey.name":
		if e.complexity.BuildCacheKey.Name == nil {
			break
		}

		return e.complexity.BuildCacheKey.Name(childComplexity), true

	case "BuildCacheKey.recordVersion":
		if e.complexity.BuildCacheKey.RecordVersion == nil {
			break
		}

		return e.complexity.BuildCacheKey.RecordVersion(childComplexity), true

	case "BuildCacheKey.updateTime":
		if e.complexity.BuildCacheKey.UpdateTime == nil {
			break
		}

		return e.complexity.BuildCacheKey.UpdateTime(childComplexity), true

	case "BuildCacheKey.volumeSizeInGB":
		if e.complexity.BuildCacheKey.VolumeSizeInGb == nil {
			break
		}

		return e.complexity.BuildCacheKey.VolumeSizeInGb(childComplexity), true

	case "BuildCacheKeyEdge.cursor":
		if e.complexity.BuildCacheKeyEdge.Cursor == nil {
			break
		}

		return e.complexity.BuildCacheKeyEdge.Cursor(childComplexity), true

	case "BuildCacheKeyEdge.node":
		if e.complexity.BuildCacheKeyEdge.Node == nil {
			break
		}

		return e.complexity.BuildCacheKeyEdge.Node(childComplexity), true

	case "BuildCacheKeyPaginatedRecords.edges":
		if e.complexity.BuildCacheKeyPaginatedRecords.Edges == nil {
			break
		}

		return e.complexity.BuildCacheKeyPaginatedRecords.Edges(childComplexity), true

	case "BuildCacheKeyPaginatedRecords.pageInfo":
		if e.complexity.BuildCacheKeyPaginatedRecords.PageInfo == nil {
			break
		}

		return e.complexity.BuildCacheKeyPaginatedRecords.PageInfo(childComplexity), true

	case "BuildCacheKeyPaginatedRecords.totalCount":
		if e.complexity.BuildCacheKeyPaginatedRecords.TotalCount == nil {
			break
		}

		return e.complexity.BuildCacheKeyPaginatedRecords.TotalCount(childComplexity), true

	case "BuildEdge.cursor":
		if e.complexity.BuildEdge.Cursor == nil {
			break
		}

		return e.complexity.BuildEdge.Cursor(childComplexity), true

	case "BuildEdge.node":
		if e.complexity.BuildEdge.Node == nil {
			break
		}

		return e.complexity.BuildEdge.Node(childComplexity), true

	case "BuildPaginatedRecords.edges":
		if e.complexity.BuildPaginatedRecords.Edges == nil {
			break
		}

		return e.complexity.BuildPaginatedRecords.Edges(childComplexity), true

	case "BuildPaginatedRecords.pageInfo":
		if e.complexity.BuildPaginatedRecords.PageInfo == nil {
			break
		}

		return e.complexity.BuildPaginatedRecords.PageInfo(childComplexity), true

	case "BuildPaginatedRecords.totalCount":
		if e.complexity.BuildPaginatedRecords.TotalCount == nil {
			break
		}

		return e.complexity.BuildPaginatedRecords.TotalCount(childComplexity), true

	case "CRCheckNameAvailabilityOutput.result":
		if e.complexity.CRCheckNameAvailabilityOutput.Result == nil {
			break
		}

		return e.complexity.CRCheckNameAvailabilityOutput.Result(childComplexity), true

	case "CRCheckNameAvailabilityOutput.suggestedNames":
		if e.complexity.CRCheckNameAvailabilityOutput.SuggestedNames == nil {
			break
		}

		return e.complexity.CRCheckNameAvailabilityOutput.SuggestedNames(childComplexity), true

	case "Credential.access":
		if e.complexity.Credential.Access == nil {
			break
		}

		return e.complexity.Credential.Access(childComplexity), true

	case "Credential.accountName":
		if e.complexity.Credential.AccountName == nil {
			break
		}

		return e.complexity.Credential.AccountName(childComplexity), true

	case "Credential.createdBy":
		if e.complexity.Credential.CreatedBy == nil {
			break
		}

		return e.complexity.Credential.CreatedBy(childComplexity), true

	case "Credential.creationTime":
		if e.complexity.Credential.CreationTime == nil {
			break
		}

		return e.complexity.Credential.CreationTime(childComplexity), true

	case "Credential.expiration":
		if e.complexity.Credential.Expiration == nil {
			break
		}

		return e.complexity.Credential.Expiration(childComplexity), true

	case "Credential.id":
		if e.complexity.Credential.ID == nil {
			break
		}

		return e.complexity.Credential.ID(childComplexity), true

	case "Credential.lastUpdatedBy":
		if e.complexity.Credential.LastUpdatedBy == nil {
			break
		}

		return e.complexity.Credential.LastUpdatedBy(childComplexity), true

	case "Credential.markedForDeletion":
		if e.complexity.Credential.MarkedForDeletion == nil {
			break
		}

		return e.complexity.Credential.MarkedForDeletion(childComplexity), true

	case "Credential.name":
		if e.complexity.Credential.Name == nil {
			break
		}

		return e.complexity.Credential.Name(childComplexity), true

	case "Credential.recordVersion":
		if e.complexity.Credential.RecordVersion == nil {
			break
		}

		return e.complexity.Credential.RecordVersion(childComplexity), true

	case "Credential.updateTime":
		if e.complexity.Credential.UpdateTime == nil {
			break
		}

		return e.complexity.Credential.UpdateTime(childComplexity), true

	case "Credential.username":
		if e.complexity.Credential.UserName == nil {
			break
		}

		return e.complexity.Credential.UserName(childComplexity), true

	case "CredentialEdge.cursor":
		if e.complexity.CredentialEdge.Cursor == nil {
			break
		}

		return e.complexity.CredentialEdge.Cursor(childComplexity), true

	case "CredentialEdge.node":
		if e.complexity.CredentialEdge.Node == nil {
			break
		}

		return e.complexity.CredentialEdge.Node(childComplexity), true

	case "CredentialPaginatedRecords.edges":
		if e.complexity.CredentialPaginatedRecords.Edges == nil {
			break
		}

		return e.complexity.CredentialPaginatedRecords.Edges(childComplexity), true

	case "CredentialPaginatedRecords.pageInfo":
		if e.complexity.CredentialPaginatedRecords.PageInfo == nil {
			break
		}

		return e.complexity.CredentialPaginatedRecords.PageInfo(childComplexity), true

	case "CredentialPaginatedRecords.totalCount":
		if e.complexity.CredentialPaginatedRecords.TotalCount == nil {
			break
		}

		return e.complexity.CredentialPaginatedRecords.TotalCount(childComplexity), true

	case "CursorPagination.after":
		if e.complexity.CursorPagination.After == nil {
			break
		}

		return e.complexity.CursorPagination.After(childComplexity), true

	case "CursorPagination.before":
		if e.complexity.CursorPagination.Before == nil {
			break
		}

		return e.complexity.CursorPagination.Before(childComplexity), true

	case "CursorPagination.first":
		if e.complexity.CursorPagination.First == nil {
			break
		}

		return e.complexity.CursorPagination.First(childComplexity), true

	case "CursorPagination.last":
		if e.complexity.CursorPagination.Last == nil {
			break
		}

		return e.complexity.CursorPagination.Last(childComplexity), true

	case "CursorPagination.orderBy":
		if e.complexity.CursorPagination.OrderBy == nil {
			break
		}

		return e.complexity.CursorPagination.OrderBy(childComplexity), true

	case "CursorPagination.sortDirection":
		if e.complexity.CursorPagination.SortDirection == nil {
			break
		}

		return e.complexity.CursorPagination.SortDirection(childComplexity), true

	case "Digest.accountName":
		if e.complexity.Digest.AccountName == nil {
			break
		}

		return e.complexity.Digest.AccountName(childComplexity), true

	case "Digest.actor":
		if e.complexity.Digest.Actor == nil {
			break
		}

		return e.complexity.Digest.Actor(childComplexity), true

	case "Digest.creationTime":
		if e.complexity.Digest.CreationTime == nil {
			break
		}

		return e.complexity.Digest.CreationTime(childComplexity), true

	case "Digest.deleting":
		if e.complexity.Digest.Deleting == nil {
			break
		}

		return e.complexity.Digest.Deleting(childComplexity), true

	case "Digest.digest":
		if e.complexity.Digest.Digest == nil {
			break
		}

		return e.complexity.Digest.Digest(childComplexity), true

	case "Digest.id":
		if e.complexity.Digest.ID == nil {
			break
		}

		return e.complexity.Digest.ID(childComplexity), true

	case "Digest.length":
		if e.complexity.Digest.Length == nil {
			break
		}

		return e.complexity.Digest.Length(childComplexity), true

	case "Digest.markedForDeletion":
		if e.complexity.Digest.MarkedForDeletion == nil {
			break
		}

		return e.complexity.Digest.MarkedForDeletion(childComplexity), true

	case "Digest.mediaType":
		if e.complexity.Digest.MediaType == nil {
			break
		}

		return e.complexity.Digest.MediaType(childComplexity), true

	case "Digest.recordVersion":
		if e.complexity.Digest.RecordVersion == nil {
			break
		}

		return e.complexity.Digest.RecordVersion(childComplexity), true

	case "Digest.repository":
		if e.complexity.Digest.Repository == nil {
			break
		}

		return e.complexity.Digest.Repository(childComplexity), true

	case "Digest.size":
		if e.complexity.Digest.Size == nil {
			break
		}

		return e.complexity.Digest.Size(childComplexity), true

	case "Digest.tags":
		if e.complexity.Digest.Tags == nil {
			break
		}

		return e.complexity.Digest.Tags(childComplexity), true

	case "Digest.url":
		if e.complexity.Digest.URL == nil {
			break
		}

		return e.complexity.Digest.URL(childComplexity), true

	case "Digest.updateTime":
		if e.complexity.Digest.UpdateTime == nil {
			break
		}

		return e.complexity.Digest.UpdateTime(childComplexity), true

	case "DigestEdge.cursor":
		if e.complexity.DigestEdge.Cursor == nil {
			break
		}

		return e.complexity.DigestEdge.Cursor(childComplexity), true

	case "DigestEdge.node":
		if e.complexity.DigestEdge.Node == nil {
			break
		}

		return e.complexity.DigestEdge.Node(childComplexity), true

	case "DigestPaginatedRecords.edges":
		if e.complexity.DigestPaginatedRecords.Edges == nil {
			break
		}

		return e.complexity.DigestPaginatedRecords.Edges(childComplexity), true

	case "DigestPaginatedRecords.pageInfo":
		if e.complexity.DigestPaginatedRecords.PageInfo == nil {
			break
		}

		return e.complexity.DigestPaginatedRecords.PageInfo(childComplexity), true

	case "DigestPaginatedRecords.totalCount":
		if e.complexity.DigestPaginatedRecords.TotalCount == nil {
			break
		}

		return e.complexity.DigestPaginatedRecords.TotalCount(childComplexity), true

	case "GitBranch.name":
		if e.complexity.GitBranch.Name == nil {
			break
		}

		return e.complexity.GitBranch.Name(childComplexity), true

	case "GitBranch.protected":
		if e.complexity.GitBranch.Protected == nil {
			break
		}

		return e.complexity.GitBranch.Protected(childComplexity), true

	case "GithubBranch.name":
		if e.complexity.GithubBranch.Name == nil {
			break
		}

		return e.complexity.GithubBranch.Name(childComplexity), true

	case "GithubBranch.protected":
		if e.complexity.GithubBranch.Protected == nil {
			break
		}

		return e.complexity.GithubBranch.Protected(childComplexity), true

	case "GithubInstallation.account":
		if e.complexity.GithubInstallation.Account == nil {
			break
		}

		return e.complexity.GithubInstallation.Account(childComplexity), true

	case "GithubInstallation.appId":
		if e.complexity.GithubInstallation.AppID == nil {
			break
		}

		return e.complexity.GithubInstallation.AppID(childComplexity), true

	case "GithubInstallation.id":
		if e.complexity.GithubInstallation.ID == nil {
			break
		}

		return e.complexity.GithubInstallation.ID(childComplexity), true

	case "GithubInstallation.nodeId":
		if e.complexity.GithubInstallation.NodeID == nil {
			break
		}

		return e.complexity.GithubInstallation.NodeID(childComplexity), true

	case "GithubInstallation.repositoriesUrl":
		if e.complexity.GithubInstallation.RepositoriesURL == nil {
			break
		}

		return e.complexity.GithubInstallation.RepositoriesURL(childComplexity), true

	case "GithubInstallation.targetId":
		if e.complexity.GithubInstallation.TargetID == nil {
			break
		}

		return e.complexity.GithubInstallation.TargetID(childComplexity), true

	case "GithubInstallation.targetType":
		if e.complexity.GithubInstallation.TargetType == nil {
			break
		}

		return e.complexity.GithubInstallation.TargetType(childComplexity), true

	case "GithubListRepository.repositories":
		if e.complexity.GithubListRepository.Repositories == nil {
			break
		}

		return e.complexity.GithubListRepository.Repositories(childComplexity), true

	case "GithubListRepository.totalCount":
		if e.complexity.GithubListRepository.TotalCount == nil {
			break
		}

		return e.complexity.GithubListRepository.TotalCount(childComplexity), true

	case "GithubSearchRepository.incompleteResults":
		if e.complexity.GithubSearchRepository.IncompleteResults == nil {
			break
		}

		return e.complexity.GithubSearchRepository.IncompleteResults(childComplexity), true

	case "GithubSearchRepository.repositories":
		if e.complexity.GithubSearchRepository.Repositories == nil {
			break
		}

		return e.complexity.GithubSearchRepository.Repositories(childComplexity), true

	case "GithubSearchRepository.total":
		if e.complexity.GithubSearchRepository.Total == nil {
			break
		}

		return e.complexity.GithubSearchRepository.Total(childComplexity), true

	case "GitlabBranch.canPush":
		if e.complexity.GitlabBranch.CanPush == nil {
			break
		}

		return e.complexity.GitlabBranch.CanPush(childComplexity), true

	case "GitlabBranch.default":
		if e.complexity.GitlabBranch.Default == nil {
			break
		}

		return e.complexity.GitlabBranch.Default(childComplexity), true

	case "GitlabBranch.developersCanMerge":
		if e.complexity.GitlabBranch.DevelopersCanMerge == nil {
			break
		}

		return e.complexity.GitlabBranch.DevelopersCanMerge(childComplexity), true

	case "GitlabBranch.developersCanPush":
		if e.complexity.GitlabBranch.DevelopersCanPush == nil {
			break
		}

		return e.complexity.GitlabBranch.DevelopersCanPush(childComplexity), true

	case "GitlabBranch.merged":
		if e.complexity.GitlabBranch.Merged == nil {
			break
		}

		return e.complexity.GitlabBranch.Merged(childComplexity), true

	case "GitlabBranch.name":
		if e.complexity.GitlabBranch.Name == nil {
			break
		}

		return e.complexity.GitlabBranch.Name(childComplexity), true

	case "GitlabBranch.protected":
		if e.complexity.GitlabBranch.Protected == nil {
			break
		}

		return e.complexity.GitlabBranch.Protected(childComplexity), true

	case "GitlabBranch.webUrl":
		if e.complexity.GitlabBranch.WebURL == nil {
			break
		}

		return e.complexity.GitlabBranch.WebURL(childComplexity), true

	case "GitlabGroup.avatarUrl":
		if e.complexity.GitlabGroup.AvatarUrl == nil {
			break
		}

		return e.complexity.GitlabGroup.AvatarUrl(childComplexity), true

	case "GitlabGroup.fullName":
		if e.complexity.GitlabGroup.FullName == nil {
			break
		}

		return e.complexity.GitlabGroup.FullName(childComplexity), true

	case "GitlabGroup.id":
		if e.complexity.GitlabGroup.Id == nil {
			break
		}

		return e.complexity.GitlabGroup.Id(childComplexity), true

	case "GitlabProject.archived":
		if e.complexity.GitlabProject.Archived == nil {
			break
		}

		return e.complexity.GitlabProject.Archived(childComplexity), true

	case "GitlabProject.avatarUrl":
		if e.complexity.GitlabProject.AvatarURL == nil {
			break
		}

		return e.complexity.GitlabProject.AvatarURL(childComplexity), true

	case "GitlabProject.createdAt":
		if e.complexity.GitlabProject.CreatedAt == nil {
			break
		}

		return e.complexity.GitlabProject.CreatedAt(childComplexity), true

	case "GitlabProject.creatorId":
		if e.complexity.GitlabProject.CreatorID == nil {
			break
		}

		return e.complexity.GitlabProject.CreatorID(childComplexity), true

	case "GitlabProject.defaultBranch":
		if e.complexity.GitlabProject.DefaultBranch == nil {
			break
		}

		return e.complexity.GitlabProject.DefaultBranch(childComplexity), true

	case "GitlabProject.description":
		if e.complexity.GitlabProject.Description == nil {
			break
		}

		return e.complexity.GitlabProject.Description(childComplexity), true

	case "GitlabProject.emptyRepo":
		if e.complexity.GitlabProject.EmptyRepo == nil {
			break
		}

		return e.complexity.GitlabProject.EmptyRepo(childComplexity), true

	case "GitlabProject.httpUrlToRepo":
		if e.complexity.GitlabProject.HTTPURLToRepo == nil {
			break
		}

		return e.complexity.GitlabProject.HTTPURLToRepo(childComplexity), true

	case "GitlabProject.id":
		if e.complexity.GitlabProject.ID == nil {
			break
		}

		return e.complexity.GitlabProject.ID(childComplexity), true

	case "GitlabProject.lastActivityAt":
		if e.complexity.GitlabProject.LastActivityAt == nil {
			break
		}

		return e.complexity.GitlabProject.LastActivityAt(childComplexity), true

	case "GitlabProject.name":
		if e.complexity.GitlabProject.Name == nil {
			break
		}

		return e.complexity.GitlabProject.Name(childComplexity), true

	case "GitlabProject.nameWithNamespace":
		if e.complexity.GitlabProject.NameWithNamespace == nil {
			break
		}

		return e.complexity.GitlabProject.NameWithNamespace(childComplexity), true

	case "GitlabProject.path":
		if e.complexity.GitlabProject.Path == nil {
			break
		}

		return e.complexity.GitlabProject.Path(childComplexity), true

	case "GitlabProject.pathWithNamespace":
		if e.complexity.GitlabProject.PathWithNamespace == nil {
			break
		}

		return e.complexity.GitlabProject.PathWithNamespace(childComplexity), true

	case "GitlabProject.public":
		if e.complexity.GitlabProject.Public == nil {
			break
		}

		return e.complexity.GitlabProject.Public(childComplexity), true

	case "GitlabProject.sshUrlToRepo":
		if e.complexity.GitlabProject.SSHURLToRepo == nil {
			break
		}

		return e.complexity.GitlabProject.SSHURLToRepo(childComplexity), true

	case "GitlabProject.tagList":
		if e.complexity.GitlabProject.TagList == nil {
			break
		}

		return e.complexity.GitlabProject.TagList(childComplexity), true

	case "GitlabProject.topics":
		if e.complexity.GitlabProject.Topics == nil {
			break
		}

		return e.complexity.GitlabProject.Topics(childComplexity), true

	case "GitlabProject.webUrl":
		if e.complexity.GitlabProject.WebURL == nil {
			break
		}

		return e.complexity.GitlabProject.WebURL(childComplexity), true

	case "Kloudlite_io__apps__container___registry__internal__domain__entities_BuildOptions.buildArgs":
		if e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_BuildOptions.BuildArgs == nil {
			break
		}

		return e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_BuildOptions.BuildArgs(childComplexity), true

	case "Kloudlite_io__apps__container___registry__internal__domain__entities_BuildOptions.buildContexts":
		if e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_BuildOptions.BuildContexts == nil {
			break
		}

		return e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_BuildOptions.BuildContexts(childComplexity), true

	case "Kloudlite_io__apps__container___registry__internal__domain__entities_BuildOptions.contextDir":
		if e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_BuildOptions.ContextDir == nil {
			break
		}

		return e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_BuildOptions.ContextDir(childComplexity), true

	case "Kloudlite_io__apps__container___registry__internal__domain__entities_BuildOptions.dockerfileContent":
		if e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_BuildOptions.DockerfileContent == nil {
			break
		}

		return e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_BuildOptions.DockerfileContent(childComplexity), true

	case "Kloudlite_io__apps__container___registry__internal__domain__entities_BuildOptions.dockerfilePath":
		if e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_BuildOptions.DockerfilePath == nil {
			break
		}

		return e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_BuildOptions.DockerfilePath(childComplexity), true

	case "Kloudlite_io__apps__container___registry__internal__domain__entities_BuildOptions.targetPlatforms":
		if e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_BuildOptions.TargetPlatforms == nil {
			break
		}

		return e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_BuildOptions.TargetPlatforms(childComplexity), true

	case "Kloudlite_io__apps__container___registry__internal__domain__entities_Expiration.unit":
		if e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_Expiration.Unit == nil {
			break
		}

		return e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_Expiration.Unit(childComplexity), true

	case "Kloudlite_io__apps__container___registry__internal__domain__entities_Expiration.value":
		if e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_Expiration.Value == nil {
			break
		}

		return e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_Expiration.Value(childComplexity), true

	case "Kloudlite_io__apps__container___registry__internal__domain__entities_GitSource.branch":
		if e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GitSource.Branch == nil {
			break
		}

		return e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GitSource.Branch(childComplexity), true

	case "Kloudlite_io__apps__container___registry__internal__domain__entities_GitSource.provider":
		if e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GitSource.Provider == nil {
			break
		}

		return e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GitSource.Provider(childComplexity), true

	case "Kloudlite_io__apps__container___registry__internal__domain__entities_GitSource.repository":
		if e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GitSource.Repository == nil {
			break
		}

		return e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GitSource.Repository(childComplexity), true

	case "Kloudlite_io__apps__container___registry__internal__domain__entities_GitSource.webhookId":
		if e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GitSource.WebhookID == nil {
			break
		}

		return e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GitSource.WebhookID(childComplexity), true

	case "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.archived":
		if e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.Archived == nil {
			break
		}

		return e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.Archived(childComplexity), true

	case "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.cloneUrl":
		if e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.CloneURL == nil {
			break
		}

		return e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.CloneURL(childComplexity), true

	case "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.createdAt":
		if e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.CreatedAt == nil {
			break
		}

		return e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.CreatedAt(childComplexity), true

	case "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.defaultBranch":
		if e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.DefaultBranch == nil {
			break
		}

		return e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.DefaultBranch(childComplexity), true

	case "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.description":
		if e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.Description == nil {
			break
		}

		return e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.Description(childComplexity), true

	case "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.disabled":
		if e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.Disabled == nil {
			break
		}

		return e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.Disabled(childComplexity), true

	case "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.fullName":
		if e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.FullName == nil {
			break
		}

		return e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.FullName(childComplexity), true

	case "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.gitUrl":
		if e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.GitURL == nil {
			break
		}

		return e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.GitURL(childComplexity), true

	case "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.gitignoreTemplate":
		if e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.GitignoreTemplate == nil {
			break
		}

		return e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.GitignoreTemplate(childComplexity), true

	case "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.htmlUrl":
		if e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.HTMLURL == nil {
			break
		}

		return e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.HTMLURL(childComplexity), true

	case "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.id":
		if e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.ID == nil {
			break
		}

		return e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.ID(childComplexity), true

	case "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.language":
		if e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.Language == nil {
			break
		}

		return e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.Language(childComplexity), true

	case "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.masterBranch":
		if e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.MasterBranch == nil {
			break
		}

		return e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.MasterBranch(childComplexity), true

	case "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.mirrorUrl":
		if e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.MirrorURL == nil {
			break
		}

		return e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.MirrorURL(childComplexity), true

	case "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.name":
		if e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.Name == nil {
			break
		}

		return e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.Name(childComplexity), true

	case "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.node_id":
		if e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.NodeID == nil {
			break
		}

		return e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.NodeID(childComplexity), true

	case "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.permissions":
		if e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.Permissions == nil {
			break
		}

		return e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.Permissions(childComplexity), true

	case "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.private":
		if e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.Private == nil {
			break
		}

		return e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.Private(childComplexity), true

	case "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.pushedAt":
		if e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.PushedAt == nil {
			break
		}

		return e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.PushedAt(childComplexity), true

	case "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.size":
		if e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.Size == nil {
			break
		}

		return e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.Size(childComplexity), true

	case "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.team_id":
		if e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.TeamID == nil {
			break
		}

		return e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.TeamID(childComplexity), true

	case "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.url":
		if e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.URL == nil {
			break
		}

		return e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.URL(childComplexity), true

	case "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.updatedAt":
		if e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.UpdatedAt == nil {
			break
		}

		return e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.UpdatedAt(childComplexity), true

	case "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.visibility":
		if e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.Visibility == nil {
			break
		}

		return e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository.Visibility(childComplexity), true

	case "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount.avatarUrl":
		if e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount.AvatarURL == nil {
			break
		}

		return e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount.AvatarURL(childComplexity), true

	case "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount.id":
		if e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount.ID == nil {
			break
		}

		return e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount.ID(childComplexity), true

	case "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount.login":
		if e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount.Login == nil {
			break
		}

		return e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount.Login(childComplexity), true

	case "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount.nodeId":
		if e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount.NodeID == nil {
			break
		}

		return e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount.NodeID(childComplexity), true

	case "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount.type":
		if e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount.Type == nil {
			break
		}

		return e.complexity.Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount.Type(childComplexity), true

	case "Kloudlite_io__common_CreatedOrUpdatedBy.userEmail":
		if e.complexity.Kloudlite_io__common_CreatedOrUpdatedBy.UserEmail == nil {
			break
		}

		return e.complexity.Kloudlite_io__common_CreatedOrUpdatedBy.UserEmail(childComplexity), true

	case "Kloudlite_io__common_CreatedOrUpdatedBy.userId":
		if e.complexity.Kloudlite_io__common_CreatedOrUpdatedBy.UserID == nil {
			break
		}

		return e.complexity.Kloudlite_io__common_CreatedOrUpdatedBy.UserID(childComplexity), true

	case "Kloudlite_io__common_CreatedOrUpdatedBy.userName":
		if e.complexity.Kloudlite_io__common_CreatedOrUpdatedBy.UserName == nil {
			break
		}

		return e.complexity.Kloudlite_io__common_CreatedOrUpdatedBy.UserName(childComplexity), true

	case "MatchFilter.array":
		if e.complexity.MatchFilter.Array == nil {
			break
		}

		return e.complexity.MatchFilter.Array(childComplexity), true

	case "MatchFilter.exact":
		if e.complexity.MatchFilter.Exact == nil {
			break
		}

		return e.complexity.MatchFilter.Exact(childComplexity), true

	case "MatchFilter.matchType":
		if e.complexity.MatchFilter.MatchType == nil {
			break
		}

		return e.complexity.MatchFilter.MatchType(childComplexity), true

	case "MatchFilter.regex":
		if e.complexity.MatchFilter.Regex == nil {
			break
		}

		return e.complexity.MatchFilter.Regex(childComplexity), true

	case "Mutation.cr_addBuild":
		if e.complexity.Mutation.CrAddBuild == nil {
			break
		}

		args, err := ec.field_Mutation_cr_addBuild_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CrAddBuild(childComplexity, args["build"].(entities.Build)), true

	case "Mutation.cr_addBuildCacheKey":
		if e.complexity.Mutation.CrAddBuildCacheKey == nil {
			break
		}

		args, err := ec.field_Mutation_cr_addBuildCacheKey_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CrAddBuildCacheKey(childComplexity, args["buildCacheKey"].(entities.BuildCacheKey)), true

	case "Mutation.cr_createCred":
		if e.complexity.Mutation.CrCreateCred == nil {
			break
		}

		args, err := ec.field_Mutation_cr_createCred_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CrCreateCred(childComplexity, args["credential"].(entities.Credential)), true

	case "Mutation.cr_createRepo":
		if e.complexity.Mutation.CrCreateRepo == nil {
			break
		}

		args, err := ec.field_Mutation_cr_createRepo_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CrCreateRepo(childComplexity, args["repository"].(entities.Repository)), true

	case "Mutation.cr_deleteBuild":
		if e.complexity.Mutation.CrDeleteBuild == nil {
			break
		}

		args, err := ec.field_Mutation_cr_deleteBuild_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CrDeleteBuild(childComplexity, args["id"].(repos.ID)), true

	case "Mutation.cr_deleteBuildCacheKey":
		if e.complexity.Mutation.CrDeleteBuildCacheKey == nil {
			break
		}

		args, err := ec.field_Mutation_cr_deleteBuildCacheKey_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CrDeleteBuildCacheKey(childComplexity, args["id"].(repos.ID)), true

	case "Mutation.cr_deleteCred":
		if e.complexity.Mutation.CrDeleteCred == nil {
			break
		}

		args, err := ec.field_Mutation_cr_deleteCred_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CrDeleteCred(childComplexity, args["username"].(string)), true

	case "Mutation.cr_deleteDigest":
		if e.complexity.Mutation.CrDeleteDigest == nil {
			break
		}

		args, err := ec.field_Mutation_cr_deleteDigest_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CrDeleteDigest(childComplexity, args["repoName"].(string), args["digest"].(string)), true

	case "Mutation.cr_deleteRepo":
		if e.complexity.Mutation.CrDeleteRepo == nil {
			break
		}

		args, err := ec.field_Mutation_cr_deleteRepo_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CrDeleteRepo(childComplexity, args["name"].(string)), true

	case "Mutation.cr_listBuildsByBuildCacheId":
		if e.complexity.Mutation.CrListBuildsByBuildCacheID == nil {
			break
		}

		args, err := ec.field_Mutation_cr_listBuildsByBuildCacheId_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CrListBuildsByBuildCacheID(childComplexity, args["buildCacheKeyId"].(repos.ID), args["pagination"].(*repos.CursorPagination)), true

	case "Mutation.cr_triggerBuild":
		if e.complexity.Mutation.CrTriggerBuild == nil {
			break
		}

		args, err := ec.field_Mutation_cr_triggerBuild_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CrTriggerBuild(childComplexity, args["id"].(repos.ID)), true

	case "Mutation.cr_updateBuild":
		if e.complexity.Mutation.CrUpdateBuild == nil {
			break
		}

		args, err := ec.field_Mutation_cr_updateBuild_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CrUpdateBuild(childComplexity, args["id"].(repos.ID), args["build"].(entities.Build)), true

	case "Mutation.cr_updateBuildCacheKey":
		if e.complexity.Mutation.CrUpdateBuildCacheKey == nil {
			break
		}

		args, err := ec.field_Mutation_cr_updateBuildCacheKey_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CrUpdateBuildCacheKey(childComplexity, args["id"].(repos.ID), args["buildCacheKey"].(entities.BuildCacheKey)), true

	case "PageInfo.endCursor":
		if e.complexity.PageInfo.EndCursor == nil {
			break
		}

		return e.complexity.PageInfo.EndCursor(childComplexity), true

	case "PageInfo.hasNextPage":
		if e.complexity.PageInfo.HasNextPage == nil {
			break
		}

		return e.complexity.PageInfo.HasNextPage(childComplexity), true

	case "PageInfo.hasPreviousPage":
		if e.complexity.PageInfo.HasPreviousPage == nil {
			break
		}

		return e.complexity.PageInfo.HasPreviousPage(childComplexity), true

	case "PageInfo.startCursor":
		if e.complexity.PageInfo.StartCursor == nil {
			break
		}

		return e.complexity.PageInfo.StartCursor(childComplexity), true

	case "Pagination.page":
		if e.complexity.Pagination.Page == nil {
			break
		}

		return e.complexity.Pagination.Page(childComplexity), true

	case "Pagination.per_page":
		if e.complexity.Pagination.PerPage == nil {
			break
		}

		return e.complexity.Pagination.PerPage(childComplexity), true

	case "Query.cr_checkUserNameAvailability":
		if e.complexity.Query.CrCheckUserNameAvailability == nil {
			break
		}

		args, err := ec.field_Query_cr_checkUserNameAvailability_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CrCheckUserNameAvailability(childComplexity, args["name"].(string)), true

	case "Query.cr_getBuild":
		if e.complexity.Query.CrGetBuild == nil {
			break
		}

		args, err := ec.field_Query_cr_getBuild_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CrGetBuild(childComplexity, args["id"].(repos.ID)), true

	case "Query.cr_getCredToken":
		if e.complexity.Query.CrGetCredToken == nil {
			break
		}

		args, err := ec.field_Query_cr_getCredToken_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CrGetCredToken(childComplexity, args["username"].(string)), true

	case "Query.cr_listBuildCacheKeys":
		if e.complexity.Query.CrListBuildCacheKeys == nil {
			break
		}

		args, err := ec.field_Query_cr_listBuildCacheKeys_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CrListBuildCacheKeys(childComplexity, args["pq"].(*repos.CursorPagination), args["search"].(*model.SearchBuildCacheKeys)), true

	case "Query.cr_listBuilds":
		if e.complexity.Query.CrListBuilds == nil {
			break
		}

		args, err := ec.field_Query_cr_listBuilds_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CrListBuilds(childComplexity, args["repoName"].(string), args["search"].(*model.SearchBuilds), args["pagination"].(*repos.CursorPagination)), true

	case "Query.cr_listCreds":
		if e.complexity.Query.CrListCreds == nil {
			break
		}

		args, err := ec.field_Query_cr_listCreds_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CrListCreds(childComplexity, args["search"].(*model.SearchCreds), args["pagination"].(*repos.CursorPagination)), true

	case "Query.cr_listDigests":
		if e.complexity.Query.CrListDigests == nil {
			break
		}

		args, err := ec.field_Query_cr_listDigests_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CrListDigests(childComplexity, args["repoName"].(string), args["search"].(*model.SearchRepos), args["pagination"].(*repos.CursorPagination)), true

	case "Query.cr_listGithubBranches":
		if e.complexity.Query.CrListGithubBranches == nil {
			break
		}

		args, err := ec.field_Query_cr_listGithubBranches_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CrListGithubBranches(childComplexity, args["repoUrl"].(string), args["pagination"].(*types.Pagination)), true

	case "Query.cr_listGithubInstallations":
		if e.complexity.Query.CrListGithubInstallations == nil {
			break
		}

		args, err := ec.field_Query_cr_listGithubInstallations_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CrListGithubInstallations(childComplexity, args["pagination"].(*types.Pagination)), true

	case "Query.cr_listGithubRepos":
		if e.complexity.Query.CrListGithubRepos == nil {
			break
		}

		args, err := ec.field_Query_cr_listGithubRepos_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CrListGithubRepos(childComplexity, args["installationId"].(int), args["pagination"].(*types.Pagination)), true

	case "Query.cr_listGitlabBranches":
		if e.complexity.Query.CrListGitlabBranches == nil {
			break
		}

		args, err := ec.field_Query_cr_listGitlabBranches_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CrListGitlabBranches(childComplexity, args["repoId"].(string), args["query"].(*string), args["pagination"].(*types.Pagination)), true

	case "Query.cr_listGitlabGroups":
		if e.complexity.Query.CrListGitlabGroups == nil {
			break
		}

		args, err := ec.field_Query_cr_listGitlabGroups_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CrListGitlabGroups(childComplexity, args["query"].(*string), args["pagination"].(*types.Pagination)), true

	case "Query.cr_listGitlabRepositories":
		if e.complexity.Query.CrListGitlabRepositories == nil {
			break
		}

		args, err := ec.field_Query_cr_listGitlabRepositories_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CrListGitlabRepositories(childComplexity, args["groupId"].(string), args["query"].(*string), args["pagination"].(*types.Pagination)), true

	case "Query.cr_listRepos":
		if e.complexity.Query.CrListRepos == nil {
			break
		}

		args, err := ec.field_Query_cr_listRepos_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CrListRepos(childComplexity, args["search"].(*model.SearchRepos), args["pagination"].(*repos.CursorPagination)), true

	case "Query.cr_searchGithubRepos":
		if e.complexity.Query.CrSearchGithubRepos == nil {
			break
		}

		args, err := ec.field_Query_cr_searchGithubRepos_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CrSearchGithubRepos(childComplexity, args["organization"].(string), args["search"].(string), args["pagination"].(*types.Pagination)), true

	case "Query._service":
		if e.complexity.Query.__resolve__service == nil {
			break
		}

		return e.complexity.Query.__resolve__service(childComplexity), true

	case "Repository.accountName":
		if e.complexity.Repository.AccountName == nil {
			break
		}

		return e.complexity.Repository.AccountName(childComplexity), true

	case "Repository.createdBy":
		if e.complexity.Repository.CreatedBy == nil {
			break
		}

		return e.complexity.Repository.CreatedBy(childComplexity), true

	case "Repository.creationTime":
		if e.complexity.Repository.CreationTime == nil {
			break
		}

		return e.complexity.Repository.CreationTime(childComplexity), true

	case "Repository.id":
		if e.complexity.Repository.ID == nil {
			break
		}

		return e.complexity.Repository.ID(childComplexity), true

	case "Repository.lastUpdatedBy":
		if e.complexity.Repository.LastUpdatedBy == nil {
			break
		}

		return e.complexity.Repository.LastUpdatedBy(childComplexity), true

	case "Repository.markedForDeletion":
		if e.complexity.Repository.MarkedForDeletion == nil {
			break
		}

		return e.complexity.Repository.MarkedForDeletion(childComplexity), true

	case "Repository.name":
		if e.complexity.Repository.Name == nil {
			break
		}

		return e.complexity.Repository.Name(childComplexity), true

	case "Repository.recordVersion":
		if e.complexity.Repository.RecordVersion == nil {
			break
		}

		return e.complexity.Repository.RecordVersion(childComplexity), true

	case "Repository.updateTime":
		if e.complexity.Repository.UpdateTime == nil {
			break
		}

		return e.complexity.Repository.UpdateTime(childComplexity), true

	case "RepositoryEdge.cursor":
		if e.complexity.RepositoryEdge.Cursor == nil {
			break
		}

		return e.complexity.RepositoryEdge.Cursor(childComplexity), true

	case "RepositoryEdge.node":
		if e.complexity.RepositoryEdge.Node == nil {
			break
		}

		return e.complexity.RepositoryEdge.Node(childComplexity), true

	case "RepositoryPaginatedRecords.edges":
		if e.complexity.RepositoryPaginatedRecords.Edges == nil {
			break
		}

		return e.complexity.RepositoryPaginatedRecords.Edges(childComplexity), true

	case "RepositoryPaginatedRecords.pageInfo":
		if e.complexity.RepositoryPaginatedRecords.PageInfo == nil {
			break
		}

		return e.complexity.RepositoryPaginatedRecords.PageInfo(childComplexity), true

	case "RepositoryPaginatedRecords.totalCount":
		if e.complexity.RepositoryPaginatedRecords.TotalCount == nil {
			break
		}

		return e.complexity.RepositoryPaginatedRecords.TotalCount(childComplexity), true

	case "_Service.sdl":
		if e.complexity._Service.SDL == nil {
			break
		}

		return e.complexity._Service.SDL(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputBuildCacheKeyIn,
		ec.unmarshalInputBuildIn,
		ec.unmarshalInputCredentialIn,
		ec.unmarshalInputCursorPaginationIn,
		ec.unmarshalInputKloudlite_io__apps__container___registry__internal__domain__entities_BuildOptionsIn,
		ec.unmarshalInputKloudlite_io__apps__container___registry__internal__domain__entities_ExpirationIn,
		ec.unmarshalInputKloudlite_io__apps__container___registry__internal__domain__entities_GitSourceIn,
		ec.unmarshalInputKloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccountIn,
		ec.unmarshalInputMatchFilterIn,
		ec.unmarshalInputPaginationIn,
		ec.unmarshalInputRepositoryIn,
		ec.unmarshalInputSearchBuildCacheKeys,
		ec.unmarshalInputSearchBuilds,
		ec.unmarshalInputSearchCreds,
		ec.unmarshalInputSearchRepos,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Query(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schema.graphqls", Input: `directive @isLoggedInAndVerified on FIELD_DEFINITION
directive @hasAccount on FIELD_DEFINITION

input SearchRepos {
  text: MatchFilterIn
}

input  SearchCreds {
  text: MatchFilterIn
}

input  SearchBuilds {
  text: MatchFilterIn
}

input SearchBuildCacheKeys {
  text: MatchFilterIn
}

type CRCheckNameAvailabilityOutput @shareable {
  result: Boolean!
  suggestedNames: [String!]
}

type Query {
  cr_listRepos(search:SearchRepos, pagination:CursorPaginationIn) : RepositoryPaginatedRecords @isLoggedInAndVerified @hasAccount
  cr_listCreds(search:SearchCreds, pagination:CursorPaginationIn) : CredentialPaginatedRecords @isLoggedInAndVerified @hasAccount
  cr_listDigests(repoName:String!, search: SearchRepos, pagination:CursorPaginationIn) : DigestPaginatedRecords @isLoggedInAndVerified @hasAccount

  cr_getCredToken(username:String!) : String! @isLoggedInAndVerified @hasAccount

  cr_checkUserNameAvailability(name:String!) :CRCheckNameAvailabilityOutput! @isLoggedInAndVerified @hasAccount

  cr_getBuild(id:ID!) : Build @isLoggedInAndVerified @hasAccount
  cr_listBuilds(repoName:String!, search:SearchBuilds, pagination:CursorPaginationIn) : BuildPaginatedRecords @isLoggedInAndVerified @hasAccount

  cr_listGithubInstallations(pagination:PaginationIn) : [GithubInstallation!] @isLoggedInAndVerified
  cr_listGithubRepos(installationId:Int!, pagination:PaginationIn) : GithubListRepository @isLoggedInAndVerified
  cr_searchGithubRepos(organization:String!, search:String!, pagination:PaginationIn) : GithubSearchRepository @isLoggedInAndVerified
  cr_listGithubBranches(repoUrl:String!, pagination:PaginationIn) : [GitBranch!] @isLoggedInAndVerified

  cr_listGitlabGroups(query:String, pagination:PaginationIn) : [GitlabGroup!] @isLoggedInAndVerified
  cr_listGitlabRepositories(groupId:String!, query:String, pagination:PaginationIn) : [GitlabProject!] @isLoggedInAndVerified
  cr_listGitlabBranches(repoId:String!, query:String, pagination:PaginationIn) : [GitBranch!] @isLoggedInAndVerified
  cr_listBuildCacheKeys(pq:CursorPaginationIn, search: SearchBuildCacheKeys) : BuildCacheKeyPaginatedRecords @isLoggedInAndVerified @hasAccount
}

type Mutation {
  cr_createRepo(repository:RepositoryIn!) : Repository @isLoggedInAndVerified @hasAccount
  cr_createCred(credential: CredentialIn!) : Credential @isLoggedInAndVerified @hasAccount

  cr_deleteRepo(name:String!) :Boolean! @isLoggedInAndVerified @hasAccount
  cr_deleteCred(username:String!) :Boolean! @isLoggedInAndVerified @hasAccount
  cr_deleteDigest(repoName:String!, digest:String!) :Boolean! @isLoggedInAndVerified @hasAccount


  cr_addBuild(build:BuildIn!) : Build @isLoggedInAndVerified @hasAccount
  cr_updateBuild(id:ID!, build:BuildIn!) : Build @isLoggedInAndVerified @hasAccount
  cr_deleteBuild(id:ID!) : Boolean! @isLoggedInAndVerified @hasAccount
  cr_triggerBuild(id:ID!) : Boolean! @isLoggedInAndVerified @hasAccount

  cr_addBuildCacheKey(buildCacheKey:BuildCacheKeyIn!) : BuildCacheKey @isLoggedInAndVerified @hasAccount
  cr_deleteBuildCacheKey(id:ID!) : Boolean! @isLoggedInAndVerified @hasAccount
  cr_updateBuildCacheKey(id:ID!, buildCacheKey:BuildCacheKeyIn!) : BuildCacheKey @isLoggedInAndVerified @hasAccount

  cr_listBuildsByBuildCacheId(buildCacheKeyId:ID!, pagination:CursorPaginationIn) : BuildPaginatedRecords @isLoggedInAndVerified @hasAccount
}
`, BuiltIn: false},
	{Name: "../struct-to-graphql/build.graphqls", Input: `type Build @shareable {
  accountName: String!
  buildCacheId: String
  buildData: Kloudlite_io__apps__container___registry__internal__domain__entities_BuildOptions
  createdBy: Kloudlite_io__common_CreatedOrUpdatedBy!
  creationTime: Date!
  credUser: Kloudlite_io__common_CreatedOrUpdatedBy!
  errorMessages: Map!
  id: String!
  lastUpdatedBy: Kloudlite_io__common_CreatedOrUpdatedBy!
  markedForDeletion: Boolean
  name: String!
  recordVersion: Int!
  repository: String!
  source: Kloudlite_io__apps__container___registry__internal__domain__entities_GitSource!
  status: Kloudlite_io__apps__container___registry__internal__domain__entities_BuildStatus!
  tags: [String!]!
  updateTime: Date!
}

type BuildEdge @shareable {
  cursor: String!
  node: Build!
}

type BuildPaginatedRecords @shareable {
  edges: [BuildEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input BuildIn {
  buildCacheId: String
  buildData: Kloudlite_io__apps__container___registry__internal__domain__entities_BuildOptionsIn
  name: String!
  repository: String!
  source: Kloudlite_io__apps__container___registry__internal__domain__entities_GitSourceIn!
  tags: [String!]!
}

`, BuiltIn: false},
	{Name: "../struct-to-graphql/buildcachekey.graphqls", Input: `type BuildCacheKey @shareable {
  accountName: String!
  createdBy: Kloudlite_io__common_CreatedOrUpdatedBy!
  creationTime: Date!
  displayName: String!
  id: String!
  lastUpdatedBy: Kloudlite_io__common_CreatedOrUpdatedBy!
  markedForDeletion: Boolean
  name: String!
  recordVersion: Int!
  updateTime: Date!
  volumeSizeInGB: Float!
}

type BuildCacheKeyEdge @shareable {
  cursor: String!
  node: BuildCacheKey!
}

type BuildCacheKeyPaginatedRecords @shareable {
  edges: [BuildCacheKeyEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input BuildCacheKeyIn {
  displayName: String!
  name: String!
  volumeSizeInGB: Float!
}

`, BuiltIn: false},
	{Name: "../struct-to-graphql/common-types.graphqls", Input: `type Kloudlite_io__apps__container___registry__internal__domain__entities_BuildOptions @shareable {
  buildArgs: Map!
  buildContexts: Map!
  contextDir: String
  dockerfileContent: String
  dockerfilePath: String
  targetPlatforms: [String!]!
}

type Kloudlite_io__apps__container___registry__internal__domain__entities_Expiration @shareable {
  unit: Kloudlite_io__apps__container___registry__internal__domain__entities_ExpirationUnit!
  value: Int!
}

type Kloudlite_io__apps__container___registry__internal__domain__entities_GitSource @shareable {
  branch: String!
  provider: Kloudlite_io__apps__container___registry__internal__domain__entities_GitProvider!
  repository: String!
  webhookId: Int
}

type Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository @shareable {
  archived: Boolean
  cloneUrl: String
  createdAt: Date
  defaultBranch: String
  description: String
  disabled: Boolean
  fullName: String
  gitignoreTemplate: String
  gitUrl: String
  htmlUrl: String
  id: Int
  language: String
  masterBranch: String
  mirrorUrl: String
  name: String
  node_id: String
  permissions: Map
  private: Boolean
  pushedAt: Date
  size: Int
  team_id: Int
  updatedAt: Date
  url: String
  visibility: String
}

type Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount @shareable {
  avatarUrl: String
  id: Int
  login: String
  nodeId: String
  type: String
}

type Kloudlite_io__common_CreatedOrUpdatedBy @shareable {
  userEmail: String!
  userId: String!
  userName: String!
}

type PageInfo @shareable {
  endCursor: String
  hasNextPage: Boolean
  hasPreviousPage: Boolean
  startCursor: String
}

input Kloudlite_io__apps__container___registry__internal__domain__entities_BuildOptionsIn {
  buildArgs: Map!
  buildContexts: Map!
  contextDir: String
  dockerfileContent: String
  dockerfilePath: String
  targetPlatforms: [String!]!
}

input Kloudlite_io__apps__container___registry__internal__domain__entities_ExpirationIn {
  unit: Kloudlite_io__apps__container___registry__internal__domain__entities_ExpirationUnit!
  value: Int!
}

input Kloudlite_io__apps__container___registry__internal__domain__entities_GitSourceIn {
  branch: String!
  provider: Kloudlite_io__apps__container___registry__internal__domain__entities_GitProvider!
  repository: String!
}

input Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccountIn {
  avatarUrl: String
  id: Int
  login: String
  nodeId: String
  type: String
}

enum Kloudlite_io__apps__container___registry__internal__domain__entities_BuildStatus {
  error
  failed
  idle
  pending
  queued
  running
  success
}

enum Kloudlite_io__apps__container___registry__internal__domain__entities_ExpirationUnit {
  d
  h
  m
  w
  y
}

enum Kloudlite_io__apps__container___registry__internal__domain__entities_GitProvider {
  github
  gitlab
}

enum Kloudlite_io__apps__container___registry__internal__domain__entities_RepoAccess {
  read
  read_write
}

`, BuiltIn: false},
	{Name: "../struct-to-graphql/credential.graphqls", Input: `type Credential @shareable {
  access: Kloudlite_io__apps__container___registry__internal__domain__entities_RepoAccess!
  accountName: String!
  createdBy: Kloudlite_io__common_CreatedOrUpdatedBy!
  creationTime: Date!
  expiration: Kloudlite_io__apps__container___registry__internal__domain__entities_Expiration!
  id: String!
  lastUpdatedBy: Kloudlite_io__common_CreatedOrUpdatedBy!
  markedForDeletion: Boolean
  name: String!
  recordVersion: Int!
  updateTime: Date!
  username: String!
}

type CredentialEdge @shareable {
  cursor: String!
  node: Credential!
}

type CredentialPaginatedRecords @shareable {
  edges: [CredentialEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input CredentialIn {
  access: Kloudlite_io__apps__container___registry__internal__domain__entities_RepoAccess!
  expiration: Kloudlite_io__apps__container___registry__internal__domain__entities_ExpirationIn!
  name: String!
  username: String!
}

`, BuiltIn: false},
	{Name: "../struct-to-graphql/cursorpagination.graphqls", Input: `type CursorPagination @shareable {
  after: String
  before: String
  first: Int
  last: Int
  orderBy: String
  sortDirection: CursorPaginationSortDirection
}

input CursorPaginationIn {
  after: String
  before: String
  first: Int
  last: Int
  orderBy: String = "_id"
  sortDirection: CursorPaginationSortDirection = "ASC"
}

enum CursorPaginationSortDirection {
  ASC
  DESC
}

`, BuiltIn: false},
	{Name: "../struct-to-graphql/digest.graphqls", Input: `type Digest @shareable {
  accountName: String!
  actor: String!
  creationTime: Date!
  deleting: Boolean!
  digest: String!
  id: String!
  length: Int!
  markedForDeletion: Boolean
  mediaType: String!
  recordVersion: Int!
  repository: String!
  size: Int!
  tags: [String!]!
  updateTime: Date!
  url: String!
}

type DigestEdge @shareable {
  cursor: String!
  node: Digest!
}

type DigestPaginatedRecords @shareable {
  edges: [DigestEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

`, BuiltIn: false},
	{Name: "../struct-to-graphql/directives.graphqls", Input: `extend schema @link(url: "https://specs.apollo.dev/federation/v2.0", import: ["@key", "@shareable", "@external"])

directive @goField(
	forceResolver: Boolean
	name: String
) on INPUT_FIELD_DEFINITION | FIELD_DEFINITION
`, BuiltIn: false},
	{Name: "../struct-to-graphql/gitbranch.graphqls", Input: `type GitBranch @shareable {
  name: String
  protected: Boolean
}

`, BuiltIn: false},
	{Name: "../struct-to-graphql/githubbranch.graphqls", Input: `type GithubBranch @shareable {
  name: String
  protected: Boolean
}

`, BuiltIn: false},
	{Name: "../struct-to-graphql/githubinstallation.graphqls", Input: `type GithubInstallation @shareable {
  account: Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount
  appId: Int
  id: Int
  nodeId: String
  repositoriesUrl: String
  targetId: Int
  targetType: String
}

`, BuiltIn: false},
	{Name: "../struct-to-graphql/githublistrepository.graphqls", Input: `type GithubListRepository @shareable {
  repositories: [Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository]!
  totalCount: Int
}

`, BuiltIn: false},
	{Name: "../struct-to-graphql/githubsearchrepository.graphqls", Input: `type GithubSearchRepository @shareable {
  incompleteResults: Boolean
  repositories: [Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository]!
  total: Int
}

`, BuiltIn: false},
	{Name: "../struct-to-graphql/gitlabbranch.graphqls", Input: `type GitlabBranch @shareable {
  canPush: Boolean!
  default: Boolean!
  developersCanMerge: Boolean!
  developersCanPush: Boolean!
  merged: Boolean!
  name: String!
  protected: Boolean!
  webUrl: String!
}

`, BuiltIn: false},
	{Name: "../struct-to-graphql/gitlabgroup.graphqls", Input: `type GitlabGroup @shareable {
  avatarUrl: String!
  fullName: String!
  id: String!
}

`, BuiltIn: false},
	{Name: "../struct-to-graphql/gitlabproject.graphqls", Input: `type GitlabProject @shareable {
  archived: Boolean!
  avatarUrl: String!
  createdAt: Date
  creatorId: Int!
  defaultBranch: String!
  description: String!
  emptyRepo: Boolean!
  httpUrlToRepo: String!
  id: Int!
  lastActivityAt: Date
  name: String!
  nameWithNamespace: String!
  path: String!
  pathWithNamespace: String!
  public: Boolean!
  sshUrlToRepo: String!
  tagList: [String!]!
  topics: [String!]!
  webUrl: String!
}

`, BuiltIn: false},
	{Name: "../struct-to-graphql/matchfilter.graphqls", Input: `type MatchFilter @shareable {
  array: [Any!]
  exact: Any
  matchType: MatchFilterMatchType!
  regex: String
}

input MatchFilterIn {
  array: [Any!]
  exact: Any
  matchType: MatchFilterMatchType!
  regex: String
}

enum MatchFilterMatchType {
  array
  exact
  regex
}

`, BuiltIn: false},
	{Name: "../struct-to-graphql/pagination.graphqls", Input: `type Pagination @shareable {
  page: Int
  per_page: Int
}

input PaginationIn {
  page: Int
  per_page: Int
}

`, BuiltIn: false},
	{Name: "../struct-to-graphql/repository.graphqls", Input: `type Repository @shareable {
  accountName: String!
  createdBy: Kloudlite_io__common_CreatedOrUpdatedBy!
  creationTime: Date!
  id: String!
  lastUpdatedBy: Kloudlite_io__common_CreatedOrUpdatedBy!
  markedForDeletion: Boolean
  name: String!
  recordVersion: Int!
  updateTime: Date!
}

type RepositoryEdge @shareable {
  cursor: String!
  node: Repository!
}

type RepositoryPaginatedRecords @shareable {
  edges: [RepositoryEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input RepositoryIn {
  name: String!
}

`, BuiltIn: false},
	{Name: "../struct-to-graphql/scalars.graphqls", Input: `scalar Any
scalar Json
scalar Map
scalar Date
`, BuiltIn: false},
	{Name: "../../federation/directives.graphql", Input: `
	scalar _Any
	scalar _FieldSet
	directive @requires(fields: _FieldSet!) on FIELD_DEFINITION
	directive @provides(fields: _FieldSet!) on FIELD_DEFINITION
	directive @extends on OBJECT | INTERFACE

	directive @key(fields: _FieldSet!, resolvable: Boolean = true) repeatable on OBJECT | INTERFACE
	directive @external on FIELD_DEFINITION | OBJECT
	directive @link(import: [String!], url: String!) repeatable on SCHEMA
	directive @shareable on OBJECT | FIELD_DEFINITION
	directive @tag(name: String!) repeatable on FIELD_DEFINITION | INTERFACE | OBJECT | UNION | ARGUMENT_DEFINITION | SCALAR | ENUM | ENUM_VALUE | INPUT_OBJECT | INPUT_FIELD_DEFINITION
	directive @override(from: String!) on FIELD_DEFINITION
	directive @inaccessible on SCALAR | OBJECT | FIELD_DEFINITION | ARGUMENT_DEFINITION | INTERFACE | UNION | ENUM | ENUM_VALUE | INPUT_OBJECT | INPUT_FIELD_DEFINITION
`, BuiltIn: true},
	{Name: "../../federation/entity.graphql", Input: `
type _Service {
  sdl: String
}

extend type Query {
  _service: _Service!
}
`, BuiltIn: true},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) field_Mutation_cr_addBuildCacheKey_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 entities.BuildCacheKey
	if tmp, ok := rawArgs["buildCacheKey"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("buildCacheKey"))
		arg0, err = ec.unmarshalNBuildCacheKeyIn2kloudliteioappscontainerregistryinternaldomainentitiesBuildCacheKey(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["buildCacheKey"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_cr_addBuild_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 entities.Build
	if tmp, ok := rawArgs["build"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("build"))
		arg0, err = ec.unmarshalNBuildIn2kloudliteioappscontainerregistryinternaldomainentitiesBuild(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["build"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_cr_createCred_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 entities.Credential
	if tmp, ok := rawArgs["credential"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("credential"))
		arg0, err = ec.unmarshalNCredentialIn2kloudliteioappscontainerregistryinternaldomainentitiesCredential(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["credential"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_cr_createRepo_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 entities.Repository
	if tmp, ok := rawArgs["repository"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("repository"))
		arg0, err = ec.unmarshalNRepositoryIn2kloudliteioappscontainerregistryinternaldomainentitiesRepository(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["repository"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_cr_deleteBuildCacheKey_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 repos.ID
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2kloudliteiopkgreposID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_cr_deleteBuild_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 repos.ID
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2kloudliteiopkgreposID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_cr_deleteCred_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["username"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("username"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["username"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_cr_deleteDigest_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["repoName"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("repoName"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["repoName"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["digest"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("digest"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["digest"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_cr_deleteRepo_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_cr_listBuildsByBuildCacheId_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 repos.ID
	if tmp, ok := rawArgs["buildCacheKeyId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("buildCacheKeyId"))
		arg0, err = ec.unmarshalNID2kloudliteiopkgreposID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["buildCacheKeyId"] = arg0
	var arg1 *repos.CursorPagination
	if tmp, ok := rawArgs["pagination"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
		arg1, err = ec.unmarshalOCursorPaginationIn2kloudliteiopkgreposCursorPagination(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pagination"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_cr_triggerBuild_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 repos.ID
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2kloudliteiopkgreposID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_cr_updateBuildCacheKey_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 repos.ID
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2kloudliteiopkgreposID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 entities.BuildCacheKey
	if tmp, ok := rawArgs["buildCacheKey"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("buildCacheKey"))
		arg1, err = ec.unmarshalNBuildCacheKeyIn2kloudliteioappscontainerregistryinternaldomainentitiesBuildCacheKey(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["buildCacheKey"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_cr_updateBuild_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 repos.ID
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2kloudliteiopkgreposID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 entities.Build
	if tmp, ok := rawArgs["build"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("build"))
		arg1, err = ec.unmarshalNBuildIn2kloudliteioappscontainerregistryinternaldomainentitiesBuild(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["build"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_cr_checkUserNameAvailability_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_cr_getBuild_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 repos.ID
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2kloudliteiopkgreposID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_cr_getCredToken_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["username"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("username"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["username"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_cr_listBuildCacheKeys_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *repos.CursorPagination
	if tmp, ok := rawArgs["pq"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pq"))
		arg0, err = ec.unmarshalOCursorPaginationIn2kloudliteiopkgreposCursorPagination(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pq"] = arg0
	var arg1 *model.SearchBuildCacheKeys
	if tmp, ok := rawArgs["search"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("search"))
		arg1, err = ec.unmarshalOSearchBuildCacheKeys2kloudliteioappscontainerregistryinternalappgraphmodelSearchBuildCacheKeys(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["search"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_cr_listBuilds_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["repoName"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("repoName"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["repoName"] = arg0
	var arg1 *model.SearchBuilds
	if tmp, ok := rawArgs["search"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("search"))
		arg1, err = ec.unmarshalOSearchBuilds2kloudliteioappscontainerregistryinternalappgraphmodelSearchBuilds(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["search"] = arg1
	var arg2 *repos.CursorPagination
	if tmp, ok := rawArgs["pagination"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
		arg2, err = ec.unmarshalOCursorPaginationIn2kloudliteiopkgreposCursorPagination(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pagination"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_cr_listCreds_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.SearchCreds
	if tmp, ok := rawArgs["search"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("search"))
		arg0, err = ec.unmarshalOSearchCreds2kloudliteioappscontainerregistryinternalappgraphmodelSearchCreds(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["search"] = arg0
	var arg1 *repos.CursorPagination
	if tmp, ok := rawArgs["pagination"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
		arg1, err = ec.unmarshalOCursorPaginationIn2kloudliteiopkgreposCursorPagination(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pagination"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_cr_listDigests_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["repoName"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("repoName"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["repoName"] = arg0
	var arg1 *model.SearchRepos
	if tmp, ok := rawArgs["search"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("search"))
		arg1, err = ec.unmarshalOSearchRepos2kloudliteioappscontainerregistryinternalappgraphmodelSearchRepos(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["search"] = arg1
	var arg2 *repos.CursorPagination
	if tmp, ok := rawArgs["pagination"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
		arg2, err = ec.unmarshalOCursorPaginationIn2kloudliteiopkgreposCursorPagination(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pagination"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_cr_listGithubBranches_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["repoUrl"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("repoUrl"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["repoUrl"] = arg0
	var arg1 *types.Pagination
	if tmp, ok := rawArgs["pagination"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
		arg1, err = ec.unmarshalOPaginationIn2kloudliteiopkgtypesPagination(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pagination"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_cr_listGithubInstallations_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *types.Pagination
	if tmp, ok := rawArgs["pagination"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
		arg0, err = ec.unmarshalOPaginationIn2kloudliteiopkgtypesPagination(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pagination"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_cr_listGithubRepos_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["installationId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("installationId"))
		arg0, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["installationId"] = arg0
	var arg1 *types.Pagination
	if tmp, ok := rawArgs["pagination"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
		arg1, err = ec.unmarshalOPaginationIn2kloudliteiopkgtypesPagination(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pagination"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_cr_listGitlabBranches_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["repoId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("repoId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["repoId"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["query"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("query"))
		arg1, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["query"] = arg1
	var arg2 *types.Pagination
	if tmp, ok := rawArgs["pagination"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
		arg2, err = ec.unmarshalOPaginationIn2kloudliteiopkgtypesPagination(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pagination"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_cr_listGitlabGroups_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["query"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("query"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["query"] = arg0
	var arg1 *types.Pagination
	if tmp, ok := rawArgs["pagination"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
		arg1, err = ec.unmarshalOPaginationIn2kloudliteiopkgtypesPagination(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pagination"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_cr_listGitlabRepositories_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["groupId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("groupId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["groupId"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["query"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("query"))
		arg1, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["query"] = arg1
	var arg2 *types.Pagination
	if tmp, ok := rawArgs["pagination"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
		arg2, err = ec.unmarshalOPaginationIn2kloudliteiopkgtypesPagination(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pagination"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_cr_listRepos_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.SearchRepos
	if tmp, ok := rawArgs["search"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("search"))
		arg0, err = ec.unmarshalOSearchRepos2kloudliteioappscontainerregistryinternalappgraphmodelSearchRepos(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["search"] = arg0
	var arg1 *repos.CursorPagination
	if tmp, ok := rawArgs["pagination"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
		arg1, err = ec.unmarshalOCursorPaginationIn2kloudliteiopkgreposCursorPagination(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pagination"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_cr_searchGithubRepos_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["organization"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("organization"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["organization"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["search"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("search"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["search"] = arg1
	var arg2 *types.Pagination
	if tmp, ok := rawArgs["pagination"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
		arg2, err = ec.unmarshalOPaginationIn2kloudliteiopkgtypesPagination(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pagination"] = arg2
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _Build_accountName(ctx context.Context, field graphql.CollectedField, obj *entities.Build) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Build_accountName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AccountName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Build_accountName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Build",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Build_buildCacheId(ctx context.Context, field graphql.CollectedField, obj *entities.Build) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Build_buildCacheId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BuildCacheId, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Build_buildCacheId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Build",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Build_buildData(ctx context.Context, field graphql.CollectedField, obj *entities.Build) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Build_buildData(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Build().BuildData(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesBuildOptions)
	fc.Result = res
	return ec.marshalOKloudlite_io__apps__container___registry__internal__domain__entities_BuildOptions2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoAppsContainerRegistryInternalDomainEntitiesBuildOptions(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Build_buildData(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Build",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "buildArgs":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_BuildOptions_buildArgs(ctx, field)
			case "buildContexts":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_BuildOptions_buildContexts(ctx, field)
			case "contextDir":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_BuildOptions_contextDir(ctx, field)
			case "dockerfileContent":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_BuildOptions_dockerfileContent(ctx, field)
			case "dockerfilePath":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_BuildOptions_dockerfilePath(ctx, field)
			case "targetPlatforms":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_BuildOptions_targetPlatforms(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Kloudlite_io__apps__container___registry__internal__domain__entities_BuildOptions", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Build_createdBy(ctx context.Context, field graphql.CollectedField, obj *entities.Build) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Build_createdBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Build().CreatedBy(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.KloudliteIoCommonCreatedOrUpdatedBy)
	fc.Result = res
	return ec.marshalNKloudlite_io__common_CreatedOrUpdatedBy2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoCommonCreatedOrUpdatedBy(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Build_createdBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Build",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "userEmail":
				return ec.fieldContext_Kloudlite_io__common_CreatedOrUpdatedBy_userEmail(ctx, field)
			case "userId":
				return ec.fieldContext_Kloudlite_io__common_CreatedOrUpdatedBy_userId(ctx, field)
			case "userName":
				return ec.fieldContext_Kloudlite_io__common_CreatedOrUpdatedBy_userName(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Kloudlite_io__common_CreatedOrUpdatedBy", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Build_creationTime(ctx context.Context, field graphql.CollectedField, obj *entities.Build) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Build_creationTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Build().CreationTime(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNDate2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Build_creationTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Build",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Build_credUser(ctx context.Context, field graphql.CollectedField, obj *entities.Build) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Build_credUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Build().CredUser(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.KloudliteIoCommonCreatedOrUpdatedBy)
	fc.Result = res
	return ec.marshalNKloudlite_io__common_CreatedOrUpdatedBy2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoCommonCreatedOrUpdatedBy(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Build_credUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Build",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "userEmail":
				return ec.fieldContext_Kloudlite_io__common_CreatedOrUpdatedBy_userEmail(ctx, field)
			case "userId":
				return ec.fieldContext_Kloudlite_io__common_CreatedOrUpdatedBy_userId(ctx, field)
			case "userName":
				return ec.fieldContext_Kloudlite_io__common_CreatedOrUpdatedBy_userName(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Kloudlite_io__common_CreatedOrUpdatedBy", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Build_errorMessages(ctx context.Context, field graphql.CollectedField, obj *entities.Build) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Build_errorMessages(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Build().ErrorMessages(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalNMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Build_errorMessages(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Build",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Build_id(ctx context.Context, field graphql.CollectedField, obj *entities.Build) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Build_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Build().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Build_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Build",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Build_lastUpdatedBy(ctx context.Context, field graphql.CollectedField, obj *entities.Build) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Build_lastUpdatedBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Build().LastUpdatedBy(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.KloudliteIoCommonCreatedOrUpdatedBy)
	fc.Result = res
	return ec.marshalNKloudlite_io__common_CreatedOrUpdatedBy2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoCommonCreatedOrUpdatedBy(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Build_lastUpdatedBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Build",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "userEmail":
				return ec.fieldContext_Kloudlite_io__common_CreatedOrUpdatedBy_userEmail(ctx, field)
			case "userId":
				return ec.fieldContext_Kloudlite_io__common_CreatedOrUpdatedBy_userId(ctx, field)
			case "userName":
				return ec.fieldContext_Kloudlite_io__common_CreatedOrUpdatedBy_userName(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Kloudlite_io__common_CreatedOrUpdatedBy", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Build_markedForDeletion(ctx context.Context, field graphql.CollectedField, obj *entities.Build) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Build_markedForDeletion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MarkedForDeletion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Build_markedForDeletion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Build",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Build_name(ctx context.Context, field graphql.CollectedField, obj *entities.Build) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Build_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Build_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Build",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Build_recordVersion(ctx context.Context, field graphql.CollectedField, obj *entities.Build) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Build_recordVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RecordVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Build_recordVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Build",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Build_repository(ctx context.Context, field graphql.CollectedField, obj *entities.Build) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Build_repository(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Repository, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Build_repository(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Build",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Build_source(ctx context.Context, field graphql.CollectedField, obj *entities.Build) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Build_source(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Build().Source(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGitSource)
	fc.Result = res
	return ec.marshalNKloudlite_io__apps__container___registry__internal__domain__entities_GitSource2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoAppsContainerRegistryInternalDomainEntitiesGitSource(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Build_source(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Build",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "branch":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GitSource_branch(ctx, field)
			case "provider":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GitSource_provider(ctx, field)
			case "repository":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GitSource_repository(ctx, field)
			case "webhookId":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GitSource_webhookId(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Kloudlite_io__apps__container___registry__internal__domain__entities_GitSource", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Build_status(ctx context.Context, field graphql.CollectedField, obj *entities.Build) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Build_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Build().Status(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesBuildStatus)
	fc.Result = res
	return ec.marshalNKloudlite_io__apps__container___registry__internal__domain__entities_BuildStatus2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoAppsContainerRegistryInternalDomainEntitiesBuildStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Build_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Build",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Kloudlite_io__apps__container___registry__internal__domain__entities_BuildStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Build_tags(ctx context.Context, field graphql.CollectedField, obj *entities.Build) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Build_tags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tags, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Build_tags(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Build",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Build_updateTime(ctx context.Context, field graphql.CollectedField, obj *entities.Build) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Build_updateTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Build().UpdateTime(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNDate2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Build_updateTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Build",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildCacheKey_accountName(ctx context.Context, field graphql.CollectedField, obj *entities.BuildCacheKey) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BuildCacheKey_accountName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AccountName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BuildCacheKey_accountName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildCacheKey",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildCacheKey_createdBy(ctx context.Context, field graphql.CollectedField, obj *entities.BuildCacheKey) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BuildCacheKey_createdBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.BuildCacheKey().CreatedBy(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.KloudliteIoCommonCreatedOrUpdatedBy)
	fc.Result = res
	return ec.marshalNKloudlite_io__common_CreatedOrUpdatedBy2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoCommonCreatedOrUpdatedBy(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BuildCacheKey_createdBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildCacheKey",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "userEmail":
				return ec.fieldContext_Kloudlite_io__common_CreatedOrUpdatedBy_userEmail(ctx, field)
			case "userId":
				return ec.fieldContext_Kloudlite_io__common_CreatedOrUpdatedBy_userId(ctx, field)
			case "userName":
				return ec.fieldContext_Kloudlite_io__common_CreatedOrUpdatedBy_userName(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Kloudlite_io__common_CreatedOrUpdatedBy", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildCacheKey_creationTime(ctx context.Context, field graphql.CollectedField, obj *entities.BuildCacheKey) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BuildCacheKey_creationTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.BuildCacheKey().CreationTime(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNDate2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BuildCacheKey_creationTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildCacheKey",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildCacheKey_displayName(ctx context.Context, field graphql.CollectedField, obj *entities.BuildCacheKey) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BuildCacheKey_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BuildCacheKey_displayName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildCacheKey",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildCacheKey_id(ctx context.Context, field graphql.CollectedField, obj *entities.BuildCacheKey) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BuildCacheKey_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.BuildCacheKey().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BuildCacheKey_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildCacheKey",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildCacheKey_lastUpdatedBy(ctx context.Context, field graphql.CollectedField, obj *entities.BuildCacheKey) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BuildCacheKey_lastUpdatedBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.BuildCacheKey().LastUpdatedBy(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.KloudliteIoCommonCreatedOrUpdatedBy)
	fc.Result = res
	return ec.marshalNKloudlite_io__common_CreatedOrUpdatedBy2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoCommonCreatedOrUpdatedBy(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BuildCacheKey_lastUpdatedBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildCacheKey",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "userEmail":
				return ec.fieldContext_Kloudlite_io__common_CreatedOrUpdatedBy_userEmail(ctx, field)
			case "userId":
				return ec.fieldContext_Kloudlite_io__common_CreatedOrUpdatedBy_userId(ctx, field)
			case "userName":
				return ec.fieldContext_Kloudlite_io__common_CreatedOrUpdatedBy_userName(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Kloudlite_io__common_CreatedOrUpdatedBy", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildCacheKey_markedForDeletion(ctx context.Context, field graphql.CollectedField, obj *entities.BuildCacheKey) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BuildCacheKey_markedForDeletion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MarkedForDeletion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BuildCacheKey_markedForDeletion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildCacheKey",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildCacheKey_name(ctx context.Context, field graphql.CollectedField, obj *entities.BuildCacheKey) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BuildCacheKey_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BuildCacheKey_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildCacheKey",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildCacheKey_recordVersion(ctx context.Context, field graphql.CollectedField, obj *entities.BuildCacheKey) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BuildCacheKey_recordVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RecordVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BuildCacheKey_recordVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildCacheKey",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildCacheKey_updateTime(ctx context.Context, field graphql.CollectedField, obj *entities.BuildCacheKey) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BuildCacheKey_updateTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.BuildCacheKey().UpdateTime(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNDate2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BuildCacheKey_updateTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildCacheKey",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildCacheKey_volumeSizeInGB(ctx context.Context, field graphql.CollectedField, obj *entities.BuildCacheKey) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BuildCacheKey_volumeSizeInGB(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.BuildCacheKey().VolumeSizeInGb(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BuildCacheKey_volumeSizeInGB(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildCacheKey",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildCacheKeyEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *model.BuildCacheKeyEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BuildCacheKeyEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BuildCacheKeyEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildCacheKeyEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildCacheKeyEdge_node(ctx context.Context, field graphql.CollectedField, obj *model.BuildCacheKeyEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BuildCacheKeyEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*entities.BuildCacheKey)
	fc.Result = res
	return ec.marshalNBuildCacheKey2kloudliteioappscontainerregistryinternaldomainentitiesBuildCacheKey(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BuildCacheKeyEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildCacheKeyEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "accountName":
				return ec.fieldContext_BuildCacheKey_accountName(ctx, field)
			case "createdBy":
				return ec.fieldContext_BuildCacheKey_createdBy(ctx, field)
			case "creationTime":
				return ec.fieldContext_BuildCacheKey_creationTime(ctx, field)
			case "displayName":
				return ec.fieldContext_BuildCacheKey_displayName(ctx, field)
			case "id":
				return ec.fieldContext_BuildCacheKey_id(ctx, field)
			case "lastUpdatedBy":
				return ec.fieldContext_BuildCacheKey_lastUpdatedBy(ctx, field)
			case "markedForDeletion":
				return ec.fieldContext_BuildCacheKey_markedForDeletion(ctx, field)
			case "name":
				return ec.fieldContext_BuildCacheKey_name(ctx, field)
			case "recordVersion":
				return ec.fieldContext_BuildCacheKey_recordVersion(ctx, field)
			case "updateTime":
				return ec.fieldContext_BuildCacheKey_updateTime(ctx, field)
			case "volumeSizeInGB":
				return ec.fieldContext_BuildCacheKey_volumeSizeInGB(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BuildCacheKey", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildCacheKeyPaginatedRecords_edges(ctx context.Context, field graphql.CollectedField, obj *model.BuildCacheKeyPaginatedRecords) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BuildCacheKeyPaginatedRecords_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.BuildCacheKeyEdge)
	fc.Result = res
	return ec.marshalNBuildCacheKeyEdge2kloudliteioappscontainerregistryinternalappgraphmodelBuildCacheKeyEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BuildCacheKeyPaginatedRecords_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildCacheKeyPaginatedRecords",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cursor":
				return ec.fieldContext_BuildCacheKeyEdge_cursor(ctx, field)
			case "node":
				return ec.fieldContext_BuildCacheKeyEdge_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BuildCacheKeyEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildCacheKeyPaginatedRecords_pageInfo(ctx context.Context, field graphql.CollectedField, obj *model.BuildCacheKeyPaginatedRecords) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BuildCacheKeyPaginatedRecords_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2kloudliteioappscontainerregistryinternalappgraphmodelPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BuildCacheKeyPaginatedRecords_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildCacheKeyPaginatedRecords",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildCacheKeyPaginatedRecords_totalCount(ctx context.Context, field graphql.CollectedField, obj *model.BuildCacheKeyPaginatedRecords) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BuildCacheKeyPaginatedRecords_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BuildCacheKeyPaginatedRecords_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildCacheKeyPaginatedRecords",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *model.BuildEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BuildEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BuildEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildEdge_node(ctx context.Context, field graphql.CollectedField, obj *model.BuildEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BuildEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*entities.Build)
	fc.Result = res
	return ec.marshalNBuild2kloudliteioappscontainerregistryinternaldomainentitiesBuild(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BuildEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "accountName":
				return ec.fieldContext_Build_accountName(ctx, field)
			case "buildCacheId":
				return ec.fieldContext_Build_buildCacheId(ctx, field)
			case "buildData":
				return ec.fieldContext_Build_buildData(ctx, field)
			case "createdBy":
				return ec.fieldContext_Build_createdBy(ctx, field)
			case "creationTime":
				return ec.fieldContext_Build_creationTime(ctx, field)
			case "credUser":
				return ec.fieldContext_Build_credUser(ctx, field)
			case "errorMessages":
				return ec.fieldContext_Build_errorMessages(ctx, field)
			case "id":
				return ec.fieldContext_Build_id(ctx, field)
			case "lastUpdatedBy":
				return ec.fieldContext_Build_lastUpdatedBy(ctx, field)
			case "markedForDeletion":
				return ec.fieldContext_Build_markedForDeletion(ctx, field)
			case "name":
				return ec.fieldContext_Build_name(ctx, field)
			case "recordVersion":
				return ec.fieldContext_Build_recordVersion(ctx, field)
			case "repository":
				return ec.fieldContext_Build_repository(ctx, field)
			case "source":
				return ec.fieldContext_Build_source(ctx, field)
			case "status":
				return ec.fieldContext_Build_status(ctx, field)
			case "tags":
				return ec.fieldContext_Build_tags(ctx, field)
			case "updateTime":
				return ec.fieldContext_Build_updateTime(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Build", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildPaginatedRecords_edges(ctx context.Context, field graphql.CollectedField, obj *model.BuildPaginatedRecords) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BuildPaginatedRecords_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.BuildEdge)
	fc.Result = res
	return ec.marshalNBuildEdge2kloudliteioappscontainerregistryinternalappgraphmodelBuildEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BuildPaginatedRecords_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildPaginatedRecords",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cursor":
				return ec.fieldContext_BuildEdge_cursor(ctx, field)
			case "node":
				return ec.fieldContext_BuildEdge_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BuildEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildPaginatedRecords_pageInfo(ctx context.Context, field graphql.CollectedField, obj *model.BuildPaginatedRecords) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BuildPaginatedRecords_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2kloudliteioappscontainerregistryinternalappgraphmodelPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BuildPaginatedRecords_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildPaginatedRecords",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildPaginatedRecords_totalCount(ctx context.Context, field graphql.CollectedField, obj *model.BuildPaginatedRecords) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BuildPaginatedRecords_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BuildPaginatedRecords_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildPaginatedRecords",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CRCheckNameAvailabilityOutput_result(ctx context.Context, field graphql.CollectedField, obj *domain.CheckNameAvailabilityOutput) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CRCheckNameAvailabilityOutput_result(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Result, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CRCheckNameAvailabilityOutput_result(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CRCheckNameAvailabilityOutput",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CRCheckNameAvailabilityOutput_suggestedNames(ctx context.Context, field graphql.CollectedField, obj *domain.CheckNameAvailabilityOutput) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CRCheckNameAvailabilityOutput_suggestedNames(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SuggestedNames, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CRCheckNameAvailabilityOutput_suggestedNames(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CRCheckNameAvailabilityOutput",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Credential_access(ctx context.Context, field graphql.CollectedField, obj *entities.Credential) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Credential_access(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Credential().Access(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesRepoAccess)
	fc.Result = res
	return ec.marshalNKloudlite_io__apps__container___registry__internal__domain__entities_RepoAccess2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoAppsContainerRegistryInternalDomainEntitiesRepoAccess(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Credential_access(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Credential",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Kloudlite_io__apps__container___registry__internal__domain__entities_RepoAccess does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Credential_accountName(ctx context.Context, field graphql.CollectedField, obj *entities.Credential) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Credential_accountName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AccountName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Credential_accountName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Credential",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Credential_createdBy(ctx context.Context, field graphql.CollectedField, obj *entities.Credential) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Credential_createdBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Credential().CreatedBy(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.KloudliteIoCommonCreatedOrUpdatedBy)
	fc.Result = res
	return ec.marshalNKloudlite_io__common_CreatedOrUpdatedBy2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoCommonCreatedOrUpdatedBy(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Credential_createdBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Credential",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "userEmail":
				return ec.fieldContext_Kloudlite_io__common_CreatedOrUpdatedBy_userEmail(ctx, field)
			case "userId":
				return ec.fieldContext_Kloudlite_io__common_CreatedOrUpdatedBy_userId(ctx, field)
			case "userName":
				return ec.fieldContext_Kloudlite_io__common_CreatedOrUpdatedBy_userName(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Kloudlite_io__common_CreatedOrUpdatedBy", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Credential_creationTime(ctx context.Context, field graphql.CollectedField, obj *entities.Credential) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Credential_creationTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Credential().CreationTime(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNDate2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Credential_creationTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Credential",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Credential_expiration(ctx context.Context, field graphql.CollectedField, obj *entities.Credential) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Credential_expiration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Credential().Expiration(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesExpiration)
	fc.Result = res
	return ec.marshalNKloudlite_io__apps__container___registry__internal__domain__entities_Expiration2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoAppsContainerRegistryInternalDomainEntitiesExpiration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Credential_expiration(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Credential",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "unit":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_Expiration_unit(ctx, field)
			case "value":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_Expiration_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Kloudlite_io__apps__container___registry__internal__domain__entities_Expiration", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Credential_id(ctx context.Context, field graphql.CollectedField, obj *entities.Credential) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Credential_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Credential().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Credential_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Credential",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Credential_lastUpdatedBy(ctx context.Context, field graphql.CollectedField, obj *entities.Credential) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Credential_lastUpdatedBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Credential().LastUpdatedBy(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.KloudliteIoCommonCreatedOrUpdatedBy)
	fc.Result = res
	return ec.marshalNKloudlite_io__common_CreatedOrUpdatedBy2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoCommonCreatedOrUpdatedBy(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Credential_lastUpdatedBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Credential",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "userEmail":
				return ec.fieldContext_Kloudlite_io__common_CreatedOrUpdatedBy_userEmail(ctx, field)
			case "userId":
				return ec.fieldContext_Kloudlite_io__common_CreatedOrUpdatedBy_userId(ctx, field)
			case "userName":
				return ec.fieldContext_Kloudlite_io__common_CreatedOrUpdatedBy_userName(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Kloudlite_io__common_CreatedOrUpdatedBy", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Credential_markedForDeletion(ctx context.Context, field graphql.CollectedField, obj *entities.Credential) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Credential_markedForDeletion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MarkedForDeletion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Credential_markedForDeletion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Credential",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Credential_name(ctx context.Context, field graphql.CollectedField, obj *entities.Credential) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Credential_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Credential_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Credential",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Credential_recordVersion(ctx context.Context, field graphql.CollectedField, obj *entities.Credential) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Credential_recordVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RecordVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Credential_recordVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Credential",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Credential_updateTime(ctx context.Context, field graphql.CollectedField, obj *entities.Credential) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Credential_updateTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Credential().UpdateTime(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNDate2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Credential_updateTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Credential",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Credential_username(ctx context.Context, field graphql.CollectedField, obj *entities.Credential) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Credential_username(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Credential_username(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Credential",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CredentialEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *model.CredentialEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CredentialEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CredentialEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CredentialEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CredentialEdge_node(ctx context.Context, field graphql.CollectedField, obj *model.CredentialEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CredentialEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*entities.Credential)
	fc.Result = res
	return ec.marshalNCredential2kloudliteioappscontainerregistryinternaldomainentitiesCredential(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CredentialEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CredentialEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "access":
				return ec.fieldContext_Credential_access(ctx, field)
			case "accountName":
				return ec.fieldContext_Credential_accountName(ctx, field)
			case "createdBy":
				return ec.fieldContext_Credential_createdBy(ctx, field)
			case "creationTime":
				return ec.fieldContext_Credential_creationTime(ctx, field)
			case "expiration":
				return ec.fieldContext_Credential_expiration(ctx, field)
			case "id":
				return ec.fieldContext_Credential_id(ctx, field)
			case "lastUpdatedBy":
				return ec.fieldContext_Credential_lastUpdatedBy(ctx, field)
			case "markedForDeletion":
				return ec.fieldContext_Credential_markedForDeletion(ctx, field)
			case "name":
				return ec.fieldContext_Credential_name(ctx, field)
			case "recordVersion":
				return ec.fieldContext_Credential_recordVersion(ctx, field)
			case "updateTime":
				return ec.fieldContext_Credential_updateTime(ctx, field)
			case "username":
				return ec.fieldContext_Credential_username(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Credential", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CredentialPaginatedRecords_edges(ctx context.Context, field graphql.CollectedField, obj *model.CredentialPaginatedRecords) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CredentialPaginatedRecords_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.CredentialEdge)
	fc.Result = res
	return ec.marshalNCredentialEdge2kloudliteioappscontainerregistryinternalappgraphmodelCredentialEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CredentialPaginatedRecords_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CredentialPaginatedRecords",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cursor":
				return ec.fieldContext_CredentialEdge_cursor(ctx, field)
			case "node":
				return ec.fieldContext_CredentialEdge_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CredentialEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CredentialPaginatedRecords_pageInfo(ctx context.Context, field graphql.CollectedField, obj *model.CredentialPaginatedRecords) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CredentialPaginatedRecords_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2kloudliteioappscontainerregistryinternalappgraphmodelPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CredentialPaginatedRecords_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CredentialPaginatedRecords",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CredentialPaginatedRecords_totalCount(ctx context.Context, field graphql.CollectedField, obj *model.CredentialPaginatedRecords) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CredentialPaginatedRecords_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CredentialPaginatedRecords_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CredentialPaginatedRecords",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CursorPagination_after(ctx context.Context, field graphql.CollectedField, obj *repos.CursorPagination) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CursorPagination_after(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.After, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CursorPagination_after(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CursorPagination",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CursorPagination_before(ctx context.Context, field graphql.CollectedField, obj *repos.CursorPagination) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CursorPagination_before(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Before, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CursorPagination_before(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CursorPagination",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CursorPagination_first(ctx context.Context, field graphql.CollectedField, obj *repos.CursorPagination) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CursorPagination_first(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.First, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int64)
	fc.Result = res
	return ec.marshalOInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CursorPagination_first(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CursorPagination",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CursorPagination_last(ctx context.Context, field graphql.CollectedField, obj *repos.CursorPagination) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CursorPagination_last(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Last, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int64)
	fc.Result = res
	return ec.marshalOInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CursorPagination_last(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CursorPagination",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CursorPagination_orderBy(ctx context.Context, field graphql.CollectedField, obj *repos.CursorPagination) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CursorPagination_orderBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OrderBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CursorPagination_orderBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CursorPagination",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CursorPagination_sortDirection(ctx context.Context, field graphql.CollectedField, obj *repos.CursorPagination) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CursorPagination_sortDirection(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SortDirection, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(repos.SortDirection)
	fc.Result = res
	return ec.marshalOCursorPaginationSortDirection2kloudliteiopkgreposSortDirection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CursorPagination_sortDirection(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CursorPagination",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CursorPaginationSortDirection does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Digest_accountName(ctx context.Context, field graphql.CollectedField, obj *entities.Digest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Digest_accountName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AccountName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Digest_accountName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Digest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Digest_actor(ctx context.Context, field graphql.CollectedField, obj *entities.Digest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Digest_actor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Actor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Digest_actor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Digest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Digest_creationTime(ctx context.Context, field graphql.CollectedField, obj *entities.Digest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Digest_creationTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Digest().CreationTime(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNDate2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Digest_creationTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Digest",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Digest_deleting(ctx context.Context, field graphql.CollectedField, obj *entities.Digest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Digest_deleting(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Deleting, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Digest_deleting(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Digest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Digest_digest(ctx context.Context, field graphql.CollectedField, obj *entities.Digest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Digest_digest(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Digest, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Digest_digest(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Digest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Digest_id(ctx context.Context, field graphql.CollectedField, obj *entities.Digest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Digest_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Digest().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Digest_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Digest",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Digest_length(ctx context.Context, field graphql.CollectedField, obj *entities.Digest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Digest_length(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Length, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Digest_length(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Digest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Digest_markedForDeletion(ctx context.Context, field graphql.CollectedField, obj *entities.Digest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Digest_markedForDeletion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MarkedForDeletion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Digest_markedForDeletion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Digest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Digest_mediaType(ctx context.Context, field graphql.CollectedField, obj *entities.Digest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Digest_mediaType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MediaType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Digest_mediaType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Digest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Digest_recordVersion(ctx context.Context, field graphql.CollectedField, obj *entities.Digest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Digest_recordVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RecordVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Digest_recordVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Digest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Digest_repository(ctx context.Context, field graphql.CollectedField, obj *entities.Digest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Digest_repository(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Repository, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Digest_repository(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Digest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Digest_size(ctx context.Context, field graphql.CollectedField, obj *entities.Digest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Digest_size(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Size, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Digest_size(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Digest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Digest_tags(ctx context.Context, field graphql.CollectedField, obj *entities.Digest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Digest_tags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tags, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Digest_tags(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Digest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Digest_updateTime(ctx context.Context, field graphql.CollectedField, obj *entities.Digest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Digest_updateTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Digest().UpdateTime(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNDate2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Digest_updateTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Digest",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Digest_url(ctx context.Context, field graphql.CollectedField, obj *entities.Digest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Digest_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Digest_url(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Digest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DigestEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *model.DigestEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DigestEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DigestEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DigestEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DigestEdge_node(ctx context.Context, field graphql.CollectedField, obj *model.DigestEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DigestEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*entities.Digest)
	fc.Result = res
	return ec.marshalNDigest2kloudliteioappscontainerregistryinternaldomainentitiesDigest(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DigestEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DigestEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "accountName":
				return ec.fieldContext_Digest_accountName(ctx, field)
			case "actor":
				return ec.fieldContext_Digest_actor(ctx, field)
			case "creationTime":
				return ec.fieldContext_Digest_creationTime(ctx, field)
			case "deleting":
				return ec.fieldContext_Digest_deleting(ctx, field)
			case "digest":
				return ec.fieldContext_Digest_digest(ctx, field)
			case "id":
				return ec.fieldContext_Digest_id(ctx, field)
			case "length":
				return ec.fieldContext_Digest_length(ctx, field)
			case "markedForDeletion":
				return ec.fieldContext_Digest_markedForDeletion(ctx, field)
			case "mediaType":
				return ec.fieldContext_Digest_mediaType(ctx, field)
			case "recordVersion":
				return ec.fieldContext_Digest_recordVersion(ctx, field)
			case "repository":
				return ec.fieldContext_Digest_repository(ctx, field)
			case "size":
				return ec.fieldContext_Digest_size(ctx, field)
			case "tags":
				return ec.fieldContext_Digest_tags(ctx, field)
			case "updateTime":
				return ec.fieldContext_Digest_updateTime(ctx, field)
			case "url":
				return ec.fieldContext_Digest_url(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Digest", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DigestPaginatedRecords_edges(ctx context.Context, field graphql.CollectedField, obj *model.DigestPaginatedRecords) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DigestPaginatedRecords_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.DigestEdge)
	fc.Result = res
	return ec.marshalNDigestEdge2kloudliteioappscontainerregistryinternalappgraphmodelDigestEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DigestPaginatedRecords_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DigestPaginatedRecords",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cursor":
				return ec.fieldContext_DigestEdge_cursor(ctx, field)
			case "node":
				return ec.fieldContext_DigestEdge_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DigestEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DigestPaginatedRecords_pageInfo(ctx context.Context, field graphql.CollectedField, obj *model.DigestPaginatedRecords) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DigestPaginatedRecords_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2kloudliteioappscontainerregistryinternalappgraphmodelPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DigestPaginatedRecords_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DigestPaginatedRecords",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DigestPaginatedRecords_totalCount(ctx context.Context, field graphql.CollectedField, obj *model.DigestPaginatedRecords) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DigestPaginatedRecords_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DigestPaginatedRecords_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DigestPaginatedRecords",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GitBranch_name(ctx context.Context, field graphql.CollectedField, obj *entities.GitBranch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GitBranch_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GitBranch_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GitBranch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GitBranch_protected(ctx context.Context, field graphql.CollectedField, obj *entities.GitBranch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GitBranch_protected(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Protected, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GitBranch_protected(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GitBranch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubBranch_name(ctx context.Context, field graphql.CollectedField, obj *model.GithubBranch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubBranch_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubBranch_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubBranch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubBranch_protected(ctx context.Context, field graphql.CollectedField, obj *model.GithubBranch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubBranch_protected(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Protected, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubBranch_protected(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubBranch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubInstallation_account(ctx context.Context, field graphql.CollectedField, obj *entities.GithubInstallation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubInstallation_account(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.GithubInstallation().Account(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubUserAccount)
	fc.Result = res
	return ec.marshalOKloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubUserAccount(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubInstallation_account(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubInstallation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "avatarUrl":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount_avatarUrl(ctx, field)
			case "id":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount_id(ctx, field)
			case "login":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount_login(ctx, field)
			case "nodeId":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount_nodeId(ctx, field)
			case "type":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount_type(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubInstallation_appId(ctx context.Context, field graphql.CollectedField, obj *entities.GithubInstallation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubInstallation_appId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AppID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int64)
	fc.Result = res
	return ec.marshalOInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubInstallation_appId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubInstallation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubInstallation_id(ctx context.Context, field graphql.CollectedField, obj *entities.GithubInstallation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubInstallation_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int64)
	fc.Result = res
	return ec.marshalOInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubInstallation_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubInstallation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubInstallation_nodeId(ctx context.Context, field graphql.CollectedField, obj *entities.GithubInstallation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubInstallation_nodeId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NodeID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubInstallation_nodeId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubInstallation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubInstallation_repositoriesUrl(ctx context.Context, field graphql.CollectedField, obj *entities.GithubInstallation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubInstallation_repositoriesUrl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RepositoriesURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubInstallation_repositoriesUrl(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubInstallation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubInstallation_targetId(ctx context.Context, field graphql.CollectedField, obj *entities.GithubInstallation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubInstallation_targetId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TargetID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int64)
	fc.Result = res
	return ec.marshalOInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubInstallation_targetId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubInstallation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubInstallation_targetType(ctx context.Context, field graphql.CollectedField, obj *entities.GithubInstallation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubInstallation_targetType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TargetType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubInstallation_targetType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubInstallation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubListRepository_repositories(ctx context.Context, field graphql.CollectedField, obj *entities.GithubListRepository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubListRepository_repositories(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.GithubListRepository().Repositories(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubRepository)
	fc.Result = res
	return ec.marshalNKloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubRepository(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubListRepository_repositories(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubListRepository",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "archived":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_archived(ctx, field)
			case "cloneUrl":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_cloneUrl(ctx, field)
			case "createdAt":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_createdAt(ctx, field)
			case "defaultBranch":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_defaultBranch(ctx, field)
			case "description":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_description(ctx, field)
			case "disabled":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_disabled(ctx, field)
			case "fullName":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_fullName(ctx, field)
			case "gitignoreTemplate":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_gitignoreTemplate(ctx, field)
			case "gitUrl":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_gitUrl(ctx, field)
			case "htmlUrl":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_htmlUrl(ctx, field)
			case "id":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_id(ctx, field)
			case "language":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_language(ctx, field)
			case "masterBranch":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_masterBranch(ctx, field)
			case "mirrorUrl":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_mirrorUrl(ctx, field)
			case "name":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_name(ctx, field)
			case "node_id":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_node_id(ctx, field)
			case "permissions":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_permissions(ctx, field)
			case "private":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_private(ctx, field)
			case "pushedAt":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_pushedAt(ctx, field)
			case "size":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_size(ctx, field)
			case "team_id":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_team_id(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_updatedAt(ctx, field)
			case "url":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_url(ctx, field)
			case "visibility":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_visibility(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubListRepository_totalCount(ctx context.Context, field graphql.CollectedField, obj *entities.GithubListRepository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubListRepository_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubListRepository_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubListRepository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubSearchRepository_incompleteResults(ctx context.Context, field graphql.CollectedField, obj *entities.GithubSearchRepository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubSearchRepository_incompleteResults(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IncompleteResults, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubSearchRepository_incompleteResults(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubSearchRepository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubSearchRepository_repositories(ctx context.Context, field graphql.CollectedField, obj *entities.GithubSearchRepository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubSearchRepository_repositories(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.GithubSearchRepository().Repositories(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubRepository)
	fc.Result = res
	return ec.marshalNKloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubRepository(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubSearchRepository_repositories(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubSearchRepository",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "archived":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_archived(ctx, field)
			case "cloneUrl":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_cloneUrl(ctx, field)
			case "createdAt":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_createdAt(ctx, field)
			case "defaultBranch":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_defaultBranch(ctx, field)
			case "description":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_description(ctx, field)
			case "disabled":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_disabled(ctx, field)
			case "fullName":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_fullName(ctx, field)
			case "gitignoreTemplate":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_gitignoreTemplate(ctx, field)
			case "gitUrl":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_gitUrl(ctx, field)
			case "htmlUrl":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_htmlUrl(ctx, field)
			case "id":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_id(ctx, field)
			case "language":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_language(ctx, field)
			case "masterBranch":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_masterBranch(ctx, field)
			case "mirrorUrl":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_mirrorUrl(ctx, field)
			case "name":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_name(ctx, field)
			case "node_id":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_node_id(ctx, field)
			case "permissions":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_permissions(ctx, field)
			case "private":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_private(ctx, field)
			case "pushedAt":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_pushedAt(ctx, field)
			case "size":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_size(ctx, field)
			case "team_id":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_team_id(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_updatedAt(ctx, field)
			case "url":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_url(ctx, field)
			case "visibility":
				return ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_visibility(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubSearchRepository_total(ctx context.Context, field graphql.CollectedField, obj *entities.GithubSearchRepository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubSearchRepository_total(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubSearchRepository_total(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubSearchRepository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GitlabBranch_canPush(ctx context.Context, field graphql.CollectedField, obj *model.GitlabBranch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GitlabBranch_canPush(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CanPush, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GitlabBranch_canPush(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GitlabBranch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GitlabBranch_default(ctx context.Context, field graphql.CollectedField, obj *model.GitlabBranch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GitlabBranch_default(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Default, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GitlabBranch_default(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GitlabBranch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GitlabBranch_developersCanMerge(ctx context.Context, field graphql.CollectedField, obj *model.GitlabBranch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GitlabBranch_developersCanMerge(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DevelopersCanMerge, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GitlabBranch_developersCanMerge(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GitlabBranch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GitlabBranch_developersCanPush(ctx context.Context, field graphql.CollectedField, obj *model.GitlabBranch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GitlabBranch_developersCanPush(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DevelopersCanPush, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GitlabBranch_developersCanPush(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GitlabBranch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GitlabBranch_merged(ctx context.Context, field graphql.CollectedField, obj *model.GitlabBranch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GitlabBranch_merged(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Merged, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GitlabBranch_merged(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GitlabBranch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GitlabBranch_name(ctx context.Context, field graphql.CollectedField, obj *model.GitlabBranch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GitlabBranch_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GitlabBranch_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GitlabBranch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GitlabBranch_protected(ctx context.Context, field graphql.CollectedField, obj *model.GitlabBranch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GitlabBranch_protected(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Protected, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GitlabBranch_protected(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GitlabBranch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GitlabBranch_webUrl(ctx context.Context, field graphql.CollectedField, obj *model.GitlabBranch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GitlabBranch_webUrl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WebURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GitlabBranch_webUrl(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GitlabBranch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GitlabGroup_avatarUrl(ctx context.Context, field graphql.CollectedField, obj *entities.GitlabGroup) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GitlabGroup_avatarUrl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AvatarUrl, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GitlabGroup_avatarUrl(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GitlabGroup",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GitlabGroup_fullName(ctx context.Context, field graphql.CollectedField, obj *entities.GitlabGroup) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GitlabGroup_fullName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FullName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GitlabGroup_fullName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GitlabGroup",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GitlabGroup_id(ctx context.Context, field graphql.CollectedField, obj *entities.GitlabGroup) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GitlabGroup_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GitlabGroup_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GitlabGroup",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GitlabProject_archived(ctx context.Context, field graphql.CollectedField, obj *entities.GitlabProject) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GitlabProject_archived(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Archived, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GitlabProject_archived(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GitlabProject",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GitlabProject_avatarUrl(ctx context.Context, field graphql.CollectedField, obj *entities.GitlabProject) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GitlabProject_avatarUrl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AvatarURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GitlabProject_avatarUrl(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GitlabProject",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GitlabProject_createdAt(ctx context.Context, field graphql.CollectedField, obj *entities.GitlabProject) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GitlabProject_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.GitlabProject().CreatedAt(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalODate2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GitlabProject_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GitlabProject",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GitlabProject_creatorId(ctx context.Context, field graphql.CollectedField, obj *entities.GitlabProject) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GitlabProject_creatorId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatorID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GitlabProject_creatorId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GitlabProject",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GitlabProject_defaultBranch(ctx context.Context, field graphql.CollectedField, obj *entities.GitlabProject) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GitlabProject_defaultBranch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultBranch, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GitlabProject_defaultBranch(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GitlabProject",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GitlabProject_description(ctx context.Context, field graphql.CollectedField, obj *entities.GitlabProject) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GitlabProject_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GitlabProject_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GitlabProject",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GitlabProject_emptyRepo(ctx context.Context, field graphql.CollectedField, obj *entities.GitlabProject) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GitlabProject_emptyRepo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EmptyRepo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GitlabProject_emptyRepo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GitlabProject",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GitlabProject_httpUrlToRepo(ctx context.Context, field graphql.CollectedField, obj *entities.GitlabProject) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GitlabProject_httpUrlToRepo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HTTPURLToRepo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GitlabProject_httpUrlToRepo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GitlabProject",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GitlabProject_id(ctx context.Context, field graphql.CollectedField, obj *entities.GitlabProject) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GitlabProject_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GitlabProject_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GitlabProject",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GitlabProject_lastActivityAt(ctx context.Context, field graphql.CollectedField, obj *entities.GitlabProject) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GitlabProject_lastActivityAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.GitlabProject().LastActivityAt(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalODate2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GitlabProject_lastActivityAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GitlabProject",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GitlabProject_name(ctx context.Context, field graphql.CollectedField, obj *entities.GitlabProject) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GitlabProject_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GitlabProject_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GitlabProject",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GitlabProject_nameWithNamespace(ctx context.Context, field graphql.CollectedField, obj *entities.GitlabProject) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GitlabProject_nameWithNamespace(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NameWithNamespace, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GitlabProject_nameWithNamespace(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GitlabProject",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GitlabProject_path(ctx context.Context, field graphql.CollectedField, obj *entities.GitlabProject) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GitlabProject_path(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Path, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GitlabProject_path(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GitlabProject",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GitlabProject_pathWithNamespace(ctx context.Context, field graphql.CollectedField, obj *entities.GitlabProject) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GitlabProject_pathWithNamespace(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PathWithNamespace, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GitlabProject_pathWithNamespace(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GitlabProject",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GitlabProject_public(ctx context.Context, field graphql.CollectedField, obj *entities.GitlabProject) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GitlabProject_public(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Public, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GitlabProject_public(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GitlabProject",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GitlabProject_sshUrlToRepo(ctx context.Context, field graphql.CollectedField, obj *entities.GitlabProject) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GitlabProject_sshUrlToRepo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SSHURLToRepo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GitlabProject_sshUrlToRepo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GitlabProject",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GitlabProject_tagList(ctx context.Context, field graphql.CollectedField, obj *entities.GitlabProject) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GitlabProject_tagList(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TagList, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GitlabProject_tagList(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GitlabProject",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GitlabProject_topics(ctx context.Context, field graphql.CollectedField, obj *entities.GitlabProject) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GitlabProject_topics(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Topics, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GitlabProject_topics(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GitlabProject",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GitlabProject_webUrl(ctx context.Context, field graphql.CollectedField, obj *entities.GitlabProject) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GitlabProject_webUrl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WebURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GitlabProject_webUrl(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GitlabProject",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_BuildOptions_buildArgs(ctx context.Context, field graphql.CollectedField, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesBuildOptions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_BuildOptions_buildArgs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BuildArgs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalNMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_BuildOptions_buildArgs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Kloudlite_io__apps__container___registry__internal__domain__entities_BuildOptions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_BuildOptions_buildContexts(ctx context.Context, field graphql.CollectedField, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesBuildOptions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_BuildOptions_buildContexts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BuildContexts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalNMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_BuildOptions_buildContexts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Kloudlite_io__apps__container___registry__internal__domain__entities_BuildOptions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_BuildOptions_contextDir(ctx context.Context, field graphql.CollectedField, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesBuildOptions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_BuildOptions_contextDir(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ContextDir, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_BuildOptions_contextDir(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Kloudlite_io__apps__container___registry__internal__domain__entities_BuildOptions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_BuildOptions_dockerfileContent(ctx context.Context, field graphql.CollectedField, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesBuildOptions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_BuildOptions_dockerfileContent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DockerfileContent, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_BuildOptions_dockerfileContent(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Kloudlite_io__apps__container___registry__internal__domain__entities_BuildOptions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_BuildOptions_dockerfilePath(ctx context.Context, field graphql.CollectedField, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesBuildOptions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_BuildOptions_dockerfilePath(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DockerfilePath, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_BuildOptions_dockerfilePath(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Kloudlite_io__apps__container___registry__internal__domain__entities_BuildOptions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_BuildOptions_targetPlatforms(ctx context.Context, field graphql.CollectedField, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesBuildOptions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_BuildOptions_targetPlatforms(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TargetPlatforms, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_BuildOptions_targetPlatforms(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Kloudlite_io__apps__container___registry__internal__domain__entities_BuildOptions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_Expiration_unit(ctx context.Context, field graphql.CollectedField, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesExpiration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_Expiration_unit(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Unit, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesExpirationUnit)
	fc.Result = res
	return ec.marshalNKloudlite_io__apps__container___registry__internal__domain__entities_ExpirationUnit2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoAppsContainerRegistryInternalDomainEntitiesExpirationUnit(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_Expiration_unit(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Kloudlite_io__apps__container___registry__internal__domain__entities_Expiration",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Kloudlite_io__apps__container___registry__internal__domain__entities_ExpirationUnit does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_Expiration_value(ctx context.Context, field graphql.CollectedField, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesExpiration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_Expiration_value(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_Expiration_value(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Kloudlite_io__apps__container___registry__internal__domain__entities_Expiration",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_GitSource_branch(ctx context.Context, field graphql.CollectedField, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGitSource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GitSource_branch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Branch, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GitSource_branch(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Kloudlite_io__apps__container___registry__internal__domain__entities_GitSource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_GitSource_provider(ctx context.Context, field graphql.CollectedField, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGitSource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GitSource_provider(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Provider, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGitProvider)
	fc.Result = res
	return ec.marshalNKloudlite_io__apps__container___registry__internal__domain__entities_GitProvider2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoAppsContainerRegistryInternalDomainEntitiesGitProvider(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GitSource_provider(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Kloudlite_io__apps__container___registry__internal__domain__entities_GitSource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Kloudlite_io__apps__container___registry__internal__domain__entities_GitProvider does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_GitSource_repository(ctx context.Context, field graphql.CollectedField, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGitSource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GitSource_repository(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Repository, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GitSource_repository(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Kloudlite_io__apps__container___registry__internal__domain__entities_GitSource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_GitSource_webhookId(ctx context.Context, field graphql.CollectedField, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGitSource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GitSource_webhookId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WebhookID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GitSource_webhookId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Kloudlite_io__apps__container___registry__internal__domain__entities_GitSource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_archived(ctx context.Context, field graphql.CollectedField, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubRepository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_archived(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Archived, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_archived(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_cloneUrl(ctx context.Context, field graphql.CollectedField, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubRepository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_cloneUrl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CloneURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_cloneUrl(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubRepository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalODate2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_defaultBranch(ctx context.Context, field graphql.CollectedField, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubRepository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_defaultBranch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultBranch, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_defaultBranch(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_description(ctx context.Context, field graphql.CollectedField, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubRepository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_disabled(ctx context.Context, field graphql.CollectedField, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubRepository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_disabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Disabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_disabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_fullName(ctx context.Context, field graphql.CollectedField, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubRepository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_fullName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FullName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_fullName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_gitignoreTemplate(ctx context.Context, field graphql.CollectedField, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubRepository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_gitignoreTemplate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GitignoreTemplate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_gitignoreTemplate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_gitUrl(ctx context.Context, field graphql.CollectedField, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubRepository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_gitUrl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GitURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_gitUrl(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_htmlUrl(ctx context.Context, field graphql.CollectedField, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubRepository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_htmlUrl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HTMLURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_htmlUrl(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_id(ctx context.Context, field graphql.CollectedField, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubRepository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_language(ctx context.Context, field graphql.CollectedField, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubRepository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_language(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Language, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_language(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_masterBranch(ctx context.Context, field graphql.CollectedField, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubRepository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_masterBranch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MasterBranch, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_masterBranch(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_mirrorUrl(ctx context.Context, field graphql.CollectedField, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubRepository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_mirrorUrl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MirrorURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_mirrorUrl(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_name(ctx context.Context, field graphql.CollectedField, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubRepository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_node_id(ctx context.Context, field graphql.CollectedField, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubRepository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_node_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NodeID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_node_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_permissions(ctx context.Context, field graphql.CollectedField, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubRepository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_permissions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Permissions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_permissions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_private(ctx context.Context, field graphql.CollectedField, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubRepository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_private(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Private, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_private(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_pushedAt(ctx context.Context, field graphql.CollectedField, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubRepository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_pushedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PushedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalODate2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_pushedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_size(ctx context.Context, field graphql.CollectedField, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubRepository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_size(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Size, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_size(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_team_id(ctx context.Context, field graphql.CollectedField, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubRepository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_team_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TeamID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_team_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_updatedAt(ctx context.Context, field graphql.CollectedField, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubRepository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalODate2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_url(ctx context.Context, field graphql.CollectedField, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubRepository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_url(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_visibility(ctx context.Context, field graphql.CollectedField, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubRepository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_visibility(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Visibility, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_visibility(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount_avatarUrl(ctx context.Context, field graphql.CollectedField, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubUserAccount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount_avatarUrl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AvatarURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount_avatarUrl(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount_id(ctx context.Context, field graphql.CollectedField, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubUserAccount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount_login(ctx context.Context, field graphql.CollectedField, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubUserAccount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount_login(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Login, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount_login(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount_nodeId(ctx context.Context, field graphql.CollectedField, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubUserAccount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount_nodeId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NodeID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount_nodeId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount_type(ctx context.Context, field graphql.CollectedField, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubUserAccount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Kloudlite_io__common_CreatedOrUpdatedBy_userEmail(ctx context.Context, field graphql.CollectedField, obj *model.KloudliteIoCommonCreatedOrUpdatedBy) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Kloudlite_io__common_CreatedOrUpdatedBy_userEmail(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserEmail, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Kloudlite_io__common_CreatedOrUpdatedBy_userEmail(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Kloudlite_io__common_CreatedOrUpdatedBy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Kloudlite_io__common_CreatedOrUpdatedBy_userId(ctx context.Context, field graphql.CollectedField, obj *model.KloudliteIoCommonCreatedOrUpdatedBy) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Kloudlite_io__common_CreatedOrUpdatedBy_userId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Kloudlite_io__common_CreatedOrUpdatedBy_userId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Kloudlite_io__common_CreatedOrUpdatedBy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Kloudlite_io__common_CreatedOrUpdatedBy_userName(ctx context.Context, field graphql.CollectedField, obj *model.KloudliteIoCommonCreatedOrUpdatedBy) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Kloudlite_io__common_CreatedOrUpdatedBy_userName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Kloudlite_io__common_CreatedOrUpdatedBy_userName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Kloudlite_io__common_CreatedOrUpdatedBy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchFilter_array(ctx context.Context, field graphql.CollectedField, obj *repos.MatchFilter) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchFilter_array(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Array, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]any)
	fc.Result = res
	return ec.marshalOAny2interface(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchFilter_array(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchFilter",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Any does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchFilter_exact(ctx context.Context, field graphql.CollectedField, obj *repos.MatchFilter) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchFilter_exact(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Exact, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(any)
	fc.Result = res
	return ec.marshalOAny2interface(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchFilter_exact(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchFilter",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Any does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchFilter_matchType(ctx context.Context, field graphql.CollectedField, obj *repos.MatchFilter) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchFilter_matchType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MatchType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(repos.MatchType)
	fc.Result = res
	return ec.marshalNMatchFilterMatchType2kloudliteiopkgreposMatchType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchFilter_matchType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchFilter",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MatchFilterMatchType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MatchFilter_regex(ctx context.Context, field graphql.CollectedField, obj *repos.MatchFilter) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MatchFilter_regex(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Regex, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MatchFilter_regex(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MatchFilter",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_cr_createRepo(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_cr_createRepo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CrCreateRepo(rctx, fc.Args["repository"].(entities.Repository))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedInAndVerified == nil {
				return nil, errors.New("directive isLoggedInAndVerified is not implemented")
			}
			return ec.directives.IsLoggedInAndVerified(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.HasAccount == nil {
				return nil, errors.New("directive hasAccount is not implemented")
			}
			return ec.directives.HasAccount(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*entities.Repository); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *kloudlite.io/apps/container-registry/internal/domain/entities.Repository`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*entities.Repository)
	fc.Result = res
	return ec.marshalORepository2kloudliteioappscontainerregistryinternaldomainentitiesRepository(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_cr_createRepo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "accountName":
				return ec.fieldContext_Repository_accountName(ctx, field)
			case "createdBy":
				return ec.fieldContext_Repository_createdBy(ctx, field)
			case "creationTime":
				return ec.fieldContext_Repository_creationTime(ctx, field)
			case "id":
				return ec.fieldContext_Repository_id(ctx, field)
			case "lastUpdatedBy":
				return ec.fieldContext_Repository_lastUpdatedBy(ctx, field)
			case "markedForDeletion":
				return ec.fieldContext_Repository_markedForDeletion(ctx, field)
			case "name":
				return ec.fieldContext_Repository_name(ctx, field)
			case "recordVersion":
				return ec.fieldContext_Repository_recordVersion(ctx, field)
			case "updateTime":
				return ec.fieldContext_Repository_updateTime(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Repository", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_cr_createRepo_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_cr_createCred(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_cr_createCred(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CrCreateCred(rctx, fc.Args["credential"].(entities.Credential))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedInAndVerified == nil {
				return nil, errors.New("directive isLoggedInAndVerified is not implemented")
			}
			return ec.directives.IsLoggedInAndVerified(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.HasAccount == nil {
				return nil, errors.New("directive hasAccount is not implemented")
			}
			return ec.directives.HasAccount(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*entities.Credential); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *kloudlite.io/apps/container-registry/internal/domain/entities.Credential`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*entities.Credential)
	fc.Result = res
	return ec.marshalOCredential2kloudliteioappscontainerregistryinternaldomainentitiesCredential(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_cr_createCred(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "access":
				return ec.fieldContext_Credential_access(ctx, field)
			case "accountName":
				return ec.fieldContext_Credential_accountName(ctx, field)
			case "createdBy":
				return ec.fieldContext_Credential_createdBy(ctx, field)
			case "creationTime":
				return ec.fieldContext_Credential_creationTime(ctx, field)
			case "expiration":
				return ec.fieldContext_Credential_expiration(ctx, field)
			case "id":
				return ec.fieldContext_Credential_id(ctx, field)
			case "lastUpdatedBy":
				return ec.fieldContext_Credential_lastUpdatedBy(ctx, field)
			case "markedForDeletion":
				return ec.fieldContext_Credential_markedForDeletion(ctx, field)
			case "name":
				return ec.fieldContext_Credential_name(ctx, field)
			case "recordVersion":
				return ec.fieldContext_Credential_recordVersion(ctx, field)
			case "updateTime":
				return ec.fieldContext_Credential_updateTime(ctx, field)
			case "username":
				return ec.fieldContext_Credential_username(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Credential", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_cr_createCred_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_cr_deleteRepo(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_cr_deleteRepo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CrDeleteRepo(rctx, fc.Args["name"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedInAndVerified == nil {
				return nil, errors.New("directive isLoggedInAndVerified is not implemented")
			}
			return ec.directives.IsLoggedInAndVerified(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.HasAccount == nil {
				return nil, errors.New("directive hasAccount is not implemented")
			}
			return ec.directives.HasAccount(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_cr_deleteRepo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_cr_deleteRepo_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_cr_deleteCred(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_cr_deleteCred(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CrDeleteCred(rctx, fc.Args["username"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedInAndVerified == nil {
				return nil, errors.New("directive isLoggedInAndVerified is not implemented")
			}
			return ec.directives.IsLoggedInAndVerified(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.HasAccount == nil {
				return nil, errors.New("directive hasAccount is not implemented")
			}
			return ec.directives.HasAccount(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_cr_deleteCred(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_cr_deleteCred_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_cr_deleteDigest(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_cr_deleteDigest(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CrDeleteDigest(rctx, fc.Args["repoName"].(string), fc.Args["digest"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedInAndVerified == nil {
				return nil, errors.New("directive isLoggedInAndVerified is not implemented")
			}
			return ec.directives.IsLoggedInAndVerified(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.HasAccount == nil {
				return nil, errors.New("directive hasAccount is not implemented")
			}
			return ec.directives.HasAccount(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_cr_deleteDigest(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_cr_deleteDigest_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_cr_addBuild(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_cr_addBuild(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CrAddBuild(rctx, fc.Args["build"].(entities.Build))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedInAndVerified == nil {
				return nil, errors.New("directive isLoggedInAndVerified is not implemented")
			}
			return ec.directives.IsLoggedInAndVerified(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.HasAccount == nil {
				return nil, errors.New("directive hasAccount is not implemented")
			}
			return ec.directives.HasAccount(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*entities.Build); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *kloudlite.io/apps/container-registry/internal/domain/entities.Build`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*entities.Build)
	fc.Result = res
	return ec.marshalOBuild2kloudliteioappscontainerregistryinternaldomainentitiesBuild(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_cr_addBuild(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "accountName":
				return ec.fieldContext_Build_accountName(ctx, field)
			case "buildCacheId":
				return ec.fieldContext_Build_buildCacheId(ctx, field)
			case "buildData":
				return ec.fieldContext_Build_buildData(ctx, field)
			case "createdBy":
				return ec.fieldContext_Build_createdBy(ctx, field)
			case "creationTime":
				return ec.fieldContext_Build_creationTime(ctx, field)
			case "credUser":
				return ec.fieldContext_Build_credUser(ctx, field)
			case "errorMessages":
				return ec.fieldContext_Build_errorMessages(ctx, field)
			case "id":
				return ec.fieldContext_Build_id(ctx, field)
			case "lastUpdatedBy":
				return ec.fieldContext_Build_lastUpdatedBy(ctx, field)
			case "markedForDeletion":
				return ec.fieldContext_Build_markedForDeletion(ctx, field)
			case "name":
				return ec.fieldContext_Build_name(ctx, field)
			case "recordVersion":
				return ec.fieldContext_Build_recordVersion(ctx, field)
			case "repository":
				return ec.fieldContext_Build_repository(ctx, field)
			case "source":
				return ec.fieldContext_Build_source(ctx, field)
			case "status":
				return ec.fieldContext_Build_status(ctx, field)
			case "tags":
				return ec.fieldContext_Build_tags(ctx, field)
			case "updateTime":
				return ec.fieldContext_Build_updateTime(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Build", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_cr_addBuild_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_cr_updateBuild(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_cr_updateBuild(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CrUpdateBuild(rctx, fc.Args["id"].(repos.ID), fc.Args["build"].(entities.Build))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedInAndVerified == nil {
				return nil, errors.New("directive isLoggedInAndVerified is not implemented")
			}
			return ec.directives.IsLoggedInAndVerified(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.HasAccount == nil {
				return nil, errors.New("directive hasAccount is not implemented")
			}
			return ec.directives.HasAccount(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*entities.Build); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *kloudlite.io/apps/container-registry/internal/domain/entities.Build`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*entities.Build)
	fc.Result = res
	return ec.marshalOBuild2kloudliteioappscontainerregistryinternaldomainentitiesBuild(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_cr_updateBuild(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "accountName":
				return ec.fieldContext_Build_accountName(ctx, field)
			case "buildCacheId":
				return ec.fieldContext_Build_buildCacheId(ctx, field)
			case "buildData":
				return ec.fieldContext_Build_buildData(ctx, field)
			case "createdBy":
				return ec.fieldContext_Build_createdBy(ctx, field)
			case "creationTime":
				return ec.fieldContext_Build_creationTime(ctx, field)
			case "credUser":
				return ec.fieldContext_Build_credUser(ctx, field)
			case "errorMessages":
				return ec.fieldContext_Build_errorMessages(ctx, field)
			case "id":
				return ec.fieldContext_Build_id(ctx, field)
			case "lastUpdatedBy":
				return ec.fieldContext_Build_lastUpdatedBy(ctx, field)
			case "markedForDeletion":
				return ec.fieldContext_Build_markedForDeletion(ctx, field)
			case "name":
				return ec.fieldContext_Build_name(ctx, field)
			case "recordVersion":
				return ec.fieldContext_Build_recordVersion(ctx, field)
			case "repository":
				return ec.fieldContext_Build_repository(ctx, field)
			case "source":
				return ec.fieldContext_Build_source(ctx, field)
			case "status":
				return ec.fieldContext_Build_status(ctx, field)
			case "tags":
				return ec.fieldContext_Build_tags(ctx, field)
			case "updateTime":
				return ec.fieldContext_Build_updateTime(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Build", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_cr_updateBuild_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_cr_deleteBuild(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_cr_deleteBuild(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CrDeleteBuild(rctx, fc.Args["id"].(repos.ID))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedInAndVerified == nil {
				return nil, errors.New("directive isLoggedInAndVerified is not implemented")
			}
			return ec.directives.IsLoggedInAndVerified(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.HasAccount == nil {
				return nil, errors.New("directive hasAccount is not implemented")
			}
			return ec.directives.HasAccount(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_cr_deleteBuild(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_cr_deleteBuild_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_cr_triggerBuild(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_cr_triggerBuild(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CrTriggerBuild(rctx, fc.Args["id"].(repos.ID))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedInAndVerified == nil {
				return nil, errors.New("directive isLoggedInAndVerified is not implemented")
			}
			return ec.directives.IsLoggedInAndVerified(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.HasAccount == nil {
				return nil, errors.New("directive hasAccount is not implemented")
			}
			return ec.directives.HasAccount(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_cr_triggerBuild(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_cr_triggerBuild_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_cr_addBuildCacheKey(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_cr_addBuildCacheKey(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CrAddBuildCacheKey(rctx, fc.Args["buildCacheKey"].(entities.BuildCacheKey))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedInAndVerified == nil {
				return nil, errors.New("directive isLoggedInAndVerified is not implemented")
			}
			return ec.directives.IsLoggedInAndVerified(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.HasAccount == nil {
				return nil, errors.New("directive hasAccount is not implemented")
			}
			return ec.directives.HasAccount(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*entities.BuildCacheKey); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *kloudlite.io/apps/container-registry/internal/domain/entities.BuildCacheKey`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*entities.BuildCacheKey)
	fc.Result = res
	return ec.marshalOBuildCacheKey2kloudliteioappscontainerregistryinternaldomainentitiesBuildCacheKey(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_cr_addBuildCacheKey(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "accountName":
				return ec.fieldContext_BuildCacheKey_accountName(ctx, field)
			case "createdBy":
				return ec.fieldContext_BuildCacheKey_createdBy(ctx, field)
			case "creationTime":
				return ec.fieldContext_BuildCacheKey_creationTime(ctx, field)
			case "displayName":
				return ec.fieldContext_BuildCacheKey_displayName(ctx, field)
			case "id":
				return ec.fieldContext_BuildCacheKey_id(ctx, field)
			case "lastUpdatedBy":
				return ec.fieldContext_BuildCacheKey_lastUpdatedBy(ctx, field)
			case "markedForDeletion":
				return ec.fieldContext_BuildCacheKey_markedForDeletion(ctx, field)
			case "name":
				return ec.fieldContext_BuildCacheKey_name(ctx, field)
			case "recordVersion":
				return ec.fieldContext_BuildCacheKey_recordVersion(ctx, field)
			case "updateTime":
				return ec.fieldContext_BuildCacheKey_updateTime(ctx, field)
			case "volumeSizeInGB":
				return ec.fieldContext_BuildCacheKey_volumeSizeInGB(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BuildCacheKey", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_cr_addBuildCacheKey_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_cr_deleteBuildCacheKey(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_cr_deleteBuildCacheKey(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CrDeleteBuildCacheKey(rctx, fc.Args["id"].(repos.ID))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedInAndVerified == nil {
				return nil, errors.New("directive isLoggedInAndVerified is not implemented")
			}
			return ec.directives.IsLoggedInAndVerified(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.HasAccount == nil {
				return nil, errors.New("directive hasAccount is not implemented")
			}
			return ec.directives.HasAccount(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_cr_deleteBuildCacheKey(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_cr_deleteBuildCacheKey_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_cr_updateBuildCacheKey(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_cr_updateBuildCacheKey(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CrUpdateBuildCacheKey(rctx, fc.Args["id"].(repos.ID), fc.Args["buildCacheKey"].(entities.BuildCacheKey))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedInAndVerified == nil {
				return nil, errors.New("directive isLoggedInAndVerified is not implemented")
			}
			return ec.directives.IsLoggedInAndVerified(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.HasAccount == nil {
				return nil, errors.New("directive hasAccount is not implemented")
			}
			return ec.directives.HasAccount(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*entities.BuildCacheKey); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *kloudlite.io/apps/container-registry/internal/domain/entities.BuildCacheKey`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*entities.BuildCacheKey)
	fc.Result = res
	return ec.marshalOBuildCacheKey2kloudliteioappscontainerregistryinternaldomainentitiesBuildCacheKey(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_cr_updateBuildCacheKey(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "accountName":
				return ec.fieldContext_BuildCacheKey_accountName(ctx, field)
			case "createdBy":
				return ec.fieldContext_BuildCacheKey_createdBy(ctx, field)
			case "creationTime":
				return ec.fieldContext_BuildCacheKey_creationTime(ctx, field)
			case "displayName":
				return ec.fieldContext_BuildCacheKey_displayName(ctx, field)
			case "id":
				return ec.fieldContext_BuildCacheKey_id(ctx, field)
			case "lastUpdatedBy":
				return ec.fieldContext_BuildCacheKey_lastUpdatedBy(ctx, field)
			case "markedForDeletion":
				return ec.fieldContext_BuildCacheKey_markedForDeletion(ctx, field)
			case "name":
				return ec.fieldContext_BuildCacheKey_name(ctx, field)
			case "recordVersion":
				return ec.fieldContext_BuildCacheKey_recordVersion(ctx, field)
			case "updateTime":
				return ec.fieldContext_BuildCacheKey_updateTime(ctx, field)
			case "volumeSizeInGB":
				return ec.fieldContext_BuildCacheKey_volumeSizeInGB(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BuildCacheKey", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_cr_updateBuildCacheKey_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_cr_listBuildsByBuildCacheId(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_cr_listBuildsByBuildCacheId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CrListBuildsByBuildCacheID(rctx, fc.Args["buildCacheKeyId"].(repos.ID), fc.Args["pagination"].(*repos.CursorPagination))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedInAndVerified == nil {
				return nil, errors.New("directive isLoggedInAndVerified is not implemented")
			}
			return ec.directives.IsLoggedInAndVerified(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.HasAccount == nil {
				return nil, errors.New("directive hasAccount is not implemented")
			}
			return ec.directives.HasAccount(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.BuildPaginatedRecords); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *kloudlite.io/apps/container-registry/internal/app/graph/model.BuildPaginatedRecords`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.BuildPaginatedRecords)
	fc.Result = res
	return ec.marshalOBuildPaginatedRecords2kloudliteioappscontainerregistryinternalappgraphmodelBuildPaginatedRecords(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_cr_listBuildsByBuildCacheId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_BuildPaginatedRecords_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_BuildPaginatedRecords_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_BuildPaginatedRecords_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BuildPaginatedRecords", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_cr_listBuildsByBuildCacheId_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_endCursor(ctx context.Context, field graphql.CollectedField, obj *model.PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_endCursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndCursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_endCursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_hasNextPage(ctx context.Context, field graphql.CollectedField, obj *model.PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_hasNextPage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasNextPage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_hasNextPage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_hasPreviousPage(ctx context.Context, field graphql.CollectedField, obj *model.PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasPreviousPage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_hasPreviousPage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_startCursor(ctx context.Context, field graphql.CollectedField, obj *model.PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_startCursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartCursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_startCursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Pagination_page(ctx context.Context, field graphql.CollectedField, obj *types.Pagination) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Pagination_page(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Page, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Pagination_page(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Pagination",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Pagination_per_page(ctx context.Context, field graphql.CollectedField, obj *types.Pagination) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Pagination_per_page(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PerPage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Pagination_per_page(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Pagination",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_cr_listRepos(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_cr_listRepos(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().CrListRepos(rctx, fc.Args["search"].(*model.SearchRepos), fc.Args["pagination"].(*repos.CursorPagination))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedInAndVerified == nil {
				return nil, errors.New("directive isLoggedInAndVerified is not implemented")
			}
			return ec.directives.IsLoggedInAndVerified(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.HasAccount == nil {
				return nil, errors.New("directive hasAccount is not implemented")
			}
			return ec.directives.HasAccount(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.RepositoryPaginatedRecords); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *kloudlite.io/apps/container-registry/internal/app/graph/model.RepositoryPaginatedRecords`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.RepositoryPaginatedRecords)
	fc.Result = res
	return ec.marshalORepositoryPaginatedRecords2kloudliteioappscontainerregistryinternalappgraphmodelRepositoryPaginatedRecords(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_cr_listRepos(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_RepositoryPaginatedRecords_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_RepositoryPaginatedRecords_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_RepositoryPaginatedRecords_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RepositoryPaginatedRecords", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_cr_listRepos_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_cr_listCreds(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_cr_listCreds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().CrListCreds(rctx, fc.Args["search"].(*model.SearchCreds), fc.Args["pagination"].(*repos.CursorPagination))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedInAndVerified == nil {
				return nil, errors.New("directive isLoggedInAndVerified is not implemented")
			}
			return ec.directives.IsLoggedInAndVerified(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.HasAccount == nil {
				return nil, errors.New("directive hasAccount is not implemented")
			}
			return ec.directives.HasAccount(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.CredentialPaginatedRecords); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *kloudlite.io/apps/container-registry/internal/app/graph/model.CredentialPaginatedRecords`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.CredentialPaginatedRecords)
	fc.Result = res
	return ec.marshalOCredentialPaginatedRecords2kloudliteioappscontainerregistryinternalappgraphmodelCredentialPaginatedRecords(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_cr_listCreds(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_CredentialPaginatedRecords_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_CredentialPaginatedRecords_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_CredentialPaginatedRecords_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CredentialPaginatedRecords", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_cr_listCreds_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_cr_listDigests(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_cr_listDigests(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().CrListDigests(rctx, fc.Args["repoName"].(string), fc.Args["search"].(*model.SearchRepos), fc.Args["pagination"].(*repos.CursorPagination))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedInAndVerified == nil {
				return nil, errors.New("directive isLoggedInAndVerified is not implemented")
			}
			return ec.directives.IsLoggedInAndVerified(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.HasAccount == nil {
				return nil, errors.New("directive hasAccount is not implemented")
			}
			return ec.directives.HasAccount(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.DigestPaginatedRecords); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *kloudlite.io/apps/container-registry/internal/app/graph/model.DigestPaginatedRecords`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.DigestPaginatedRecords)
	fc.Result = res
	return ec.marshalODigestPaginatedRecords2kloudliteioappscontainerregistryinternalappgraphmodelDigestPaginatedRecords(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_cr_listDigests(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_DigestPaginatedRecords_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_DigestPaginatedRecords_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_DigestPaginatedRecords_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DigestPaginatedRecords", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_cr_listDigests_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_cr_getCredToken(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_cr_getCredToken(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().CrGetCredToken(rctx, fc.Args["username"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedInAndVerified == nil {
				return nil, errors.New("directive isLoggedInAndVerified is not implemented")
			}
			return ec.directives.IsLoggedInAndVerified(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.HasAccount == nil {
				return nil, errors.New("directive hasAccount is not implemented")
			}
			return ec.directives.HasAccount(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_cr_getCredToken(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_cr_getCredToken_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_cr_checkUserNameAvailability(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_cr_checkUserNameAvailability(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().CrCheckUserNameAvailability(rctx, fc.Args["name"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedInAndVerified == nil {
				return nil, errors.New("directive isLoggedInAndVerified is not implemented")
			}
			return ec.directives.IsLoggedInAndVerified(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.HasAccount == nil {
				return nil, errors.New("directive hasAccount is not implemented")
			}
			return ec.directives.HasAccount(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*domain.CheckNameAvailabilityOutput); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *kloudlite.io/apps/container-registry/internal/domain.CheckNameAvailabilityOutput`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*domain.CheckNameAvailabilityOutput)
	fc.Result = res
	return ec.marshalNCRCheckNameAvailabilityOutput2kloudliteioappscontainerregistryinternaldomainCheckNameAvailabilityOutput(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_cr_checkUserNameAvailability(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "result":
				return ec.fieldContext_CRCheckNameAvailabilityOutput_result(ctx, field)
			case "suggestedNames":
				return ec.fieldContext_CRCheckNameAvailabilityOutput_suggestedNames(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CRCheckNameAvailabilityOutput", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_cr_checkUserNameAvailability_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_cr_getBuild(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_cr_getBuild(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().CrGetBuild(rctx, fc.Args["id"].(repos.ID))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedInAndVerified == nil {
				return nil, errors.New("directive isLoggedInAndVerified is not implemented")
			}
			return ec.directives.IsLoggedInAndVerified(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.HasAccount == nil {
				return nil, errors.New("directive hasAccount is not implemented")
			}
			return ec.directives.HasAccount(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*entities.Build); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *kloudlite.io/apps/container-registry/internal/domain/entities.Build`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*entities.Build)
	fc.Result = res
	return ec.marshalOBuild2kloudliteioappscontainerregistryinternaldomainentitiesBuild(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_cr_getBuild(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "accountName":
				return ec.fieldContext_Build_accountName(ctx, field)
			case "buildCacheId":
				return ec.fieldContext_Build_buildCacheId(ctx, field)
			case "buildData":
				return ec.fieldContext_Build_buildData(ctx, field)
			case "createdBy":
				return ec.fieldContext_Build_createdBy(ctx, field)
			case "creationTime":
				return ec.fieldContext_Build_creationTime(ctx, field)
			case "credUser":
				return ec.fieldContext_Build_credUser(ctx, field)
			case "errorMessages":
				return ec.fieldContext_Build_errorMessages(ctx, field)
			case "id":
				return ec.fieldContext_Build_id(ctx, field)
			case "lastUpdatedBy":
				return ec.fieldContext_Build_lastUpdatedBy(ctx, field)
			case "markedForDeletion":
				return ec.fieldContext_Build_markedForDeletion(ctx, field)
			case "name":
				return ec.fieldContext_Build_name(ctx, field)
			case "recordVersion":
				return ec.fieldContext_Build_recordVersion(ctx, field)
			case "repository":
				return ec.fieldContext_Build_repository(ctx, field)
			case "source":
				return ec.fieldContext_Build_source(ctx, field)
			case "status":
				return ec.fieldContext_Build_status(ctx, field)
			case "tags":
				return ec.fieldContext_Build_tags(ctx, field)
			case "updateTime":
				return ec.fieldContext_Build_updateTime(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Build", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_cr_getBuild_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_cr_listBuilds(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_cr_listBuilds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().CrListBuilds(rctx, fc.Args["repoName"].(string), fc.Args["search"].(*model.SearchBuilds), fc.Args["pagination"].(*repos.CursorPagination))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedInAndVerified == nil {
				return nil, errors.New("directive isLoggedInAndVerified is not implemented")
			}
			return ec.directives.IsLoggedInAndVerified(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.HasAccount == nil {
				return nil, errors.New("directive hasAccount is not implemented")
			}
			return ec.directives.HasAccount(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.BuildPaginatedRecords); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *kloudlite.io/apps/container-registry/internal/app/graph/model.BuildPaginatedRecords`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.BuildPaginatedRecords)
	fc.Result = res
	return ec.marshalOBuildPaginatedRecords2kloudliteioappscontainerregistryinternalappgraphmodelBuildPaginatedRecords(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_cr_listBuilds(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_BuildPaginatedRecords_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_BuildPaginatedRecords_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_BuildPaginatedRecords_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BuildPaginatedRecords", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_cr_listBuilds_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_cr_listGithubInstallations(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_cr_listGithubInstallations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().CrListGithubInstallations(rctx, fc.Args["pagination"].(*types.Pagination))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedInAndVerified == nil {
				return nil, errors.New("directive isLoggedInAndVerified is not implemented")
			}
			return ec.directives.IsLoggedInAndVerified(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*entities.GithubInstallation); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*kloudlite.io/apps/container-registry/internal/domain/entities.GithubInstallation`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*entities.GithubInstallation)
	fc.Result = res
	return ec.marshalOGithubInstallation2kloudliteioappscontainerregistryinternaldomainentitiesGithubInstallation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_cr_listGithubInstallations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "account":
				return ec.fieldContext_GithubInstallation_account(ctx, field)
			case "appId":
				return ec.fieldContext_GithubInstallation_appId(ctx, field)
			case "id":
				return ec.fieldContext_GithubInstallation_id(ctx, field)
			case "nodeId":
				return ec.fieldContext_GithubInstallation_nodeId(ctx, field)
			case "repositoriesUrl":
				return ec.fieldContext_GithubInstallation_repositoriesUrl(ctx, field)
			case "targetId":
				return ec.fieldContext_GithubInstallation_targetId(ctx, field)
			case "targetType":
				return ec.fieldContext_GithubInstallation_targetType(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubInstallation", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_cr_listGithubInstallations_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_cr_listGithubRepos(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_cr_listGithubRepos(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().CrListGithubRepos(rctx, fc.Args["installationId"].(int), fc.Args["pagination"].(*types.Pagination))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedInAndVerified == nil {
				return nil, errors.New("directive isLoggedInAndVerified is not implemented")
			}
			return ec.directives.IsLoggedInAndVerified(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*entities.GithubListRepository); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *kloudlite.io/apps/container-registry/internal/domain/entities.GithubListRepository`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*entities.GithubListRepository)
	fc.Result = res
	return ec.marshalOGithubListRepository2kloudliteioappscontainerregistryinternaldomainentitiesGithubListRepository(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_cr_listGithubRepos(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "repositories":
				return ec.fieldContext_GithubListRepository_repositories(ctx, field)
			case "totalCount":
				return ec.fieldContext_GithubListRepository_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubListRepository", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_cr_listGithubRepos_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_cr_searchGithubRepos(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_cr_searchGithubRepos(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().CrSearchGithubRepos(rctx, fc.Args["organization"].(string), fc.Args["search"].(string), fc.Args["pagination"].(*types.Pagination))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedInAndVerified == nil {
				return nil, errors.New("directive isLoggedInAndVerified is not implemented")
			}
			return ec.directives.IsLoggedInAndVerified(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*entities.GithubSearchRepository); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *kloudlite.io/apps/container-registry/internal/domain/entities.GithubSearchRepository`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*entities.GithubSearchRepository)
	fc.Result = res
	return ec.marshalOGithubSearchRepository2kloudliteioappscontainerregistryinternaldomainentitiesGithubSearchRepository(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_cr_searchGithubRepos(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "incompleteResults":
				return ec.fieldContext_GithubSearchRepository_incompleteResults(ctx, field)
			case "repositories":
				return ec.fieldContext_GithubSearchRepository_repositories(ctx, field)
			case "total":
				return ec.fieldContext_GithubSearchRepository_total(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubSearchRepository", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_cr_searchGithubRepos_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_cr_listGithubBranches(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_cr_listGithubBranches(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().CrListGithubBranches(rctx, fc.Args["repoUrl"].(string), fc.Args["pagination"].(*types.Pagination))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedInAndVerified == nil {
				return nil, errors.New("directive isLoggedInAndVerified is not implemented")
			}
			return ec.directives.IsLoggedInAndVerified(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*entities.GitBranch); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*kloudlite.io/apps/container-registry/internal/domain/entities.GitBranch`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*entities.GitBranch)
	fc.Result = res
	return ec.marshalOGitBranch2kloudliteioappscontainerregistryinternaldomainentitiesGitBranch(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_cr_listGithubBranches(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_GitBranch_name(ctx, field)
			case "protected":
				return ec.fieldContext_GitBranch_protected(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GitBranch", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_cr_listGithubBranches_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_cr_listGitlabGroups(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_cr_listGitlabGroups(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().CrListGitlabGroups(rctx, fc.Args["query"].(*string), fc.Args["pagination"].(*types.Pagination))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedInAndVerified == nil {
				return nil, errors.New("directive isLoggedInAndVerified is not implemented")
			}
			return ec.directives.IsLoggedInAndVerified(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*entities.GitlabGroup); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*kloudlite.io/apps/container-registry/internal/domain/entities.GitlabGroup`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*entities.GitlabGroup)
	fc.Result = res
	return ec.marshalOGitlabGroup2kloudliteioappscontainerregistryinternaldomainentitiesGitlabGroup(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_cr_listGitlabGroups(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "avatarUrl":
				return ec.fieldContext_GitlabGroup_avatarUrl(ctx, field)
			case "fullName":
				return ec.fieldContext_GitlabGroup_fullName(ctx, field)
			case "id":
				return ec.fieldContext_GitlabGroup_id(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GitlabGroup", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_cr_listGitlabGroups_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_cr_listGitlabRepositories(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_cr_listGitlabRepositories(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().CrListGitlabRepositories(rctx, fc.Args["groupId"].(string), fc.Args["query"].(*string), fc.Args["pagination"].(*types.Pagination))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedInAndVerified == nil {
				return nil, errors.New("directive isLoggedInAndVerified is not implemented")
			}
			return ec.directives.IsLoggedInAndVerified(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*entities.GitlabProject); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*kloudlite.io/apps/container-registry/internal/domain/entities.GitlabProject`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*entities.GitlabProject)
	fc.Result = res
	return ec.marshalOGitlabProject2kloudliteioappscontainerregistryinternaldomainentitiesGitlabProject(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_cr_listGitlabRepositories(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "archived":
				return ec.fieldContext_GitlabProject_archived(ctx, field)
			case "avatarUrl":
				return ec.fieldContext_GitlabProject_avatarUrl(ctx, field)
			case "createdAt":
				return ec.fieldContext_GitlabProject_createdAt(ctx, field)
			case "creatorId":
				return ec.fieldContext_GitlabProject_creatorId(ctx, field)
			case "defaultBranch":
				return ec.fieldContext_GitlabProject_defaultBranch(ctx, field)
			case "description":
				return ec.fieldContext_GitlabProject_description(ctx, field)
			case "emptyRepo":
				return ec.fieldContext_GitlabProject_emptyRepo(ctx, field)
			case "httpUrlToRepo":
				return ec.fieldContext_GitlabProject_httpUrlToRepo(ctx, field)
			case "id":
				return ec.fieldContext_GitlabProject_id(ctx, field)
			case "lastActivityAt":
				return ec.fieldContext_GitlabProject_lastActivityAt(ctx, field)
			case "name":
				return ec.fieldContext_GitlabProject_name(ctx, field)
			case "nameWithNamespace":
				return ec.fieldContext_GitlabProject_nameWithNamespace(ctx, field)
			case "path":
				return ec.fieldContext_GitlabProject_path(ctx, field)
			case "pathWithNamespace":
				return ec.fieldContext_GitlabProject_pathWithNamespace(ctx, field)
			case "public":
				return ec.fieldContext_GitlabProject_public(ctx, field)
			case "sshUrlToRepo":
				return ec.fieldContext_GitlabProject_sshUrlToRepo(ctx, field)
			case "tagList":
				return ec.fieldContext_GitlabProject_tagList(ctx, field)
			case "topics":
				return ec.fieldContext_GitlabProject_topics(ctx, field)
			case "webUrl":
				return ec.fieldContext_GitlabProject_webUrl(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GitlabProject", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_cr_listGitlabRepositories_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_cr_listGitlabBranches(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_cr_listGitlabBranches(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().CrListGitlabBranches(rctx, fc.Args["repoId"].(string), fc.Args["query"].(*string), fc.Args["pagination"].(*types.Pagination))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedInAndVerified == nil {
				return nil, errors.New("directive isLoggedInAndVerified is not implemented")
			}
			return ec.directives.IsLoggedInAndVerified(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*entities.GitBranch); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*kloudlite.io/apps/container-registry/internal/domain/entities.GitBranch`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*entities.GitBranch)
	fc.Result = res
	return ec.marshalOGitBranch2kloudliteioappscontainerregistryinternaldomainentitiesGitBranch(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_cr_listGitlabBranches(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_GitBranch_name(ctx, field)
			case "protected":
				return ec.fieldContext_GitBranch_protected(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GitBranch", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_cr_listGitlabBranches_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_cr_listBuildCacheKeys(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_cr_listBuildCacheKeys(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().CrListBuildCacheKeys(rctx, fc.Args["pq"].(*repos.CursorPagination), fc.Args["search"].(*model.SearchBuildCacheKeys))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsLoggedInAndVerified == nil {
				return nil, errors.New("directive isLoggedInAndVerified is not implemented")
			}
			return ec.directives.IsLoggedInAndVerified(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.HasAccount == nil {
				return nil, errors.New("directive hasAccount is not implemented")
			}
			return ec.directives.HasAccount(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.BuildCacheKeyPaginatedRecords); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *kloudlite.io/apps/container-registry/internal/app/graph/model.BuildCacheKeyPaginatedRecords`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.BuildCacheKeyPaginatedRecords)
	fc.Result = res
	return ec.marshalOBuildCacheKeyPaginatedRecords2kloudliteioappscontainerregistryinternalappgraphmodelBuildCacheKeyPaginatedRecords(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_cr_listBuildCacheKeys(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_BuildCacheKeyPaginatedRecords_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_BuildCacheKeyPaginatedRecords_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_BuildCacheKeyPaginatedRecords_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BuildCacheKeyPaginatedRecords", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_cr_listBuildCacheKeys_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query__service(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query__service(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.__resolve__service(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(fedruntime.Service)
	fc.Result = res
	return ec.marshalN_Service2githubcom99designsgqlgenpluginfederationfedruntimeService(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query__service(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "sdl":
				return ec.fieldContext__Service_sdl(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type _Service", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___schema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___schema(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Repository_accountName(ctx context.Context, field graphql.CollectedField, obj *entities.Repository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Repository_accountName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AccountName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Repository_accountName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Repository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Repository_createdBy(ctx context.Context, field graphql.CollectedField, obj *entities.Repository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Repository_createdBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Repository().CreatedBy(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.KloudliteIoCommonCreatedOrUpdatedBy)
	fc.Result = res
	return ec.marshalNKloudlite_io__common_CreatedOrUpdatedBy2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoCommonCreatedOrUpdatedBy(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Repository_createdBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Repository",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "userEmail":
				return ec.fieldContext_Kloudlite_io__common_CreatedOrUpdatedBy_userEmail(ctx, field)
			case "userId":
				return ec.fieldContext_Kloudlite_io__common_CreatedOrUpdatedBy_userId(ctx, field)
			case "userName":
				return ec.fieldContext_Kloudlite_io__common_CreatedOrUpdatedBy_userName(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Kloudlite_io__common_CreatedOrUpdatedBy", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Repository_creationTime(ctx context.Context, field graphql.CollectedField, obj *entities.Repository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Repository_creationTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Repository().CreationTime(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNDate2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Repository_creationTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Repository",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Repository_id(ctx context.Context, field graphql.CollectedField, obj *entities.Repository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Repository_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Repository().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Repository_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Repository",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Repository_lastUpdatedBy(ctx context.Context, field graphql.CollectedField, obj *entities.Repository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Repository_lastUpdatedBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Repository().LastUpdatedBy(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.KloudliteIoCommonCreatedOrUpdatedBy)
	fc.Result = res
	return ec.marshalNKloudlite_io__common_CreatedOrUpdatedBy2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoCommonCreatedOrUpdatedBy(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Repository_lastUpdatedBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Repository",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "userEmail":
				return ec.fieldContext_Kloudlite_io__common_CreatedOrUpdatedBy_userEmail(ctx, field)
			case "userId":
				return ec.fieldContext_Kloudlite_io__common_CreatedOrUpdatedBy_userId(ctx, field)
			case "userName":
				return ec.fieldContext_Kloudlite_io__common_CreatedOrUpdatedBy_userName(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Kloudlite_io__common_CreatedOrUpdatedBy", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Repository_markedForDeletion(ctx context.Context, field graphql.CollectedField, obj *entities.Repository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Repository_markedForDeletion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MarkedForDeletion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Repository_markedForDeletion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Repository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Repository_name(ctx context.Context, field graphql.CollectedField, obj *entities.Repository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Repository_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Repository_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Repository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Repository_recordVersion(ctx context.Context, field graphql.CollectedField, obj *entities.Repository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Repository_recordVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RecordVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Repository_recordVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Repository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Repository_updateTime(ctx context.Context, field graphql.CollectedField, obj *entities.Repository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Repository_updateTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Repository().UpdateTime(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNDate2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Repository_updateTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Repository",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepositoryEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *model.RepositoryEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepositoryEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepositoryEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepositoryEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepositoryEdge_node(ctx context.Context, field graphql.CollectedField, obj *model.RepositoryEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepositoryEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*entities.Repository)
	fc.Result = res
	return ec.marshalNRepository2kloudliteioappscontainerregistryinternaldomainentitiesRepository(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepositoryEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepositoryEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "accountName":
				return ec.fieldContext_Repository_accountName(ctx, field)
			case "createdBy":
				return ec.fieldContext_Repository_createdBy(ctx, field)
			case "creationTime":
				return ec.fieldContext_Repository_creationTime(ctx, field)
			case "id":
				return ec.fieldContext_Repository_id(ctx, field)
			case "lastUpdatedBy":
				return ec.fieldContext_Repository_lastUpdatedBy(ctx, field)
			case "markedForDeletion":
				return ec.fieldContext_Repository_markedForDeletion(ctx, field)
			case "name":
				return ec.fieldContext_Repository_name(ctx, field)
			case "recordVersion":
				return ec.fieldContext_Repository_recordVersion(ctx, field)
			case "updateTime":
				return ec.fieldContext_Repository_updateTime(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Repository", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepositoryPaginatedRecords_edges(ctx context.Context, field graphql.CollectedField, obj *model.RepositoryPaginatedRecords) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepositoryPaginatedRecords_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.RepositoryEdge)
	fc.Result = res
	return ec.marshalNRepositoryEdge2kloudliteioappscontainerregistryinternalappgraphmodelRepositoryEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepositoryPaginatedRecords_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepositoryPaginatedRecords",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cursor":
				return ec.fieldContext_RepositoryEdge_cursor(ctx, field)
			case "node":
				return ec.fieldContext_RepositoryEdge_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RepositoryEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepositoryPaginatedRecords_pageInfo(ctx context.Context, field graphql.CollectedField, obj *model.RepositoryPaginatedRecords) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepositoryPaginatedRecords_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2kloudliteioappscontainerregistryinternalappgraphmodelPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepositoryPaginatedRecords_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepositoryPaginatedRecords",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepositoryPaginatedRecords_totalCount(ctx context.Context, field graphql.CollectedField, obj *model.RepositoryPaginatedRecords) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepositoryPaginatedRecords_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepositoryPaginatedRecords_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepositoryPaginatedRecords",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) __Service_sdl(ctx context.Context, field graphql.CollectedField, obj *fedruntime.Service) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext__Service_sdl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SDL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext__Service_sdl(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "_Service",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_locations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_isRepeatable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRepeatable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_defaultValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_types(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_queryType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_queryType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_mutationType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_mutationType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_subscriptionType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_directives(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_directives(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_kind(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_fields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_interfaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_interfaces(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_possibleTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_enumValues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_inputFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_inputFields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_ofType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_ofType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_specifiedByURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpecifiedByURL(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputBuildCacheKeyIn(ctx context.Context, obj interface{}) (entities.BuildCacheKey, error) {
	var it entities.BuildCacheKey
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"displayName", "name", "volumeSizeInGB"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "displayName":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayName"))
			it.DisplayName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "volumeSizeInGB":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("volumeSizeInGB"))
			data, err := ec.unmarshalNFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.BuildCacheKeyIn().VolumeSizeInGb(ctx, &it, data); err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBuildIn(ctx context.Context, obj interface{}) (entities.Build, error) {
	var it entities.Build
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"buildCacheId", "buildData", "name", "repository", "source", "tags"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "buildCacheId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("buildCacheId"))
			it.BuildCacheId, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "buildData":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("buildData"))
			data, err := ec.unmarshalOKloudlite_io__apps__container___registry__internal__domain__entities_BuildOptionsIn2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoAppsContainerRegistryInternalDomainEntitiesBuildOptionsIn(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.BuildIn().BuildData(ctx, &it, data); err != nil {
				return it, err
			}
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "repository":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("repository"))
			it.Repository, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "source":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("source"))
			data, err := ec.unmarshalNKloudlite_io__apps__container___registry__internal__domain__entities_GitSourceIn2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoAppsContainerRegistryInternalDomainEntitiesGitSourceIn(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.BuildIn().Source(ctx, &it, data); err != nil {
				return it, err
			}
		case "tags":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tags"))
			it.Tags, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCredentialIn(ctx context.Context, obj interface{}) (entities.Credential, error) {
	var it entities.Credential
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"access", "expiration", "name", "username"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "access":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("access"))
			data, err := ec.unmarshalNKloudlite_io__apps__container___registry__internal__domain__entities_RepoAccess2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoAppsContainerRegistryInternalDomainEntitiesRepoAccess(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.CredentialIn().Access(ctx, &it, data); err != nil {
				return it, err
			}
		case "expiration":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expiration"))
			data, err := ec.unmarshalNKloudlite_io__apps__container___registry__internal__domain__entities_ExpirationIn2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoAppsContainerRegistryInternalDomainEntitiesExpirationIn(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.CredentialIn().Expiration(ctx, &it, data); err != nil {
				return it, err
			}
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "username":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("username"))
			it.UserName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCursorPaginationIn(ctx context.Context, obj interface{}) (repos.CursorPagination, error) {
	var it repos.CursorPagination
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["orderBy"]; !present {
		asMap["orderBy"] = "_id"
	}
	if _, present := asMap["sortDirection"]; !present {
		asMap["sortDirection"] = "ASC"
	}

	fieldsInOrder := [...]string{"after", "before", "first", "last", "orderBy", "sortDirection"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "after":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
			it.After, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "before":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
			it.Before, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "first":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
			it.First, err = ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
		case "last":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
			it.Last, err = ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
		case "orderBy":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
			it.OrderBy, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "sortDirection":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sortDirection"))
			it.SortDirection, err = ec.unmarshalOCursorPaginationSortDirection2kloudliteiopkgreposSortDirection(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputKloudlite_io__apps__container___registry__internal__domain__entities_BuildOptionsIn(ctx context.Context, obj interface{}) (model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesBuildOptionsIn, error) {
	var it model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesBuildOptionsIn
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"buildArgs", "buildContexts", "contextDir", "dockerfileContent", "dockerfilePath", "targetPlatforms"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "buildArgs":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("buildArgs"))
			it.BuildArgs, err = ec.unmarshalNMap2map(ctx, v)
			if err != nil {
				return it, err
			}
		case "buildContexts":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("buildContexts"))
			it.BuildContexts, err = ec.unmarshalNMap2map(ctx, v)
			if err != nil {
				return it, err
			}
		case "contextDir":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contextDir"))
			it.ContextDir, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "dockerfileContent":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("dockerfileContent"))
			it.DockerfileContent, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "dockerfilePath":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("dockerfilePath"))
			it.DockerfilePath, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "targetPlatforms":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("targetPlatforms"))
			it.TargetPlatforms, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputKloudlite_io__apps__container___registry__internal__domain__entities_ExpirationIn(ctx context.Context, obj interface{}) (model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesExpirationIn, error) {
	var it model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesExpirationIn
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"unit", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "unit":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("unit"))
			it.Unit, err = ec.unmarshalNKloudlite_io__apps__container___registry__internal__domain__entities_ExpirationUnit2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoAppsContainerRegistryInternalDomainEntitiesExpirationUnit(ctx, v)
			if err != nil {
				return it, err
			}
		case "value":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			it.Value, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputKloudlite_io__apps__container___registry__internal__domain__entities_GitSourceIn(ctx context.Context, obj interface{}) (model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGitSourceIn, error) {
	var it model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGitSourceIn
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"branch", "provider", "repository"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "branch":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("branch"))
			it.Branch, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "provider":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("provider"))
			it.Provider, err = ec.unmarshalNKloudlite_io__apps__container___registry__internal__domain__entities_GitProvider2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoAppsContainerRegistryInternalDomainEntitiesGitProvider(ctx, v)
			if err != nil {
				return it, err
			}
		case "repository":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("repository"))
			it.Repository, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputKloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccountIn(ctx context.Context, obj interface{}) (model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubUserAccountIn, error) {
	var it model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubUserAccountIn
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"avatarUrl", "id", "login", "nodeId", "type"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "avatarUrl":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarUrl"))
			it.AvatarURL, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "login":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("login"))
			it.Login, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nodeId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nodeId"))
			it.NodeID, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "type":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			it.Type, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMatchFilterIn(ctx context.Context, obj interface{}) (repos.MatchFilter, error) {
	var it repos.MatchFilter
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"array", "exact", "matchType", "regex"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "array":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("array"))
			it.Array, err = ec.unmarshalOAny2interface(ctx, v)
			if err != nil {
				return it, err
			}
		case "exact":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("exact"))
			it.Exact, err = ec.unmarshalOAny2interface(ctx, v)
			if err != nil {
				return it, err
			}
		case "matchType":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("matchType"))
			it.MatchType, err = ec.unmarshalNMatchFilterMatchType2kloudliteiopkgreposMatchType(ctx, v)
			if err != nil {
				return it, err
			}
		case "regex":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("regex"))
			it.Regex, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPaginationIn(ctx context.Context, obj interface{}) (types.Pagination, error) {
	var it types.Pagination
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"page", "per_page"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "page":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
			it.Page, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "per_page":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("per_page"))
			it.PerPage, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRepositoryIn(ctx context.Context, obj interface{}) (entities.Repository, error) {
	var it entities.Repository
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSearchBuildCacheKeys(ctx context.Context, obj interface{}) (model.SearchBuildCacheKeys, error) {
	var it model.SearchBuildCacheKeys
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"text"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "text":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("text"))
			it.Text, err = ec.unmarshalOMatchFilterIn2kloudliteiopkgreposMatchFilter(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSearchBuilds(ctx context.Context, obj interface{}) (model.SearchBuilds, error) {
	var it model.SearchBuilds
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"text"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "text":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("text"))
			it.Text, err = ec.unmarshalOMatchFilterIn2kloudliteiopkgreposMatchFilter(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSearchCreds(ctx context.Context, obj interface{}) (model.SearchCreds, error) {
	var it model.SearchCreds
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"text"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "text":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("text"))
			it.Text, err = ec.unmarshalOMatchFilterIn2kloudliteiopkgreposMatchFilter(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSearchRepos(ctx context.Context, obj interface{}) (model.SearchRepos, error) {
	var it model.SearchRepos
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"text"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "text":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("text"))
			it.Text, err = ec.unmarshalOMatchFilterIn2kloudliteiopkgreposMatchFilter(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var buildImplementors = []string{"Build"}

func (ec *executionContext) _Build(ctx context.Context, sel ast.SelectionSet, obj *entities.Build) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, buildImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Build")
		case "accountName":

			out.Values[i] = ec._Build_accountName(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "buildCacheId":

			out.Values[i] = ec._Build_buildCacheId(ctx, field, obj)

		case "buildData":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Build_buildData(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "createdBy":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Build_createdBy(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "creationTime":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Build_creationTime(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "credUser":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Build_credUser(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "errorMessages":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Build_errorMessages(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "id":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Build_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "lastUpdatedBy":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Build_lastUpdatedBy(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "markedForDeletion":

			out.Values[i] = ec._Build_markedForDeletion(ctx, field, obj)

		case "name":

			out.Values[i] = ec._Build_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "recordVersion":

			out.Values[i] = ec._Build_recordVersion(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "repository":

			out.Values[i] = ec._Build_repository(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "source":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Build_source(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "status":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Build_status(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "tags":

			out.Values[i] = ec._Build_tags(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "updateTime":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Build_updateTime(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var buildCacheKeyImplementors = []string{"BuildCacheKey"}

func (ec *executionContext) _BuildCacheKey(ctx context.Context, sel ast.SelectionSet, obj *entities.BuildCacheKey) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, buildCacheKeyImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BuildCacheKey")
		case "accountName":

			out.Values[i] = ec._BuildCacheKey_accountName(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "createdBy":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._BuildCacheKey_createdBy(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "creationTime":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._BuildCacheKey_creationTime(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "displayName":

			out.Values[i] = ec._BuildCacheKey_displayName(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "id":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._BuildCacheKey_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "lastUpdatedBy":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._BuildCacheKey_lastUpdatedBy(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "markedForDeletion":

			out.Values[i] = ec._BuildCacheKey_markedForDeletion(ctx, field, obj)

		case "name":

			out.Values[i] = ec._BuildCacheKey_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "recordVersion":

			out.Values[i] = ec._BuildCacheKey_recordVersion(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "updateTime":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._BuildCacheKey_updateTime(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "volumeSizeInGB":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._BuildCacheKey_volumeSizeInGB(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var buildCacheKeyEdgeImplementors = []string{"BuildCacheKeyEdge"}

func (ec *executionContext) _BuildCacheKeyEdge(ctx context.Context, sel ast.SelectionSet, obj *model.BuildCacheKeyEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, buildCacheKeyEdgeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BuildCacheKeyEdge")
		case "cursor":

			out.Values[i] = ec._BuildCacheKeyEdge_cursor(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "node":

			out.Values[i] = ec._BuildCacheKeyEdge_node(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var buildCacheKeyPaginatedRecordsImplementors = []string{"BuildCacheKeyPaginatedRecords"}

func (ec *executionContext) _BuildCacheKeyPaginatedRecords(ctx context.Context, sel ast.SelectionSet, obj *model.BuildCacheKeyPaginatedRecords) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, buildCacheKeyPaginatedRecordsImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BuildCacheKeyPaginatedRecords")
		case "edges":

			out.Values[i] = ec._BuildCacheKeyPaginatedRecords_edges(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "pageInfo":

			out.Values[i] = ec._BuildCacheKeyPaginatedRecords_pageInfo(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalCount":

			out.Values[i] = ec._BuildCacheKeyPaginatedRecords_totalCount(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var buildEdgeImplementors = []string{"BuildEdge"}

func (ec *executionContext) _BuildEdge(ctx context.Context, sel ast.SelectionSet, obj *model.BuildEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, buildEdgeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BuildEdge")
		case "cursor":

			out.Values[i] = ec._BuildEdge_cursor(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "node":

			out.Values[i] = ec._BuildEdge_node(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var buildPaginatedRecordsImplementors = []string{"BuildPaginatedRecords"}

func (ec *executionContext) _BuildPaginatedRecords(ctx context.Context, sel ast.SelectionSet, obj *model.BuildPaginatedRecords) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, buildPaginatedRecordsImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BuildPaginatedRecords")
		case "edges":

			out.Values[i] = ec._BuildPaginatedRecords_edges(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "pageInfo":

			out.Values[i] = ec._BuildPaginatedRecords_pageInfo(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalCount":

			out.Values[i] = ec._BuildPaginatedRecords_totalCount(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var cRCheckNameAvailabilityOutputImplementors = []string{"CRCheckNameAvailabilityOutput"}

func (ec *executionContext) _CRCheckNameAvailabilityOutput(ctx context.Context, sel ast.SelectionSet, obj *domain.CheckNameAvailabilityOutput) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, cRCheckNameAvailabilityOutputImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CRCheckNameAvailabilityOutput")
		case "result":

			out.Values[i] = ec._CRCheckNameAvailabilityOutput_result(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "suggestedNames":

			out.Values[i] = ec._CRCheckNameAvailabilityOutput_suggestedNames(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var credentialImplementors = []string{"Credential"}

func (ec *executionContext) _Credential(ctx context.Context, sel ast.SelectionSet, obj *entities.Credential) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, credentialImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Credential")
		case "access":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Credential_access(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "accountName":

			out.Values[i] = ec._Credential_accountName(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "createdBy":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Credential_createdBy(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "creationTime":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Credential_creationTime(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "expiration":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Credential_expiration(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "id":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Credential_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "lastUpdatedBy":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Credential_lastUpdatedBy(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "markedForDeletion":

			out.Values[i] = ec._Credential_markedForDeletion(ctx, field, obj)

		case "name":

			out.Values[i] = ec._Credential_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "recordVersion":

			out.Values[i] = ec._Credential_recordVersion(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "updateTime":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Credential_updateTime(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "username":

			out.Values[i] = ec._Credential_username(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var credentialEdgeImplementors = []string{"CredentialEdge"}

func (ec *executionContext) _CredentialEdge(ctx context.Context, sel ast.SelectionSet, obj *model.CredentialEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, credentialEdgeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CredentialEdge")
		case "cursor":

			out.Values[i] = ec._CredentialEdge_cursor(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "node":

			out.Values[i] = ec._CredentialEdge_node(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var credentialPaginatedRecordsImplementors = []string{"CredentialPaginatedRecords"}

func (ec *executionContext) _CredentialPaginatedRecords(ctx context.Context, sel ast.SelectionSet, obj *model.CredentialPaginatedRecords) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, credentialPaginatedRecordsImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CredentialPaginatedRecords")
		case "edges":

			out.Values[i] = ec._CredentialPaginatedRecords_edges(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "pageInfo":

			out.Values[i] = ec._CredentialPaginatedRecords_pageInfo(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalCount":

			out.Values[i] = ec._CredentialPaginatedRecords_totalCount(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var cursorPaginationImplementors = []string{"CursorPagination"}

func (ec *executionContext) _CursorPagination(ctx context.Context, sel ast.SelectionSet, obj *repos.CursorPagination) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, cursorPaginationImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CursorPagination")
		case "after":

			out.Values[i] = ec._CursorPagination_after(ctx, field, obj)

		case "before":

			out.Values[i] = ec._CursorPagination_before(ctx, field, obj)

		case "first":

			out.Values[i] = ec._CursorPagination_first(ctx, field, obj)

		case "last":

			out.Values[i] = ec._CursorPagination_last(ctx, field, obj)

		case "orderBy":

			out.Values[i] = ec._CursorPagination_orderBy(ctx, field, obj)

		case "sortDirection":

			out.Values[i] = ec._CursorPagination_sortDirection(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var digestImplementors = []string{"Digest"}

func (ec *executionContext) _Digest(ctx context.Context, sel ast.SelectionSet, obj *entities.Digest) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, digestImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Digest")
		case "accountName":

			out.Values[i] = ec._Digest_accountName(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "actor":

			out.Values[i] = ec._Digest_actor(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "creationTime":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Digest_creationTime(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "deleting":

			out.Values[i] = ec._Digest_deleting(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "digest":

			out.Values[i] = ec._Digest_digest(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "id":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Digest_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "length":

			out.Values[i] = ec._Digest_length(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "markedForDeletion":

			out.Values[i] = ec._Digest_markedForDeletion(ctx, field, obj)

		case "mediaType":

			out.Values[i] = ec._Digest_mediaType(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "recordVersion":

			out.Values[i] = ec._Digest_recordVersion(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "repository":

			out.Values[i] = ec._Digest_repository(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "size":

			out.Values[i] = ec._Digest_size(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "tags":

			out.Values[i] = ec._Digest_tags(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "updateTime":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Digest_updateTime(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "url":

			out.Values[i] = ec._Digest_url(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var digestEdgeImplementors = []string{"DigestEdge"}

func (ec *executionContext) _DigestEdge(ctx context.Context, sel ast.SelectionSet, obj *model.DigestEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, digestEdgeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DigestEdge")
		case "cursor":

			out.Values[i] = ec._DigestEdge_cursor(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "node":

			out.Values[i] = ec._DigestEdge_node(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var digestPaginatedRecordsImplementors = []string{"DigestPaginatedRecords"}

func (ec *executionContext) _DigestPaginatedRecords(ctx context.Context, sel ast.SelectionSet, obj *model.DigestPaginatedRecords) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, digestPaginatedRecordsImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DigestPaginatedRecords")
		case "edges":

			out.Values[i] = ec._DigestPaginatedRecords_edges(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "pageInfo":

			out.Values[i] = ec._DigestPaginatedRecords_pageInfo(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalCount":

			out.Values[i] = ec._DigestPaginatedRecords_totalCount(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var gitBranchImplementors = []string{"GitBranch"}

func (ec *executionContext) _GitBranch(ctx context.Context, sel ast.SelectionSet, obj *entities.GitBranch) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gitBranchImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GitBranch")
		case "name":

			out.Values[i] = ec._GitBranch_name(ctx, field, obj)

		case "protected":

			out.Values[i] = ec._GitBranch_protected(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var githubBranchImplementors = []string{"GithubBranch"}

func (ec *executionContext) _GithubBranch(ctx context.Context, sel ast.SelectionSet, obj *model.GithubBranch) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, githubBranchImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GithubBranch")
		case "name":

			out.Values[i] = ec._GithubBranch_name(ctx, field, obj)

		case "protected":

			out.Values[i] = ec._GithubBranch_protected(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var githubInstallationImplementors = []string{"GithubInstallation"}

func (ec *executionContext) _GithubInstallation(ctx context.Context, sel ast.SelectionSet, obj *entities.GithubInstallation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, githubInstallationImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GithubInstallation")
		case "account":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GithubInstallation_account(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "appId":

			out.Values[i] = ec._GithubInstallation_appId(ctx, field, obj)

		case "id":

			out.Values[i] = ec._GithubInstallation_id(ctx, field, obj)

		case "nodeId":

			out.Values[i] = ec._GithubInstallation_nodeId(ctx, field, obj)

		case "repositoriesUrl":

			out.Values[i] = ec._GithubInstallation_repositoriesUrl(ctx, field, obj)

		case "targetId":

			out.Values[i] = ec._GithubInstallation_targetId(ctx, field, obj)

		case "targetType":

			out.Values[i] = ec._GithubInstallation_targetType(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var githubListRepositoryImplementors = []string{"GithubListRepository"}

func (ec *executionContext) _GithubListRepository(ctx context.Context, sel ast.SelectionSet, obj *entities.GithubListRepository) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, githubListRepositoryImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GithubListRepository")
		case "repositories":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GithubListRepository_repositories(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "totalCount":

			out.Values[i] = ec._GithubListRepository_totalCount(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var githubSearchRepositoryImplementors = []string{"GithubSearchRepository"}

func (ec *executionContext) _GithubSearchRepository(ctx context.Context, sel ast.SelectionSet, obj *entities.GithubSearchRepository) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, githubSearchRepositoryImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GithubSearchRepository")
		case "incompleteResults":

			out.Values[i] = ec._GithubSearchRepository_incompleteResults(ctx, field, obj)

		case "repositories":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GithubSearchRepository_repositories(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "total":

			out.Values[i] = ec._GithubSearchRepository_total(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var gitlabBranchImplementors = []string{"GitlabBranch"}

func (ec *executionContext) _GitlabBranch(ctx context.Context, sel ast.SelectionSet, obj *model.GitlabBranch) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gitlabBranchImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GitlabBranch")
		case "canPush":

			out.Values[i] = ec._GitlabBranch_canPush(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "default":

			out.Values[i] = ec._GitlabBranch_default(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "developersCanMerge":

			out.Values[i] = ec._GitlabBranch_developersCanMerge(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "developersCanPush":

			out.Values[i] = ec._GitlabBranch_developersCanPush(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "merged":

			out.Values[i] = ec._GitlabBranch_merged(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":

			out.Values[i] = ec._GitlabBranch_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "protected":

			out.Values[i] = ec._GitlabBranch_protected(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "webUrl":

			out.Values[i] = ec._GitlabBranch_webUrl(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var gitlabGroupImplementors = []string{"GitlabGroup"}

func (ec *executionContext) _GitlabGroup(ctx context.Context, sel ast.SelectionSet, obj *entities.GitlabGroup) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gitlabGroupImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GitlabGroup")
		case "avatarUrl":

			out.Values[i] = ec._GitlabGroup_avatarUrl(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "fullName":

			out.Values[i] = ec._GitlabGroup_fullName(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "id":

			out.Values[i] = ec._GitlabGroup_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var gitlabProjectImplementors = []string{"GitlabProject"}

func (ec *executionContext) _GitlabProject(ctx context.Context, sel ast.SelectionSet, obj *entities.GitlabProject) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gitlabProjectImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GitlabProject")
		case "archived":

			out.Values[i] = ec._GitlabProject_archived(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "avatarUrl":

			out.Values[i] = ec._GitlabProject_avatarUrl(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "createdAt":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GitlabProject_createdAt(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "creatorId":

			out.Values[i] = ec._GitlabProject_creatorId(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "defaultBranch":

			out.Values[i] = ec._GitlabProject_defaultBranch(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "description":

			out.Values[i] = ec._GitlabProject_description(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "emptyRepo":

			out.Values[i] = ec._GitlabProject_emptyRepo(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "httpUrlToRepo":

			out.Values[i] = ec._GitlabProject_httpUrlToRepo(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "id":

			out.Values[i] = ec._GitlabProject_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "lastActivityAt":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GitlabProject_lastActivityAt(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "name":

			out.Values[i] = ec._GitlabProject_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "nameWithNamespace":

			out.Values[i] = ec._GitlabProject_nameWithNamespace(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "path":

			out.Values[i] = ec._GitlabProject_path(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "pathWithNamespace":

			out.Values[i] = ec._GitlabProject_pathWithNamespace(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "public":

			out.Values[i] = ec._GitlabProject_public(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "sshUrlToRepo":

			out.Values[i] = ec._GitlabProject_sshUrlToRepo(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "tagList":

			out.Values[i] = ec._GitlabProject_tagList(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "topics":

			out.Values[i] = ec._GitlabProject_topics(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "webUrl":

			out.Values[i] = ec._GitlabProject_webUrl(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var kloudlite_io__apps__container___registry__internal__domain__entities_BuildOptionsImplementors = []string{"Kloudlite_io__apps__container___registry__internal__domain__entities_BuildOptions"}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_BuildOptions(ctx context.Context, sel ast.SelectionSet, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesBuildOptions) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, kloudlite_io__apps__container___registry__internal__domain__entities_BuildOptionsImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Kloudlite_io__apps__container___registry__internal__domain__entities_BuildOptions")
		case "buildArgs":

			out.Values[i] = ec._Kloudlite_io__apps__container___registry__internal__domain__entities_BuildOptions_buildArgs(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "buildContexts":

			out.Values[i] = ec._Kloudlite_io__apps__container___registry__internal__domain__entities_BuildOptions_buildContexts(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "contextDir":

			out.Values[i] = ec._Kloudlite_io__apps__container___registry__internal__domain__entities_BuildOptions_contextDir(ctx, field, obj)

		case "dockerfileContent":

			out.Values[i] = ec._Kloudlite_io__apps__container___registry__internal__domain__entities_BuildOptions_dockerfileContent(ctx, field, obj)

		case "dockerfilePath":

			out.Values[i] = ec._Kloudlite_io__apps__container___registry__internal__domain__entities_BuildOptions_dockerfilePath(ctx, field, obj)

		case "targetPlatforms":

			out.Values[i] = ec._Kloudlite_io__apps__container___registry__internal__domain__entities_BuildOptions_targetPlatforms(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var kloudlite_io__apps__container___registry__internal__domain__entities_ExpirationImplementors = []string{"Kloudlite_io__apps__container___registry__internal__domain__entities_Expiration"}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_Expiration(ctx context.Context, sel ast.SelectionSet, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesExpiration) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, kloudlite_io__apps__container___registry__internal__domain__entities_ExpirationImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Kloudlite_io__apps__container___registry__internal__domain__entities_Expiration")
		case "unit":

			out.Values[i] = ec._Kloudlite_io__apps__container___registry__internal__domain__entities_Expiration_unit(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "value":

			out.Values[i] = ec._Kloudlite_io__apps__container___registry__internal__domain__entities_Expiration_value(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var kloudlite_io__apps__container___registry__internal__domain__entities_GitSourceImplementors = []string{"Kloudlite_io__apps__container___registry__internal__domain__entities_GitSource"}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_GitSource(ctx context.Context, sel ast.SelectionSet, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGitSource) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, kloudlite_io__apps__container___registry__internal__domain__entities_GitSourceImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Kloudlite_io__apps__container___registry__internal__domain__entities_GitSource")
		case "branch":

			out.Values[i] = ec._Kloudlite_io__apps__container___registry__internal__domain__entities_GitSource_branch(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "provider":

			out.Values[i] = ec._Kloudlite_io__apps__container___registry__internal__domain__entities_GitSource_provider(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "repository":

			out.Values[i] = ec._Kloudlite_io__apps__container___registry__internal__domain__entities_GitSource_repository(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "webhookId":

			out.Values[i] = ec._Kloudlite_io__apps__container___registry__internal__domain__entities_GitSource_webhookId(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepositoryImplementors = []string{"Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository"}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository(ctx context.Context, sel ast.SelectionSet, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubRepository) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepositoryImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository")
		case "archived":

			out.Values[i] = ec._Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_archived(ctx, field, obj)

		case "cloneUrl":

			out.Values[i] = ec._Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_cloneUrl(ctx, field, obj)

		case "createdAt":

			out.Values[i] = ec._Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_createdAt(ctx, field, obj)

		case "defaultBranch":

			out.Values[i] = ec._Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_defaultBranch(ctx, field, obj)

		case "description":

			out.Values[i] = ec._Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_description(ctx, field, obj)

		case "disabled":

			out.Values[i] = ec._Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_disabled(ctx, field, obj)

		case "fullName":

			out.Values[i] = ec._Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_fullName(ctx, field, obj)

		case "gitignoreTemplate":

			out.Values[i] = ec._Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_gitignoreTemplate(ctx, field, obj)

		case "gitUrl":

			out.Values[i] = ec._Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_gitUrl(ctx, field, obj)

		case "htmlUrl":

			out.Values[i] = ec._Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_htmlUrl(ctx, field, obj)

		case "id":

			out.Values[i] = ec._Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_id(ctx, field, obj)

		case "language":

			out.Values[i] = ec._Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_language(ctx, field, obj)

		case "masterBranch":

			out.Values[i] = ec._Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_masterBranch(ctx, field, obj)

		case "mirrorUrl":

			out.Values[i] = ec._Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_mirrorUrl(ctx, field, obj)

		case "name":

			out.Values[i] = ec._Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_name(ctx, field, obj)

		case "node_id":

			out.Values[i] = ec._Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_node_id(ctx, field, obj)

		case "permissions":

			out.Values[i] = ec._Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_permissions(ctx, field, obj)

		case "private":

			out.Values[i] = ec._Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_private(ctx, field, obj)

		case "pushedAt":

			out.Values[i] = ec._Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_pushedAt(ctx, field, obj)

		case "size":

			out.Values[i] = ec._Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_size(ctx, field, obj)

		case "team_id":

			out.Values[i] = ec._Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_team_id(ctx, field, obj)

		case "updatedAt":

			out.Values[i] = ec._Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_updatedAt(ctx, field, obj)

		case "url":

			out.Values[i] = ec._Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_url(ctx, field, obj)

		case "visibility":

			out.Values[i] = ec._Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository_visibility(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccountImplementors = []string{"Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount"}

func (ec *executionContext) _Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount(ctx context.Context, sel ast.SelectionSet, obj *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubUserAccount) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccountImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount")
		case "avatarUrl":

			out.Values[i] = ec._Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount_avatarUrl(ctx, field, obj)

		case "id":

			out.Values[i] = ec._Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount_id(ctx, field, obj)

		case "login":

			out.Values[i] = ec._Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount_login(ctx, field, obj)

		case "nodeId":

			out.Values[i] = ec._Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount_nodeId(ctx, field, obj)

		case "type":

			out.Values[i] = ec._Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount_type(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var kloudlite_io__common_CreatedOrUpdatedByImplementors = []string{"Kloudlite_io__common_CreatedOrUpdatedBy"}

func (ec *executionContext) _Kloudlite_io__common_CreatedOrUpdatedBy(ctx context.Context, sel ast.SelectionSet, obj *model.KloudliteIoCommonCreatedOrUpdatedBy) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, kloudlite_io__common_CreatedOrUpdatedByImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Kloudlite_io__common_CreatedOrUpdatedBy")
		case "userEmail":

			out.Values[i] = ec._Kloudlite_io__common_CreatedOrUpdatedBy_userEmail(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "userId":

			out.Values[i] = ec._Kloudlite_io__common_CreatedOrUpdatedBy_userId(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "userName":

			out.Values[i] = ec._Kloudlite_io__common_CreatedOrUpdatedBy_userName(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var matchFilterImplementors = []string{"MatchFilter"}

func (ec *executionContext) _MatchFilter(ctx context.Context, sel ast.SelectionSet, obj *repos.MatchFilter) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, matchFilterImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MatchFilter")
		case "array":

			out.Values[i] = ec._MatchFilter_array(ctx, field, obj)

		case "exact":

			out.Values[i] = ec._MatchFilter_exact(ctx, field, obj)

		case "matchType":

			out.Values[i] = ec._MatchFilter_matchType(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "regex":

			out.Values[i] = ec._MatchFilter_regex(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "cr_createRepo":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_cr_createRepo(ctx, field)
			})

		case "cr_createCred":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_cr_createCred(ctx, field)
			})

		case "cr_deleteRepo":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_cr_deleteRepo(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "cr_deleteCred":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_cr_deleteCred(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "cr_deleteDigest":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_cr_deleteDigest(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "cr_addBuild":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_cr_addBuild(ctx, field)
			})

		case "cr_updateBuild":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_cr_updateBuild(ctx, field)
			})

		case "cr_deleteBuild":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_cr_deleteBuild(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "cr_triggerBuild":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_cr_triggerBuild(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "cr_addBuildCacheKey":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_cr_addBuildCacheKey(ctx, field)
			})

		case "cr_deleteBuildCacheKey":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_cr_deleteBuildCacheKey(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "cr_updateBuildCacheKey":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_cr_updateBuildCacheKey(ctx, field)
			})

		case "cr_listBuildsByBuildCacheId":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_cr_listBuildsByBuildCacheId(ctx, field)
			})

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var pageInfoImplementors = []string{"PageInfo"}

func (ec *executionContext) _PageInfo(ctx context.Context, sel ast.SelectionSet, obj *model.PageInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, pageInfoImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PageInfo")
		case "endCursor":

			out.Values[i] = ec._PageInfo_endCursor(ctx, field, obj)

		case "hasNextPage":

			out.Values[i] = ec._PageInfo_hasNextPage(ctx, field, obj)

		case "hasPreviousPage":

			out.Values[i] = ec._PageInfo_hasPreviousPage(ctx, field, obj)

		case "startCursor":

			out.Values[i] = ec._PageInfo_startCursor(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var paginationImplementors = []string{"Pagination"}

func (ec *executionContext) _Pagination(ctx context.Context, sel ast.SelectionSet, obj *types.Pagination) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, paginationImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Pagination")
		case "page":

			out.Values[i] = ec._Pagination_page(ctx, field, obj)

		case "per_page":

			out.Values[i] = ec._Pagination_per_page(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "cr_listRepos":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_cr_listRepos(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "cr_listCreds":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_cr_listCreds(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "cr_listDigests":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_cr_listDigests(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "cr_getCredToken":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_cr_getCredToken(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "cr_checkUserNameAvailability":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_cr_checkUserNameAvailability(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "cr_getBuild":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_cr_getBuild(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "cr_listBuilds":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_cr_listBuilds(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "cr_listGithubInstallations":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_cr_listGithubInstallations(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "cr_listGithubRepos":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_cr_listGithubRepos(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "cr_searchGithubRepos":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_cr_searchGithubRepos(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "cr_listGithubBranches":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_cr_listGithubBranches(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "cr_listGitlabGroups":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_cr_listGitlabGroups(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "cr_listGitlabRepositories":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_cr_listGitlabRepositories(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "cr_listGitlabBranches":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_cr_listGitlabBranches(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "cr_listBuildCacheKeys":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_cr_listBuildCacheKeys(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "_service":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query__service(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "__type":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})

		case "__schema":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var repositoryImplementors = []string{"Repository"}

func (ec *executionContext) _Repository(ctx context.Context, sel ast.SelectionSet, obj *entities.Repository) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, repositoryImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Repository")
		case "accountName":

			out.Values[i] = ec._Repository_accountName(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "createdBy":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Repository_createdBy(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "creationTime":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Repository_creationTime(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "id":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Repository_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "lastUpdatedBy":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Repository_lastUpdatedBy(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "markedForDeletion":

			out.Values[i] = ec._Repository_markedForDeletion(ctx, field, obj)

		case "name":

			out.Values[i] = ec._Repository_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "recordVersion":

			out.Values[i] = ec._Repository_recordVersion(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "updateTime":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Repository_updateTime(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var repositoryEdgeImplementors = []string{"RepositoryEdge"}

func (ec *executionContext) _RepositoryEdge(ctx context.Context, sel ast.SelectionSet, obj *model.RepositoryEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, repositoryEdgeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RepositoryEdge")
		case "cursor":

			out.Values[i] = ec._RepositoryEdge_cursor(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "node":

			out.Values[i] = ec._RepositoryEdge_node(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var repositoryPaginatedRecordsImplementors = []string{"RepositoryPaginatedRecords"}

func (ec *executionContext) _RepositoryPaginatedRecords(ctx context.Context, sel ast.SelectionSet, obj *model.RepositoryPaginatedRecords) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, repositoryPaginatedRecordsImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RepositoryPaginatedRecords")
		case "edges":

			out.Values[i] = ec._RepositoryPaginatedRecords_edges(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "pageInfo":

			out.Values[i] = ec._RepositoryPaginatedRecords_pageInfo(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalCount":

			out.Values[i] = ec._RepositoryPaginatedRecords_totalCount(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var _ServiceImplementors = []string{"_Service"}

func (ec *executionContext) __Service(ctx context.Context, sel ast.SelectionSet, obj *fedruntime.Service) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, _ServiceImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("_Service")
		case "sdl":

			out.Values[i] = ec.__Service_sdl(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":

			out.Values[i] = ec.___Directive_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___Directive_description(ctx, field, obj)

		case "locations":

			out.Values[i] = ec.___Directive_locations(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "args":

			out.Values[i] = ec.___Directive_args(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isRepeatable":

			out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":

			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)

		case "isDeprecated":

			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":

			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":

			out.Values[i] = ec.___Field_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___Field_description(ctx, field, obj)

		case "args":

			out.Values[i] = ec.___Field_args(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "type":

			out.Values[i] = ec.___Field_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isDeprecated":

			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":

			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":

			out.Values[i] = ec.___InputValue_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___InputValue_description(ctx, field, obj)

		case "type":

			out.Values[i] = ec.___InputValue_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "defaultValue":

			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":

			out.Values[i] = ec.___Schema_description(ctx, field, obj)

		case "types":

			out.Values[i] = ec.___Schema_types(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "queryType":

			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "mutationType":

			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)

		case "subscriptionType":

			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)

		case "directives":

			out.Values[i] = ec.___Schema_directives(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":

			out.Values[i] = ec.___Type_kind(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":

			out.Values[i] = ec.___Type_name(ctx, field, obj)

		case "description":

			out.Values[i] = ec.___Type_description(ctx, field, obj)

		case "fields":

			out.Values[i] = ec.___Type_fields(ctx, field, obj)

		case "interfaces":

			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)

		case "possibleTypes":

			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)

		case "enumValues":

			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)

		case "inputFields":

			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)

		case "ofType":

			out.Values[i] = ec.___Type_ofType(ctx, field, obj)

		case "specifiedByURL":

			out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) unmarshalNAny2interface(ctx context.Context, v interface{}) (any, error) {
	res, err := graphql.UnmarshalAny(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAny2interface(ctx context.Context, sel ast.SelectionSet, v any) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	res := graphql.MarshalAny(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNBuild2kloudliteioappscontainerregistryinternaldomainentitiesBuild(ctx context.Context, sel ast.SelectionSet, v *entities.Build) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Build(ctx, sel, v)
}

func (ec *executionContext) marshalNBuildCacheKey2kloudliteioappscontainerregistryinternaldomainentitiesBuildCacheKey(ctx context.Context, sel ast.SelectionSet, v *entities.BuildCacheKey) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._BuildCacheKey(ctx, sel, v)
}

func (ec *executionContext) marshalNBuildCacheKeyEdge2kloudliteioappscontainerregistryinternalappgraphmodelBuildCacheKeyEdge(ctx context.Context, sel ast.SelectionSet, v []*model.BuildCacheKeyEdge) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNBuildCacheKeyEdge2kloudliteioappscontainerregistryinternalappgraphmodelBuildCacheKeyEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNBuildCacheKeyEdge2kloudliteioappscontainerregistryinternalappgraphmodelBuildCacheKeyEdge(ctx context.Context, sel ast.SelectionSet, v *model.BuildCacheKeyEdge) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._BuildCacheKeyEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalNBuildCacheKeyIn2kloudliteioappscontainerregistryinternaldomainentitiesBuildCacheKey(ctx context.Context, v interface{}) (entities.BuildCacheKey, error) {
	res, err := ec.unmarshalInputBuildCacheKeyIn(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBuildEdge2kloudliteioappscontainerregistryinternalappgraphmodelBuildEdge(ctx context.Context, sel ast.SelectionSet, v []*model.BuildEdge) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNBuildEdge2kloudliteioappscontainerregistryinternalappgraphmodelBuildEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNBuildEdge2kloudliteioappscontainerregistryinternalappgraphmodelBuildEdge(ctx context.Context, sel ast.SelectionSet, v *model.BuildEdge) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._BuildEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalNBuildIn2kloudliteioappscontainerregistryinternaldomainentitiesBuild(ctx context.Context, v interface{}) (entities.Build, error) {
	res, err := ec.unmarshalInputBuildIn(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCRCheckNameAvailabilityOutput2kloudliteioappscontainerregistryinternaldomainCheckNameAvailabilityOutput(ctx context.Context, sel ast.SelectionSet, v domain.CheckNameAvailabilityOutput) graphql.Marshaler {
	return ec._CRCheckNameAvailabilityOutput(ctx, sel, &v)
}

func (ec *executionContext) marshalNCRCheckNameAvailabilityOutput2kloudliteioappscontainerregistryinternaldomainCheckNameAvailabilityOutput(ctx context.Context, sel ast.SelectionSet, v *domain.CheckNameAvailabilityOutput) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CRCheckNameAvailabilityOutput(ctx, sel, v)
}

func (ec *executionContext) marshalNCredential2kloudliteioappscontainerregistryinternaldomainentitiesCredential(ctx context.Context, sel ast.SelectionSet, v *entities.Credential) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Credential(ctx, sel, v)
}

func (ec *executionContext) marshalNCredentialEdge2kloudliteioappscontainerregistryinternalappgraphmodelCredentialEdge(ctx context.Context, sel ast.SelectionSet, v []*model.CredentialEdge) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCredentialEdge2kloudliteioappscontainerregistryinternalappgraphmodelCredentialEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNCredentialEdge2kloudliteioappscontainerregistryinternalappgraphmodelCredentialEdge(ctx context.Context, sel ast.SelectionSet, v *model.CredentialEdge) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CredentialEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCredentialIn2kloudliteioappscontainerregistryinternaldomainentitiesCredential(ctx context.Context, v interface{}) (entities.Credential, error) {
	res, err := ec.unmarshalInputCredentialIn(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNDate2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDate2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNDigest2kloudliteioappscontainerregistryinternaldomainentitiesDigest(ctx context.Context, sel ast.SelectionSet, v *entities.Digest) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Digest(ctx, sel, v)
}

func (ec *executionContext) marshalNDigestEdge2kloudliteioappscontainerregistryinternalappgraphmodelDigestEdge(ctx context.Context, sel ast.SelectionSet, v []*model.DigestEdge) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNDigestEdge2kloudliteioappscontainerregistryinternalappgraphmodelDigestEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNDigestEdge2kloudliteioappscontainerregistryinternalappgraphmodelDigestEdge(ctx context.Context, sel ast.SelectionSet, v *model.DigestEdge) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DigestEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalNFloat2float64(ctx context.Context, v interface{}) (float64, error) {
	res, err := graphql.UnmarshalFloatContext(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFloat2float64(ctx context.Context, sel ast.SelectionSet, v float64) graphql.Marshaler {
	res := graphql.MarshalFloatContext(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return graphql.WrapContextMarshaler(ctx, res)
}

func (ec *executionContext) marshalNGitBranch2kloudliteioappscontainerregistryinternaldomainentitiesGitBranch(ctx context.Context, sel ast.SelectionSet, v *entities.GitBranch) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GitBranch(ctx, sel, v)
}

func (ec *executionContext) marshalNGithubInstallation2kloudliteioappscontainerregistryinternaldomainentitiesGithubInstallation(ctx context.Context, sel ast.SelectionSet, v *entities.GithubInstallation) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GithubInstallation(ctx, sel, v)
}

func (ec *executionContext) marshalNGitlabGroup2kloudliteioappscontainerregistryinternaldomainentitiesGitlabGroup(ctx context.Context, sel ast.SelectionSet, v *entities.GitlabGroup) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GitlabGroup(ctx, sel, v)
}

func (ec *executionContext) marshalNGitlabProject2kloudliteioappscontainerregistryinternaldomainentitiesGitlabProject(ctx context.Context, sel ast.SelectionSet, v *entities.GitlabProject) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GitlabProject(ctx, sel, v)
}

func (ec *executionContext) unmarshalNID2kloudliteiopkgreposID(ctx context.Context, v interface{}) (repos.ID, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := repos.ID(tmp)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNID2kloudliteiopkgreposID(ctx context.Context, sel ast.SelectionSet, v repos.ID) graphql.Marshaler {
	res := graphql.MarshalString(string(v))
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v interface{}) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNKloudlite_io__apps__container___registry__internal__domain__entities_BuildStatus2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoAppsContainerRegistryInternalDomainEntitiesBuildStatus(ctx context.Context, v interface{}) (model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesBuildStatus, error) {
	var res model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesBuildStatus
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNKloudlite_io__apps__container___registry__internal__domain__entities_BuildStatus2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoAppsContainerRegistryInternalDomainEntitiesBuildStatus(ctx context.Context, sel ast.SelectionSet, v model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesBuildStatus) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNKloudlite_io__apps__container___registry__internal__domain__entities_Expiration2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoAppsContainerRegistryInternalDomainEntitiesExpiration(ctx context.Context, sel ast.SelectionSet, v model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesExpiration) graphql.Marshaler {
	return ec._Kloudlite_io__apps__container___registry__internal__domain__entities_Expiration(ctx, sel, &v)
}

func (ec *executionContext) marshalNKloudlite_io__apps__container___registry__internal__domain__entities_Expiration2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoAppsContainerRegistryInternalDomainEntitiesExpiration(ctx context.Context, sel ast.SelectionSet, v *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesExpiration) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Kloudlite_io__apps__container___registry__internal__domain__entities_Expiration(ctx, sel, v)
}

func (ec *executionContext) unmarshalNKloudlite_io__apps__container___registry__internal__domain__entities_ExpirationIn2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoAppsContainerRegistryInternalDomainEntitiesExpirationIn(ctx context.Context, v interface{}) (model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesExpirationIn, error) {
	res, err := ec.unmarshalInputKloudlite_io__apps__container___registry__internal__domain__entities_ExpirationIn(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNKloudlite_io__apps__container___registry__internal__domain__entities_ExpirationIn2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoAppsContainerRegistryInternalDomainEntitiesExpirationIn(ctx context.Context, v interface{}) (*model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesExpirationIn, error) {
	res, err := ec.unmarshalInputKloudlite_io__apps__container___registry__internal__domain__entities_ExpirationIn(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNKloudlite_io__apps__container___registry__internal__domain__entities_ExpirationUnit2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoAppsContainerRegistryInternalDomainEntitiesExpirationUnit(ctx context.Context, v interface{}) (model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesExpirationUnit, error) {
	var res model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesExpirationUnit
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNKloudlite_io__apps__container___registry__internal__domain__entities_ExpirationUnit2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoAppsContainerRegistryInternalDomainEntitiesExpirationUnit(ctx context.Context, sel ast.SelectionSet, v model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesExpirationUnit) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNKloudlite_io__apps__container___registry__internal__domain__entities_GitProvider2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoAppsContainerRegistryInternalDomainEntitiesGitProvider(ctx context.Context, v interface{}) (model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGitProvider, error) {
	var res model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGitProvider
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNKloudlite_io__apps__container___registry__internal__domain__entities_GitProvider2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoAppsContainerRegistryInternalDomainEntitiesGitProvider(ctx context.Context, sel ast.SelectionSet, v model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGitProvider) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNKloudlite_io__apps__container___registry__internal__domain__entities_GitSource2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoAppsContainerRegistryInternalDomainEntitiesGitSource(ctx context.Context, sel ast.SelectionSet, v model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGitSource) graphql.Marshaler {
	return ec._Kloudlite_io__apps__container___registry__internal__domain__entities_GitSource(ctx, sel, &v)
}

func (ec *executionContext) marshalNKloudlite_io__apps__container___registry__internal__domain__entities_GitSource2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoAppsContainerRegistryInternalDomainEntitiesGitSource(ctx context.Context, sel ast.SelectionSet, v *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGitSource) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Kloudlite_io__apps__container___registry__internal__domain__entities_GitSource(ctx, sel, v)
}

func (ec *executionContext) unmarshalNKloudlite_io__apps__container___registry__internal__domain__entities_GitSourceIn2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoAppsContainerRegistryInternalDomainEntitiesGitSourceIn(ctx context.Context, v interface{}) (model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGitSourceIn, error) {
	res, err := ec.unmarshalInputKloudlite_io__apps__container___registry__internal__domain__entities_GitSourceIn(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNKloudlite_io__apps__container___registry__internal__domain__entities_GitSourceIn2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoAppsContainerRegistryInternalDomainEntitiesGitSourceIn(ctx context.Context, v interface{}) (*model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGitSourceIn, error) {
	res, err := ec.unmarshalInputKloudlite_io__apps__container___registry__internal__domain__entities_GitSourceIn(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNKloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubRepository(ctx context.Context, sel ast.SelectionSet, v []*model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubRepository) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOKloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubRepository(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) unmarshalNKloudlite_io__apps__container___registry__internal__domain__entities_RepoAccess2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoAppsContainerRegistryInternalDomainEntitiesRepoAccess(ctx context.Context, v interface{}) (model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesRepoAccess, error) {
	var res model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesRepoAccess
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNKloudlite_io__apps__container___registry__internal__domain__entities_RepoAccess2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoAppsContainerRegistryInternalDomainEntitiesRepoAccess(ctx context.Context, sel ast.SelectionSet, v model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesRepoAccess) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNKloudlite_io__common_CreatedOrUpdatedBy2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoCommonCreatedOrUpdatedBy(ctx context.Context, sel ast.SelectionSet, v model.KloudliteIoCommonCreatedOrUpdatedBy) graphql.Marshaler {
	return ec._Kloudlite_io__common_CreatedOrUpdatedBy(ctx, sel, &v)
}

func (ec *executionContext) marshalNKloudlite_io__common_CreatedOrUpdatedBy2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoCommonCreatedOrUpdatedBy(ctx context.Context, sel ast.SelectionSet, v *model.KloudliteIoCommonCreatedOrUpdatedBy) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Kloudlite_io__common_CreatedOrUpdatedBy(ctx, sel, v)
}

func (ec *executionContext) unmarshalNMap2map(ctx context.Context, v interface{}) (map[string]interface{}, error) {
	res, err := graphql.UnmarshalMap(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMap2map(ctx context.Context, sel ast.SelectionSet, v map[string]interface{}) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	res := graphql.MarshalMap(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNMatchFilterMatchType2kloudliteiopkgreposMatchType(ctx context.Context, v interface{}) (repos.MatchType, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := repos.MatchType(tmp)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMatchFilterMatchType2kloudliteiopkgreposMatchType(ctx context.Context, sel ast.SelectionSet, v repos.MatchType) graphql.Marshaler {
	res := graphql.MarshalString(string(v))
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNPageInfo2kloudliteioappscontainerregistryinternalappgraphmodelPageInfo(ctx context.Context, sel ast.SelectionSet, v *model.PageInfo) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PageInfo(ctx, sel, v)
}

func (ec *executionContext) marshalNRepository2kloudliteioappscontainerregistryinternaldomainentitiesRepository(ctx context.Context, sel ast.SelectionSet, v *entities.Repository) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Repository(ctx, sel, v)
}

func (ec *executionContext) marshalNRepositoryEdge2kloudliteioappscontainerregistryinternalappgraphmodelRepositoryEdge(ctx context.Context, sel ast.SelectionSet, v []*model.RepositoryEdge) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRepositoryEdge2kloudliteioappscontainerregistryinternalappgraphmodelRepositoryEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNRepositoryEdge2kloudliteioappscontainerregistryinternalappgraphmodelRepositoryEdge(ctx context.Context, sel ast.SelectionSet, v *model.RepositoryEdge) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RepositoryEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalNRepositoryIn2kloudliteioappscontainerregistryinternaldomainentitiesRepository(ctx context.Context, v interface{}) (entities.Repository, error) {
	res, err := ec.unmarshalInputRepositoryIn(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN_FieldSet2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN_FieldSet2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalN_Service2githubcom99designsgqlgenpluginfederationfedruntimeService(ctx context.Context, sel ast.SelectionSet, v fedruntime.Service) graphql.Marshaler {
	return ec.__Service(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalOAny2interface(ctx context.Context, v interface{}) (any, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalAny(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOAny2interface(ctx context.Context, sel ast.SelectionSet, v any) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalAny(v)
	return res
}

func (ec *executionContext) unmarshalOAny2interface(ctx context.Context, v interface{}) ([]any, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]any, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNAny2interface(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOAny2interface(ctx context.Context, sel ast.SelectionSet, v []any) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNAny2interface(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalBoolean(*v)
	return res
}

func (ec *executionContext) marshalOBuild2kloudliteioappscontainerregistryinternaldomainentitiesBuild(ctx context.Context, sel ast.SelectionSet, v *entities.Build) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Build(ctx, sel, v)
}

func (ec *executionContext) marshalOBuildCacheKey2kloudliteioappscontainerregistryinternaldomainentitiesBuildCacheKey(ctx context.Context, sel ast.SelectionSet, v *entities.BuildCacheKey) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._BuildCacheKey(ctx, sel, v)
}

func (ec *executionContext) marshalOBuildCacheKeyPaginatedRecords2kloudliteioappscontainerregistryinternalappgraphmodelBuildCacheKeyPaginatedRecords(ctx context.Context, sel ast.SelectionSet, v *model.BuildCacheKeyPaginatedRecords) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._BuildCacheKeyPaginatedRecords(ctx, sel, v)
}

func (ec *executionContext) marshalOBuildPaginatedRecords2kloudliteioappscontainerregistryinternalappgraphmodelBuildPaginatedRecords(ctx context.Context, sel ast.SelectionSet, v *model.BuildPaginatedRecords) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._BuildPaginatedRecords(ctx, sel, v)
}

func (ec *executionContext) marshalOCredential2kloudliteioappscontainerregistryinternaldomainentitiesCredential(ctx context.Context, sel ast.SelectionSet, v *entities.Credential) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Credential(ctx, sel, v)
}

func (ec *executionContext) marshalOCredentialPaginatedRecords2kloudliteioappscontainerregistryinternalappgraphmodelCredentialPaginatedRecords(ctx context.Context, sel ast.SelectionSet, v *model.CredentialPaginatedRecords) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CredentialPaginatedRecords(ctx, sel, v)
}

func (ec *executionContext) unmarshalOCursorPaginationIn2kloudliteiopkgreposCursorPagination(ctx context.Context, v interface{}) (*repos.CursorPagination, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCursorPaginationIn(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOCursorPaginationSortDirection2kloudliteiopkgreposSortDirection(ctx context.Context, v interface{}) (repos.SortDirection, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := repos.SortDirection(tmp)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOCursorPaginationSortDirection2kloudliteiopkgreposSortDirection(ctx context.Context, sel ast.SelectionSet, v repos.SortDirection) graphql.Marshaler {
	res := graphql.MarshalString(string(v))
	return res
}

func (ec *executionContext) unmarshalODate2string(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalODate2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) marshalODigestPaginatedRecords2kloudliteioappscontainerregistryinternalappgraphmodelDigestPaginatedRecords(ctx context.Context, sel ast.SelectionSet, v *model.DigestPaginatedRecords) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._DigestPaginatedRecords(ctx, sel, v)
}

func (ec *executionContext) marshalOGitBranch2kloudliteioappscontainerregistryinternaldomainentitiesGitBranch(ctx context.Context, sel ast.SelectionSet, v []*entities.GitBranch) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGitBranch2kloudliteioappscontainerregistryinternaldomainentitiesGitBranch(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOGithubInstallation2kloudliteioappscontainerregistryinternaldomainentitiesGithubInstallation(ctx context.Context, sel ast.SelectionSet, v []*entities.GithubInstallation) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGithubInstallation2kloudliteioappscontainerregistryinternaldomainentitiesGithubInstallation(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOGithubListRepository2kloudliteioappscontainerregistryinternaldomainentitiesGithubListRepository(ctx context.Context, sel ast.SelectionSet, v *entities.GithubListRepository) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GithubListRepository(ctx, sel, v)
}

func (ec *executionContext) marshalOGithubSearchRepository2kloudliteioappscontainerregistryinternaldomainentitiesGithubSearchRepository(ctx context.Context, sel ast.SelectionSet, v *entities.GithubSearchRepository) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GithubSearchRepository(ctx, sel, v)
}

func (ec *executionContext) marshalOGitlabGroup2kloudliteioappscontainerregistryinternaldomainentitiesGitlabGroup(ctx context.Context, sel ast.SelectionSet, v []*entities.GitlabGroup) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGitlabGroup2kloudliteioappscontainerregistryinternaldomainentitiesGitlabGroup(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOGitlabProject2kloudliteioappscontainerregistryinternaldomainentitiesGitlabProject(ctx context.Context, sel ast.SelectionSet, v []*entities.GitlabProject) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGitlabProject2kloudliteioappscontainerregistryinternaldomainentitiesGitlabProject(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v interface{}) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	return res
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalInt(*v)
	return res
}

func (ec *executionContext) unmarshalOInt2int64(ctx context.Context, v interface{}) (*int64, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt64(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2int64(ctx context.Context, sel ast.SelectionSet, v *int64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalInt64(*v)
	return res
}

func (ec *executionContext) marshalOKloudlite_io__apps__container___registry__internal__domain__entities_BuildOptions2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoAppsContainerRegistryInternalDomainEntitiesBuildOptions(ctx context.Context, sel ast.SelectionSet, v *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesBuildOptions) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Kloudlite_io__apps__container___registry__internal__domain__entities_BuildOptions(ctx, sel, v)
}

func (ec *executionContext) unmarshalOKloudlite_io__apps__container___registry__internal__domain__entities_BuildOptionsIn2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoAppsContainerRegistryInternalDomainEntitiesBuildOptionsIn(ctx context.Context, v interface{}) (*model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesBuildOptionsIn, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputKloudlite_io__apps__container___registry__internal__domain__entities_BuildOptionsIn(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOKloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubRepository(ctx context.Context, sel ast.SelectionSet, v *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubRepository) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Kloudlite_io__apps__container___registry__internal__domain__entities_GithubRepository(ctx, sel, v)
}

func (ec *executionContext) marshalOKloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount2kloudliteioappscontainerregistryinternalappgraphmodelKloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubUserAccount(ctx context.Context, sel ast.SelectionSet, v *model.KloudliteIoAppsContainerRegistryInternalDomainEntitiesGithubUserAccount) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Kloudlite_io__apps__container___registry__internal__domain__entities_GithubUserAccount(ctx, sel, v)
}

func (ec *executionContext) unmarshalOMap2map(ctx context.Context, v interface{}) (map[string]interface{}, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalMap(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOMap2map(ctx context.Context, sel ast.SelectionSet, v map[string]interface{}) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalMap(v)
	return res
}

func (ec *executionContext) unmarshalOMatchFilterIn2kloudliteiopkgreposMatchFilter(ctx context.Context, v interface{}) (*repos.MatchFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputMatchFilterIn(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOPaginationIn2kloudliteiopkgtypesPagination(ctx context.Context, v interface{}) (*types.Pagination, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputPaginationIn(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalORepository2kloudliteioappscontainerregistryinternaldomainentitiesRepository(ctx context.Context, sel ast.SelectionSet, v *entities.Repository) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Repository(ctx, sel, v)
}

func (ec *executionContext) marshalORepositoryPaginatedRecords2kloudliteioappscontainerregistryinternalappgraphmodelRepositoryPaginatedRecords(ctx context.Context, sel ast.SelectionSet, v *model.RepositoryPaginatedRecords) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._RepositoryPaginatedRecords(ctx, sel, v)
}

func (ec *executionContext) unmarshalOSearchBuildCacheKeys2kloudliteioappscontainerregistryinternalappgraphmodelSearchBuildCacheKeys(ctx context.Context, v interface{}) (*model.SearchBuildCacheKeys, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputSearchBuildCacheKeys(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOSearchBuilds2kloudliteioappscontainerregistryinternalappgraphmodelSearchBuilds(ctx context.Context, v interface{}) (*model.SearchBuilds, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputSearchBuilds(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOSearchCreds2kloudliteioappscontainerregistryinternalappgraphmodelSearchCreds(ctx context.Context, v interface{}) (*model.SearchCreds, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputSearchCreds(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOSearchRepos2kloudliteioappscontainerregistryinternalappgraphmodelSearchRepos(ctx context.Context, v interface{}) (*model.SearchRepos, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputSearchRepos(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	return res
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
