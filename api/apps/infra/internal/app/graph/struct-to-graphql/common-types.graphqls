type Github__com___kloudlite___api___apps___infra___internal___entities__AWSSecretCredentials @shareable {
  accessKey: String
  awsAccountId: String
  cfParamExternalID: String
  cfParamInstanceProfileName: String
  cfParamRoleName: String
  cfParamStackName: String
  cfParamTrustedARN: String
  secretKey: String
}

type Github__com___kloudlite___api___apps___infra___internal___entities__InputField @shareable {
  defaultValue: Any
  displayUnit: String
  inputType: String!
  label: String!
  max: Float
  min: Float
  multiplier: Float
  name: String!
  required: Boolean
  unit: String
}

type Github__com___kloudlite___api___apps___infra___internal___entities__MresTemplate @shareable {
  apiVersion: String
  description: String!
  displayName: String!
  fields: [Github__com___kloudlite___api___apps___infra___internal___entities__InputField!]!
  kind: String
  name: String!
  outputs: [Github__com___kloudlite___api___apps___infra___internal___entities__OutputField!]!
}

type Github__com___kloudlite___api___apps___infra___internal___entities__MsvcTemplateEntry @shareable {
  active: Boolean!
  apiVersion: String
  description: String!
  displayName: String!
  fields: [Github__com___kloudlite___api___apps___infra___internal___entities__InputField!]!
  kind: String
  logoUrl: String!
  name: String!
  outputs: [Github__com___kloudlite___api___apps___infra___internal___entities__OutputField!]!
  resources: [Github__com___kloudlite___api___apps___infra___internal___entities__MresTemplate!]!
}

type Github__com___kloudlite___api___apps___infra___internal___entities__OutputField @shareable {
  description: String!
  label: String!
  name: String!
}

type Github__com___kloudlite___api___common__CreatedOrUpdatedBy @shareable {
  userEmail: String!
  userId: String!
  userName: String!
}

type Github__com___kloudlite___api___pkg___types__EncodedString @shareable {
  encoding: String!
  value: String!
}

type Github__com___kloudlite___api___pkg___types__SyncStatus @shareable {
  action: Github__com___kloudlite___api___pkg___types__SyncAction!
  error: String
  lastSyncedAt: Date
  recordVersion: Int!
  state: Github__com___kloudlite___api___pkg___types__SyncState!
  syncScheduledAt: Date
}

type Github__com___kloudlite___operator___apis___clusters___v1__AWSClusterConfig @shareable {
  k3sMasters: Github__com___kloudlite___operator___apis___clusters___v1__AWSK3sMastersConfig
  nodePools: Map
  region: String!
  spotNodePools: Map
}

type Github__com___kloudlite___operator___apis___clusters___v1__AWSK3sMastersConfig @shareable {
  iamInstanceProfileRole: String
  imageId: String!
  imageSSHUsername: String!
  instanceType: String!
  nodes: Map
  nvidiaGpuEnabled: Boolean!
  rootVolumeSize: Int!
  rootVolumeType: String!
}

type Github__com___kloudlite___operator___apis___clusters___v1__AWSNodePoolConfig @shareable {
  availabilityZone: String!
  ec2Pool: Github__com___kloudlite___operator___apis___clusters___v1__AwsEC2PoolConfig
  iamInstanceProfileRole: String
  imageId: String!
  imageSSHUsername: String!
  nvidiaGpuEnabled: Boolean!
  poolType: Github__com___kloudlite___operator___apis___clusters___v1__AWSPoolType!
  rootVolumeSize: Int!
  rootVolumeType: String!
  spotPool: Github__com___kloudlite___operator___apis___clusters___v1__AwsSpotPoolConfig
}

type Github__com___kloudlite___operator___apis___clusters___v1__AwsEC2PoolConfig @shareable {
  instanceType: String!
  nodes: Map
}

type Github__com___kloudlite___operator___apis___clusters___v1__AwsSpotCpuNode @shareable {
  memoryPerVcpu: Github__com___kloudlite___operator___apis___common____types__MinMaxFloat
  vcpu: Github__com___kloudlite___operator___apis___common____types__MinMaxFloat!
}

type Github__com___kloudlite___operator___apis___clusters___v1__AwsSpotGpuNode @shareable {
  instanceTypes: [String!]!
}

type Github__com___kloudlite___operator___apis___clusters___v1__AwsSpotPoolConfig @shareable {
  cpuNode: Github__com___kloudlite___operator___apis___clusters___v1__AwsSpotCpuNode
  gpuNode: Github__com___kloudlite___operator___apis___clusters___v1__AwsSpotGpuNode
  nodes: Map
  spotFleetTaggingRoleName: String!
}

type Github__com___kloudlite___operator___apis___clusters___v1__CloudProviderCredentialKeys @shareable {
  keyAccessKey: String!
  keyAWSAccountId: String!
  keyAWSAssumeRoleExternalID: String!
  keyAWSAssumeRoleRoleARN: String!
  keyIAMInstanceProfileRole: String!
  keySecretKey: String!
}

type Github__com___kloudlite___operator___apis___clusters___v1__ClusterOutput @shareable {
  jobName: String!
  jobNamespace: String!
  keyK3sAgentJoinToken: String!
  keyK3sServerJoinToken: String!
  keyKubeconfig: String!
  secretName: String!
}

type Github__com___kloudlite___operator___apis___clusters___v1__ClusterSpec @shareable {
  accountId: String!
  accountName: String!
  availabilityMode: Github__com___kloudlite___operator___apis___clusters___v1__ClusterSpecAvailabilityMode!
  aws: Github__com___kloudlite___operator___apis___clusters___v1__AWSClusterConfig
  backupToS3Enabled: Boolean!
  cloudflareEnabled: Boolean
  cloudProvider: Github__com___kloudlite___operator___apis___common____types__CloudProvider!
  clusterInternalDnsHost: String
  clusterTokenRef: Github__com___kloudlite___operator___apis___common____types__SecretKeyRef
  credentialKeys: Github__com___kloudlite___operator___apis___clusters___v1__CloudProviderCredentialKeys
  credentialsRef: Github__com___kloudlite___operator___apis___common____types__SecretRef!
  kloudliteRelease: String!
  messageQueueTopicName: String!
  output: Github__com___kloudlite___operator___apis___clusters___v1__ClusterOutput
  publicDNSHost: String!
  taintMasterNodes: Boolean!
}

type Github__com___kloudlite___operator___apis___clusters___v1__InfrastuctureAsCode @shareable {
  cloudProviderAccessKey: Github__com___kloudlite___operator___apis___common____types__SecretKeyRef!
  cloudProviderSecretKey: Github__com___kloudlite___operator___apis___common____types__SecretKeyRef!
  jobName: String
  jobNamespace: String
  stateS3BucketFilePath: String!
  stateS3BucketName: String!
  stateS3BucketRegion: String!
}

type Github__com___kloudlite___operator___apis___clusters___v1__MasterNodeProps @shareable {
  availabilityZone: String!
  lastRecreatedAt: Date
  role: String!
}

type Github__com___kloudlite___operator___apis___clusters___v1__NodePoolSpec @shareable {
  aws: Github__com___kloudlite___operator___apis___clusters___v1__AWSNodePoolConfig
  cloudProvider: Github__com___kloudlite___operator___apis___common____types__CloudProvider!
  iac: Github__com___kloudlite___operator___apis___clusters___v1__InfrastuctureAsCode!
  maxCount: Int!
  minCount: Int!
  nodeLabels: Map
  nodeTaints: [K8s__io___api___core___v1__Taint!]
  targetCount: Int!
}

type Github__com___kloudlite___operator___apis___clusters___v1__NodeProps @shareable {
  lastRecreatedAt: Date
}

type Github__com___kloudlite___operator___apis___clusters___v1__NodeSpec @shareable {
  nodepoolName: String!
}

type Github__com___kloudlite___operator___apis___common____types__MinMaxFloat @shareable {
  max: String!
  min: String!
}

type Github__com___kloudlite___operator___apis___common____types__SecretKeyRef @shareable {
  key: String!
  name: String!
  namespace: String
}

type Github__com___kloudlite___operator___apis___common____types__SecretRef @shareable {
  name: String!
  namespace: String
}

type Github__com___kloudlite___operator___apis___crds___v1__ClusterManagedServiceSpec @shareable {
  msvcSpec: Github__com___kloudlite___operator___apis___crds___v1__ManagedServiceSpec!
  targetNamespace: String!
}

type Github__com___kloudlite___operator___apis___crds___v1__HelmChartSpec @shareable {
  chartName: String!
  chartRepoURL: String!
  chartVersion: String!
  jobVars: Github__com___kloudlite___operator___apis___crds___v1__JobVars
  postInstall: String
  postUninstall: String
  preInstall: String
  preUninstall: String
  values: Map!
}

type Github__com___kloudlite___operator___apis___crds___v1__HelmChartStatus @shareable {
  checks: Map
  isReady: Boolean!
  lastReadyGeneration: Int
  lastReconcileTime: Date
  message: Github__com___kloudlite___operator___pkg___raw____json__RawJson
  releaseNotes: String!
  releaseStatus: String!
  resources: [Github__com___kloudlite___operator___pkg___operator__ResourceRef!]
}

type Github__com___kloudlite___operator___apis___crds___v1__JobVars @shareable {
  affinity: K8s__io___api___core___v1__Affinity
  backOffLimit: Int
  nodeSelector: Map
  tolerations: [K8s__io___api___core___v1__Toleration!]
}

type Github__com___kloudlite___operator___apis___crds___v1__ManagedServiceSpec @shareable {
  serviceTemplate: Github__com___kloudlite___operator___apis___crds___v1__ServiceTemplate!
}

type Github__com___kloudlite___operator___apis___crds___v1__ServiceTemplate @shareable {
  apiVersion: String!
  kind: String!
  spec: Map!
}

type Github__com___kloudlite___operator___apis___wireguard___v1__CNameRecord @shareable {
  host: String
  target: String
}

type Github__com___kloudlite___operator___apis___wireguard___v1__DeviceSpec @shareable {
  cnameRecords: [Github__com___kloudlite___operator___apis___wireguard___v1__CNameRecord!]
  deviceNamespace: String
  disabled: Boolean
  nodeSelector: Map
  ports: [Github__com___kloudlite___operator___apis___wireguard___v1__Port!]
}

type Github__com___kloudlite___operator___apis___wireguard___v1__Port @shareable {
  port: Int
  targetPort: Int
}

type Github__com___kloudlite___operator___pkg___operator__Check @shareable {
  generation: Int
  message: String
  status: Boolean!
}

type Github__com___kloudlite___operator___pkg___operator__ResourceRef @shareable {
  apiVersion: String!
  kind: String!
  name: String!
  namespace: String!
}

type Github__com___kloudlite___operator___pkg___operator__Status @shareable {
  checks: Map
  isReady: Boolean!
  lastReadyGeneration: Int
  lastReconcileTime: Date
  message: Github__com___kloudlite___operator___pkg___raw____json__RawJson
  resources: [Github__com___kloudlite___operator___pkg___operator__ResourceRef!]
}

type Github__com___kloudlite___operator___pkg___raw____json__RawJson @shareable {
  RawMessage: Any
}

type K8s__io___api___core___v1__AWSElasticBlockStoreVolumeSource @shareable {
  fsType: String
  partition: Int
  readOnly: Boolean
  volumeID: String!
}

type K8s__io___api___core___v1__Affinity @shareable {
  nodeAffinity: K8s__io___api___core___v1__NodeAffinity
  podAffinity: K8s__io___api___core___v1__PodAffinity
  podAntiAffinity: K8s__io___api___core___v1__PodAntiAffinity
}

type K8s__io___api___core___v1__AzureDiskVolumeSource @shareable {
  cachingMode: String
  diskName: String!
  diskURI: String!
  fsType: String
  kind: String
  readOnly: Boolean
}

type K8s__io___api___core___v1__AzureFilePersistentVolumeSource @shareable {
  readOnly: Boolean
  secretName: String!
  secretNamespace: String
  shareName: String!
}

type K8s__io___api___core___v1__CSIPersistentVolumeSource @shareable {
  controllerExpandSecretRef: K8s__io___api___core___v1__SecretReference
  controllerPublishSecretRef: K8s__io___api___core___v1__SecretReference
  driver: String!
  fsType: String
  nodeExpandSecretRef: K8s__io___api___core___v1__SecretReference
  nodePublishSecretRef: K8s__io___api___core___v1__SecretReference
  nodeStageSecretRef: K8s__io___api___core___v1__SecretReference
  readOnly: Boolean
  volumeAttributes: Map
  volumeHandle: String!
}

type K8s__io___api___core___v1__CephFSPersistentVolumeSource @shareable {
  monitors: [String!]!
  path: String
  readOnly: Boolean
  secretFile: String
  secretRef: K8s__io___api___core___v1__SecretReference
  user: String
}

type K8s__io___api___core___v1__CinderPersistentVolumeSource @shareable {
  fsType: String
  readOnly: Boolean
  secretRef: K8s__io___api___core___v1__SecretReference
  volumeID: String!
}

type K8s__io___api___core___v1__FCVolumeSource @shareable {
  fsType: String
  lun: Int
  readOnly: Boolean
  targetWWNs: [String!]
  wwids: [String!]
}

type K8s__io___api___core___v1__FlexPersistentVolumeSource @shareable {
  driver: String!
  fsType: String
  options: Map
  readOnly: Boolean
  secretRef: K8s__io___api___core___v1__SecretReference
}

type K8s__io___api___core___v1__FlockerVolumeSource @shareable {
  datasetName: String
  datasetUUID: String
}

type K8s__io___api___core___v1__GCEPersistentDiskVolumeSource @shareable {
  fsType: String
  partition: Int
  pdName: String!
  readOnly: Boolean
}

type K8s__io___api___core___v1__GlusterfsPersistentVolumeSource @shareable {
  endpoints: String!
  endpointsNamespace: String
  path: String!
  readOnly: Boolean
}

type K8s__io___api___core___v1__HostPathVolumeSource @shareable {
  path: String!
  type: String
}

type K8s__io___api___core___v1__ISCSIPersistentVolumeSource @shareable {
  chapAuthDiscovery: Boolean
  chapAuthSession: Boolean
  fsType: String
  initiatorName: String
  iqn: String!
  iscsiInterface: String
  lun: Int!
  portals: [String!]
  readOnly: Boolean
  secretRef: K8s__io___api___core___v1__SecretReference
  targetPortal: String!
}

type K8s__io___api___core___v1__LocalVolumeSource @shareable {
  fsType: String
  path: String!
}

type K8s__io___api___core___v1__NFSVolumeSource @shareable {
  path: String!
  readOnly: Boolean
  server: String!
}

type K8s__io___api___core___v1__NamespaceCondition @shareable {
  lastTransitionTime: Date
  message: String
  reason: String
  status: K8s__io___api___core___v1__ConditionStatus!
  type: K8s__io___api___core___v1__NamespaceConditionType!
}

type K8s__io___api___core___v1__NamespaceSpec @shareable {
  finalizers: [String!]
}

type K8s__io___api___core___v1__NamespaceStatus @shareable {
  conditions: [K8s__io___api___core___v1__NamespaceCondition!]
  phase: K8s__io___api___core___v1__NamespacePhase
}

type K8s__io___api___core___v1__NodeAffinity @shareable {
  preferredDuringSchedulingIgnoredDuringExecution: [K8s__io___api___core___v1__PreferredSchedulingTerm!]
  requiredDuringSchedulingIgnoredDuringExecution: K8s__io___api___core___v1__NodeSelector
}

type K8s__io___api___core___v1__NodeSelector @shareable {
  nodeSelectorTerms: [K8s__io___api___core___v1__NodeSelectorTerm!]!
}

type K8s__io___api___core___v1__NodeSelectorRequirement @shareable {
  key: String!
  operator: K8s__io___api___core___v1__NodeSelectorOperator!
  values: [String!]
}

type K8s__io___api___core___v1__NodeSelectorTerm @shareable {
  matchExpressions: [K8s__io___api___core___v1__NodeSelectorRequirement!]
  matchFields: [K8s__io___api___core___v1__NodeSelectorRequirement!]
}

type K8s__io___api___core___v1__ObjectReference @shareable {
  apiVersion: String
  fieldPath: String
  kind: String
  name: String
  namespace: String
  resourceVersion: String
  uid: String
}

type K8s__io___api___core___v1__PersistentVolumeClaimCondition @shareable {
  lastProbeTime: Date
  lastTransitionTime: Date
  message: String
  reason: String
  status: K8s__io___api___core___v1__ConditionStatus!
  type: K8s__io___api___core___v1__PersistentVolumeClaimConditionType!
}

type K8s__io___api___core___v1__PersistentVolumeClaimSpec @shareable {
  accessModes: [String!]
  dataSource: K8s__io___api___core___v1__TypedLocalObjectReference
  dataSourceRef: K8s__io___api___core___v1__TypedObjectReference
  resources: K8s__io___api___core___v1__ResourceRequirements
  selector: K8s__io___apimachinery___pkg___apis___meta___v1__LabelSelector
  storageClassName: String
  volumeMode: String
  volumeName: String
}

type K8s__io___api___core___v1__PersistentVolumeClaimStatus @shareable {
  accessModes: [String!]
  allocatedResources: Map
  allocatedResourceStatuses: Map
  capacity: Map
  conditions: [K8s__io___api___core___v1__PersistentVolumeClaimCondition!]
  phase: K8s__io___api___core___v1__PersistentVolumeClaimPhase
}

type K8s__io___api___core___v1__PersistentVolumeSpec @shareable {
  accessModes: [String!]
  awsElasticBlockStore: K8s__io___api___core___v1__AWSElasticBlockStoreVolumeSource
  azureDisk: K8s__io___api___core___v1__AzureDiskVolumeSource
  azureFile: K8s__io___api___core___v1__AzureFilePersistentVolumeSource
  capacity: Map
  cephfs: K8s__io___api___core___v1__CephFSPersistentVolumeSource
  cinder: K8s__io___api___core___v1__CinderPersistentVolumeSource
  claimRef: K8s__io___api___core___v1__ObjectReference
  csi: K8s__io___api___core___v1__CSIPersistentVolumeSource
  fc: K8s__io___api___core___v1__FCVolumeSource
  flexVolume: K8s__io___api___core___v1__FlexPersistentVolumeSource
  flocker: K8s__io___api___core___v1__FlockerVolumeSource
  gcePersistentDisk: K8s__io___api___core___v1__GCEPersistentDiskVolumeSource
  glusterfs: K8s__io___api___core___v1__GlusterfsPersistentVolumeSource
  hostPath: K8s__io___api___core___v1__HostPathVolumeSource
  iscsi: K8s__io___api___core___v1__ISCSIPersistentVolumeSource
  local: K8s__io___api___core___v1__LocalVolumeSource
  mountOptions: [String!]
  nfs: K8s__io___api___core___v1__NFSVolumeSource
  nodeAffinity: K8s__io___api___core___v1__VolumeNodeAffinity
  persistentVolumeReclaimPolicy: K8s__io___api___core___v1__PersistentVolumeReclaimPolicy
  photonPersistentDisk: K8s__io___api___core___v1__PhotonPersistentDiskVolumeSource
  portworxVolume: K8s__io___api___core___v1__PortworxVolumeSource
  quobyte: K8s__io___api___core___v1__QuobyteVolumeSource
  rbd: K8s__io___api___core___v1__RBDPersistentVolumeSource
  scaleIO: K8s__io___api___core___v1__ScaleIOPersistentVolumeSource
  storageClassName: String
  storageos: K8s__io___api___core___v1__StorageOSPersistentVolumeSource
  volumeMode: String
  vsphereVolume: K8s__io___api___core___v1__VsphereVirtualDiskVolumeSource
}

type K8s__io___api___core___v1__PersistentVolumeStatus @shareable {
  lastPhaseTransitionTime: Date
  message: String
  phase: K8s__io___api___core___v1__PersistentVolumePhase
  reason: String
}

type K8s__io___api___core___v1__PhotonPersistentDiskVolumeSource @shareable {
  fsType: String
  pdID: String!
}

type K8s__io___api___core___v1__PodAffinity @shareable {
  preferredDuringSchedulingIgnoredDuringExecution: [K8s__io___api___core___v1__WeightedPodAffinityTerm!]
  requiredDuringSchedulingIgnoredDuringExecution: [K8s__io___api___core___v1__PodAffinityTerm!]
}

type K8s__io___api___core___v1__PodAffinityTerm @shareable {
  labelSelector: K8s__io___apimachinery___pkg___apis___meta___v1__LabelSelector
  namespaces: [String!]
  namespaceSelector: K8s__io___apimachinery___pkg___apis___meta___v1__LabelSelector
  topologyKey: String!
}

type K8s__io___api___core___v1__PodAntiAffinity @shareable {
  preferredDuringSchedulingIgnoredDuringExecution: [K8s__io___api___core___v1__WeightedPodAffinityTerm!]
  requiredDuringSchedulingIgnoredDuringExecution: [K8s__io___api___core___v1__PodAffinityTerm!]
}

type K8s__io___api___core___v1__PortworxVolumeSource @shareable {
  fsType: String
  readOnly: Boolean
  volumeID: String!
}

type K8s__io___api___core___v1__PreferredSchedulingTerm @shareable {
  preference: K8s__io___api___core___v1__NodeSelectorTerm!
  weight: Int!
}

type K8s__io___api___core___v1__QuobyteVolumeSource @shareable {
  group: String
  readOnly: Boolean
  registry: String!
  tenant: String
  user: String
  volume: String!
}

type K8s__io___api___core___v1__RBDPersistentVolumeSource @shareable {
  fsType: String
  image: String!
  keyring: String
  monitors: [String!]!
  pool: String
  readOnly: Boolean
  secretRef: K8s__io___api___core___v1__SecretReference
  user: String
}

type K8s__io___api___core___v1__ResourceClaim @shareable {
  name: String!
}

type K8s__io___api___core___v1__ResourceRequirements @shareable {
  claims: [K8s__io___api___core___v1__ResourceClaim!]
  limits: Map
  requests: Map
}

type K8s__io___api___core___v1__ScaleIOPersistentVolumeSource @shareable {
  fsType: String
  gateway: String!
  protectionDomain: String
  readOnly: Boolean
  secretRef: K8s__io___api___core___v1__SecretReference
  sslEnabled: Boolean
  storageMode: String
  storagePool: String
  system: String!
  volumeName: String
}

type K8s__io___api___core___v1__SecretReference @shareable {
  name: String
  namespace: String
}

type K8s__io___api___core___v1__StorageOSPersistentVolumeSource @shareable {
  fsType: String
  readOnly: Boolean
  secretRef: K8s__io___api___core___v1__ObjectReference
  volumeName: String
  volumeNamespace: String
}

type K8s__io___api___core___v1__Taint @shareable {
  effect: K8s__io___api___core___v1__TaintEffect!
  key: String!
  timeAdded: Date
  value: String
}

type K8s__io___api___core___v1__Toleration @shareable {
  effect: K8s__io___api___core___v1__TaintEffect
  key: String
  operator: K8s__io___api___core___v1__TolerationOperator
  tolerationSeconds: Int
  value: String
}

type K8s__io___api___core___v1__TypedLocalObjectReference @shareable {
  apiGroup: String
  kind: String!
  name: String!
}

type K8s__io___api___core___v1__TypedObjectReference @shareable {
  apiGroup: String
  kind: String!
  name: String!
  namespace: String
}

type K8s__io___api___core___v1__VolumeNodeAffinity @shareable {
  required: K8s__io___api___core___v1__NodeSelector
}

type K8s__io___api___core___v1__VsphereVirtualDiskVolumeSource @shareable {
  fsType: String
  storagePolicyID: String
  storagePolicyName: String
  volumePath: String!
}

type K8s__io___api___core___v1__WeightedPodAffinityTerm @shareable {
  podAffinityTerm: K8s__io___api___core___v1__PodAffinityTerm!
  weight: Int!
}

type K8s__io___api___storage___v1__VolumeAttachmentSource @shareable {
  inlineVolumeSpec: K8s__io___api___core___v1__PersistentVolumeSpec
  persistentVolumeName: String
}

type K8s__io___api___storage___v1__VolumeAttachmentSpec @shareable {
  attacher: String!
  nodeName: String!
  source: K8s__io___api___storage___v1__VolumeAttachmentSource!
}

type K8s__io___api___storage___v1__VolumeAttachmentStatus @shareable {
  attached: Boolean!
  attachError: K8s__io___api___storage___v1__VolumeError
  attachmentMetadata: Map
  detachError: K8s__io___api___storage___v1__VolumeError
}

type K8s__io___api___storage___v1__VolumeError @shareable {
  message: String
  time: Date
}

type K8s__io___apimachinery___pkg___api___resource__Quantity @shareable {
  Format: K8s__io___apimachinery___pkg___api___resource__Format!
}

type K8s__io___apimachinery___pkg___apis___meta___v1__LabelSelector @shareable {
  matchExpressions: [K8s__io___apimachinery___pkg___apis___meta___v1__LabelSelectorRequirement!]
  matchLabels: Map
}

type K8s__io___apimachinery___pkg___apis___meta___v1__LabelSelectorRequirement @shareable {
  key: String!
  operator: K8s__io___apimachinery___pkg___apis___meta___v1__LabelSelectorOperator!
  values: [String!]
}

type Metadata @shareable {
  annotations: Map
  creationTimestamp: Date!
  deletionTimestamp: Date
  generation: Int!
  labels: Map
  name: String!
  namespace: String
}

type PageInfo @shareable {
  endCursor: String
  hasNextPage: Boolean
  hasPreviousPage: Boolean
  startCursor: String
}

input Github__com___kloudlite___api___apps___infra___internal___entities__AWSSecretCredentialsIn {
  accessKey: String
  awsAccountId: String
  secretKey: String
}

input Github__com___kloudlite___operator___apis___clusters___v1__AWSClusterConfigIn {
  k3sMasters: Github__com___kloudlite___operator___apis___clusters___v1__AWSK3sMastersConfigIn
  region: String!
}

input Github__com___kloudlite___operator___apis___clusters___v1__AWSK3sMastersConfigIn {
  instanceType: String!
  nvidiaGpuEnabled: Boolean!
}

input Github__com___kloudlite___operator___apis___clusters___v1__AWSNodePoolConfigIn {
  availabilityZone: String!
  ec2Pool: Github__com___kloudlite___operator___apis___clusters___v1__AwsEC2PoolConfigIn
  nvidiaGpuEnabled: Boolean!
  poolType: Github__com___kloudlite___operator___apis___clusters___v1__AWSPoolType!
  spotPool: Github__com___kloudlite___operator___apis___clusters___v1__AwsSpotPoolConfigIn
}

input Github__com___kloudlite___operator___apis___clusters___v1__AwsEC2PoolConfigIn {
  instanceType: String!
  nodes: Map
}

input Github__com___kloudlite___operator___apis___clusters___v1__AwsSpotCpuNodeIn {
  memoryPerVcpu: Github__com___kloudlite___operator___apis___common____types__MinMaxFloatIn
  vcpu: Github__com___kloudlite___operator___apis___common____types__MinMaxFloatIn!
}

input Github__com___kloudlite___operator___apis___clusters___v1__AwsSpotGpuNodeIn {
  instanceTypes: [String!]!
}

input Github__com___kloudlite___operator___apis___clusters___v1__AwsSpotPoolConfigIn {
  cpuNode: Github__com___kloudlite___operator___apis___clusters___v1__AwsSpotCpuNodeIn
  gpuNode: Github__com___kloudlite___operator___apis___clusters___v1__AwsSpotGpuNodeIn
  nodes: Map
}

input Github__com___kloudlite___operator___apis___clusters___v1__ClusterSpecIn {
  availabilityMode: Github__com___kloudlite___operator___apis___clusters___v1__ClusterSpecAvailabilityMode!
  aws: Github__com___kloudlite___operator___apis___clusters___v1__AWSClusterConfigIn
  cloudflareEnabled: Boolean
  cloudProvider: Github__com___kloudlite___operator___apis___common____types__CloudProvider!
  credentialsRef: Github__com___kloudlite___operator___apis___common____types__SecretRefIn!
}

input Github__com___kloudlite___operator___apis___clusters___v1__NodePoolSpecIn {
  aws: Github__com___kloudlite___operator___apis___clusters___v1__AWSNodePoolConfigIn
  cloudProvider: Github__com___kloudlite___operator___apis___common____types__CloudProvider!
  maxCount: Int!
  minCount: Int!
  nodeLabels: Map
  nodeTaints: [K8s__io___api___core___v1__TaintIn!]
  targetCount: Int!
}

input Github__com___kloudlite___operator___apis___clusters___v1__NodePropsIn {
  lastRecreatedAt: Date
}

input Github__com___kloudlite___operator___apis___clusters___v1__NodeSpecIn {
  nodepoolName: String!
}

input Github__com___kloudlite___operator___apis___common____types__MinMaxFloatIn {
  max: String!
  min: String!
}

input Github__com___kloudlite___operator___apis___common____types__SecretRefIn {
  name: String!
  namespace: String
}

input Github__com___kloudlite___operator___apis___crds___v1__ClusterManagedServiceSpecIn {
  msvcSpec: Github__com___kloudlite___operator___apis___crds___v1__ManagedServiceSpecIn!
  targetNamespace: String!
}

input Github__com___kloudlite___operator___apis___crds___v1__HelmChartSpecIn {
  chartName: String!
  chartRepoURL: String!
  chartVersion: String!
  jobVars: Github__com___kloudlite___operator___apis___crds___v1__JobVarsIn
  postInstall: String
  postUninstall: String
  preInstall: String
  preUninstall: String
  values: Map!
}

input Github__com___kloudlite___operator___apis___crds___v1__JobVarsIn {
  affinity: K8s__io___api___core___v1__AffinityIn
  backOffLimit: Int
  nodeSelector: Map
  tolerations: [K8s__io___api___core___v1__TolerationIn!]
}

input Github__com___kloudlite___operator___apis___crds___v1__ManagedServiceSpecIn {
  serviceTemplate: Github__com___kloudlite___operator___apis___crds___v1__ServiceTemplateIn!
}

input Github__com___kloudlite___operator___apis___crds___v1__ServiceTemplateIn {
  apiVersion: String!
  kind: String!
  spec: Map!
}

input Github__com___kloudlite___operator___apis___wireguard___v1__CNameRecordIn {
  host: String
  target: String
}

input Github__com___kloudlite___operator___apis___wireguard___v1__DeviceSpecIn {
  cnameRecords: [Github__com___kloudlite___operator___apis___wireguard___v1__CNameRecordIn!]
  deviceNamespace: String
  disabled: Boolean
  nodeSelector: Map
  ports: [Github__com___kloudlite___operator___apis___wireguard___v1__PortIn!]
}

input Github__com___kloudlite___operator___apis___wireguard___v1__PortIn {
  port: Int
  targetPort: Int
}

input K8s__io___api___core___v1__AWSElasticBlockStoreVolumeSourceIn {
  fsType: String
  partition: Int
  readOnly: Boolean
  volumeID: String!
}

input K8s__io___api___core___v1__AffinityIn {
  nodeAffinity: K8s__io___api___core___v1__NodeAffinityIn
  podAffinity: K8s__io___api___core___v1__PodAffinityIn
  podAntiAffinity: K8s__io___api___core___v1__PodAntiAffinityIn
}

input K8s__io___api___core___v1__AzureDiskVolumeSourceIn {
  cachingMode: String
  diskName: String!
  diskURI: String!
  fsType: String
  kind: String
  readOnly: Boolean
}

input K8s__io___api___core___v1__AzureFilePersistentVolumeSourceIn {
  readOnly: Boolean
  secretName: String!
  secretNamespace: String
  shareName: String!
}

input K8s__io___api___core___v1__CSIPersistentVolumeSourceIn {
  controllerExpandSecretRef: K8s__io___api___core___v1__SecretReferenceIn
  controllerPublishSecretRef: K8s__io___api___core___v1__SecretReferenceIn
  driver: String!
  fsType: String
  nodeExpandSecretRef: K8s__io___api___core___v1__SecretReferenceIn
  nodePublishSecretRef: K8s__io___api___core___v1__SecretReferenceIn
  nodeStageSecretRef: K8s__io___api___core___v1__SecretReferenceIn
  readOnly: Boolean
  volumeAttributes: Map
  volumeHandle: String!
}

input K8s__io___api___core___v1__CephFSPersistentVolumeSourceIn {
  monitors: [String!]!
  path: String
  readOnly: Boolean
  secretFile: String
  secretRef: K8s__io___api___core___v1__SecretReferenceIn
  user: String
}

input K8s__io___api___core___v1__CinderPersistentVolumeSourceIn {
  fsType: String
  readOnly: Boolean
  secretRef: K8s__io___api___core___v1__SecretReferenceIn
  volumeID: String!
}

input K8s__io___api___core___v1__FCVolumeSourceIn {
  fsType: String
  lun: Int
  readOnly: Boolean
  targetWWNs: [String!]
  wwids: [String!]
}

input K8s__io___api___core___v1__FlexPersistentVolumeSourceIn {
  driver: String!
  fsType: String
  options: Map
  readOnly: Boolean
  secretRef: K8s__io___api___core___v1__SecretReferenceIn
}

input K8s__io___api___core___v1__FlockerVolumeSourceIn {
  datasetName: String
  datasetUUID: String
}

input K8s__io___api___core___v1__GCEPersistentDiskVolumeSourceIn {
  fsType: String
  partition: Int
  pdName: String!
  readOnly: Boolean
}

input K8s__io___api___core___v1__GlusterfsPersistentVolumeSourceIn {
  endpoints: String!
  endpointsNamespace: String
  path: String!
  readOnly: Boolean
}

input K8s__io___api___core___v1__HostPathVolumeSourceIn {
  path: String!
  type: String
}

input K8s__io___api___core___v1__ISCSIPersistentVolumeSourceIn {
  chapAuthDiscovery: Boolean
  chapAuthSession: Boolean
  fsType: String
  initiatorName: String
  iqn: String!
  iscsiInterface: String
  lun: Int!
  portals: [String!]
  readOnly: Boolean
  secretRef: K8s__io___api___core___v1__SecretReferenceIn
  targetPortal: String!
}

input K8s__io___api___core___v1__LocalVolumeSourceIn {
  fsType: String
  path: String!
}

input K8s__io___api___core___v1__NFSVolumeSourceIn {
  path: String!
  readOnly: Boolean
  server: String!
}

input K8s__io___api___core___v1__NamespaceConditionIn {
  lastTransitionTime: Date
  message: String
  reason: String
  status: K8s__io___api___core___v1__ConditionStatus!
  type: K8s__io___api___core___v1__NamespaceConditionType!
}

input K8s__io___api___core___v1__NamespaceSpecIn {
  finalizers: [String!]
}

input K8s__io___api___core___v1__NamespaceStatusIn {
  conditions: [K8s__io___api___core___v1__NamespaceConditionIn!]
  phase: K8s__io___api___core___v1__NamespacePhase
}

input K8s__io___api___core___v1__NodeAffinityIn {
  preferredDuringSchedulingIgnoredDuringExecution: [K8s__io___api___core___v1__PreferredSchedulingTermIn!]
  requiredDuringSchedulingIgnoredDuringExecution: K8s__io___api___core___v1__NodeSelectorIn
}

input K8s__io___api___core___v1__NodeSelectorIn {
  nodeSelectorTerms: [K8s__io___api___core___v1__NodeSelectorTermIn!]!
}

input K8s__io___api___core___v1__NodeSelectorRequirementIn {
  key: String!
  operator: K8s__io___api___core___v1__NodeSelectorOperator!
  values: [String!]
}

input K8s__io___api___core___v1__NodeSelectorTermIn {
  matchExpressions: [K8s__io___api___core___v1__NodeSelectorRequirementIn!]
  matchFields: [K8s__io___api___core___v1__NodeSelectorRequirementIn!]
}

input K8s__io___api___core___v1__ObjectReferenceIn {
  apiVersion: String
  fieldPath: String
  kind: String
  name: String
  namespace: String
  resourceVersion: String
  uid: String
}

input K8s__io___api___core___v1__PersistentVolumeClaimConditionIn {
  lastProbeTime: Date
  lastTransitionTime: Date
  message: String
  reason: String
  status: K8s__io___api___core___v1__ConditionStatus!
  type: K8s__io___api___core___v1__PersistentVolumeClaimConditionType!
}

input K8s__io___api___core___v1__PersistentVolumeClaimSpecIn {
  accessModes: [String!]
  dataSource: K8s__io___api___core___v1__TypedLocalObjectReferenceIn
  dataSourceRef: K8s__io___api___core___v1__TypedObjectReferenceIn
  resources: K8s__io___api___core___v1__ResourceRequirementsIn
  selector: K8s__io___apimachinery___pkg___apis___meta___v1__LabelSelectorIn
  storageClassName: String
  volumeMode: String
  volumeName: String
}

input K8s__io___api___core___v1__PersistentVolumeClaimStatusIn {
  accessModes: [String!]
  allocatedResources: Map
  allocatedResourceStatuses: Map
  capacity: Map
  conditions: [K8s__io___api___core___v1__PersistentVolumeClaimConditionIn!]
  phase: K8s__io___api___core___v1__PersistentVolumeClaimPhase
}

input K8s__io___api___core___v1__PersistentVolumeSpecIn {
  accessModes: [String!]
  awsElasticBlockStore: K8s__io___api___core___v1__AWSElasticBlockStoreVolumeSourceIn
  azureDisk: K8s__io___api___core___v1__AzureDiskVolumeSourceIn
  azureFile: K8s__io___api___core___v1__AzureFilePersistentVolumeSourceIn
  capacity: Map
  cephfs: K8s__io___api___core___v1__CephFSPersistentVolumeSourceIn
  cinder: K8s__io___api___core___v1__CinderPersistentVolumeSourceIn
  claimRef: K8s__io___api___core___v1__ObjectReferenceIn
  csi: K8s__io___api___core___v1__CSIPersistentVolumeSourceIn
  fc: K8s__io___api___core___v1__FCVolumeSourceIn
  flexVolume: K8s__io___api___core___v1__FlexPersistentVolumeSourceIn
  flocker: K8s__io___api___core___v1__FlockerVolumeSourceIn
  gcePersistentDisk: K8s__io___api___core___v1__GCEPersistentDiskVolumeSourceIn
  glusterfs: K8s__io___api___core___v1__GlusterfsPersistentVolumeSourceIn
  hostPath: K8s__io___api___core___v1__HostPathVolumeSourceIn
  iscsi: K8s__io___api___core___v1__ISCSIPersistentVolumeSourceIn
  local: K8s__io___api___core___v1__LocalVolumeSourceIn
  mountOptions: [String!]
  nfs: K8s__io___api___core___v1__NFSVolumeSourceIn
  nodeAffinity: K8s__io___api___core___v1__VolumeNodeAffinityIn
  persistentVolumeReclaimPolicy: K8s__io___api___core___v1__PersistentVolumeReclaimPolicy
  photonPersistentDisk: K8s__io___api___core___v1__PhotonPersistentDiskVolumeSourceIn
  portworxVolume: K8s__io___api___core___v1__PortworxVolumeSourceIn
  quobyte: K8s__io___api___core___v1__QuobyteVolumeSourceIn
  rbd: K8s__io___api___core___v1__RBDPersistentVolumeSourceIn
  scaleIO: K8s__io___api___core___v1__ScaleIOPersistentVolumeSourceIn
  storageClassName: String
  storageos: K8s__io___api___core___v1__StorageOSPersistentVolumeSourceIn
  volumeMode: String
  vsphereVolume: K8s__io___api___core___v1__VsphereVirtualDiskVolumeSourceIn
}

input K8s__io___api___core___v1__PersistentVolumeStatusIn {
  lastPhaseTransitionTime: Date
  message: String
  phase: K8s__io___api___core___v1__PersistentVolumePhase
  reason: String
}

input K8s__io___api___core___v1__PhotonPersistentDiskVolumeSourceIn {
  fsType: String
  pdID: String!
}

input K8s__io___api___core___v1__PodAffinityIn {
  preferredDuringSchedulingIgnoredDuringExecution: [K8s__io___api___core___v1__WeightedPodAffinityTermIn!]
  requiredDuringSchedulingIgnoredDuringExecution: [K8s__io___api___core___v1__PodAffinityTermIn!]
}

input K8s__io___api___core___v1__PodAffinityTermIn {
  labelSelector: K8s__io___apimachinery___pkg___apis___meta___v1__LabelSelectorIn
  namespaces: [String!]
  namespaceSelector: K8s__io___apimachinery___pkg___apis___meta___v1__LabelSelectorIn
  topologyKey: String!
}

input K8s__io___api___core___v1__PodAntiAffinityIn {
  preferredDuringSchedulingIgnoredDuringExecution: [K8s__io___api___core___v1__WeightedPodAffinityTermIn!]
  requiredDuringSchedulingIgnoredDuringExecution: [K8s__io___api___core___v1__PodAffinityTermIn!]
}

input K8s__io___api___core___v1__PortworxVolumeSourceIn {
  fsType: String
  readOnly: Boolean
  volumeID: String!
}

input K8s__io___api___core___v1__PreferredSchedulingTermIn {
  preference: K8s__io___api___core___v1__NodeSelectorTermIn!
  weight: Int!
}

input K8s__io___api___core___v1__QuobyteVolumeSourceIn {
  group: String
  readOnly: Boolean
  registry: String!
  tenant: String
  user: String
  volume: String!
}

input K8s__io___api___core___v1__RBDPersistentVolumeSourceIn {
  fsType: String
  image: String!
  keyring: String
  monitors: [String!]!
  pool: String
  readOnly: Boolean
  secretRef: K8s__io___api___core___v1__SecretReferenceIn
  user: String
}

input K8s__io___api___core___v1__ResourceClaimIn {
  name: String!
}

input K8s__io___api___core___v1__ResourceRequirementsIn {
  claims: [K8s__io___api___core___v1__ResourceClaimIn!]
  limits: Map
  requests: Map
}

input K8s__io___api___core___v1__ScaleIOPersistentVolumeSourceIn {
  fsType: String
  gateway: String!
  protectionDomain: String
  readOnly: Boolean
  secretRef: K8s__io___api___core___v1__SecretReferenceIn
  sslEnabled: Boolean
  storageMode: String
  storagePool: String
  system: String!
  volumeName: String
}

input K8s__io___api___core___v1__SecretReferenceIn {
  name: String
  namespace: String
}

input K8s__io___api___core___v1__StorageOSPersistentVolumeSourceIn {
  fsType: String
  readOnly: Boolean
  secretRef: K8s__io___api___core___v1__ObjectReferenceIn
  volumeName: String
  volumeNamespace: String
}

input K8s__io___api___core___v1__TaintIn {
  effect: K8s__io___api___core___v1__TaintEffect!
  key: String!
  timeAdded: Date
  value: String
}

input K8s__io___api___core___v1__TolerationIn {
  effect: K8s__io___api___core___v1__TaintEffect
  key: String
  operator: K8s__io___api___core___v1__TolerationOperator
  tolerationSeconds: Int
  value: String
}

input K8s__io___api___core___v1__TypedLocalObjectReferenceIn {
  apiGroup: String
  kind: String!
  name: String!
}

input K8s__io___api___core___v1__TypedObjectReferenceIn {
  apiGroup: String
  kind: String!
  name: String!
  namespace: String
}

input K8s__io___api___core___v1__VolumeNodeAffinityIn {
  required: K8s__io___api___core___v1__NodeSelectorIn
}

input K8s__io___api___core___v1__VsphereVirtualDiskVolumeSourceIn {
  fsType: String
  storagePolicyID: String
  storagePolicyName: String
  volumePath: String!
}

input K8s__io___api___core___v1__WeightedPodAffinityTermIn {
  podAffinityTerm: K8s__io___api___core___v1__PodAffinityTermIn!
  weight: Int!
}

input K8s__io___api___storage___v1__VolumeAttachmentSourceIn {
  inlineVolumeSpec: K8s__io___api___core___v1__PersistentVolumeSpecIn
  persistentVolumeName: String
}

input K8s__io___api___storage___v1__VolumeAttachmentSpecIn {
  attacher: String!
  nodeName: String!
  source: K8s__io___api___storage___v1__VolumeAttachmentSourceIn!
}

input K8s__io___api___storage___v1__VolumeAttachmentStatusIn {
  attached: Boolean!
  attachError: K8s__io___api___storage___v1__VolumeErrorIn
  attachmentMetadata: Map
  detachError: K8s__io___api___storage___v1__VolumeErrorIn
}

input K8s__io___api___storage___v1__VolumeErrorIn {
  message: String
  time: Date
}

input K8s__io___apimachinery___pkg___api___resource__QuantityIn {
  Format: K8s__io___apimachinery___pkg___api___resource__Format!
}

input K8s__io___apimachinery___pkg___apis___meta___v1__LabelSelectorIn {
  matchExpressions: [K8s__io___apimachinery___pkg___apis___meta___v1__LabelSelectorRequirementIn!]
  matchLabels: Map
}

input K8s__io___apimachinery___pkg___apis___meta___v1__LabelSelectorRequirementIn {
  key: String!
  operator: K8s__io___apimachinery___pkg___apis___meta___v1__LabelSelectorOperator!
  values: [String!]
}

input MetadataIn {
  annotations: Map
  labels: Map
  name: String!
  namespace: String
}

enum Github__com___kloudlite___api___pkg___types__SyncAction {
  APPLY
  DELETE
}

enum Github__com___kloudlite___api___pkg___types__SyncState {
  APPLIED_AT_AGENT
  DELETED_AT_AGENT
  DELETING_AT_AGENT
  ERRORED_AT_AGENT
  IDLE
  IN_QUEUE
  RECEIVED_UPDATE_FROM_AGENT
  UPDATED_AT_AGENT
}

enum Github__com___kloudlite___operator___apis___clusters___v1__AWSPoolType {
  ec2
  spot
}

enum Github__com___kloudlite___operator___apis___clusters___v1__ClusterSpecAvailabilityMode {
  dev
  HA
}

enum Github__com___kloudlite___operator___apis___common____types__CloudProvider {
  aws
  azure
  do
  gcp
}

enum K8s__io___api___core___v1__ConditionStatus {
  False
  True
  Unknown
}

enum K8s__io___api___core___v1__NamespaceConditionType {
  NamespaceContentRemaining
  NamespaceDeletionContentFailure
  NamespaceDeletionDiscoveryFailure
  NamespaceDeletionGroupVersionParsingFailure
  NamespaceFinalizersRemaining
}

enum K8s__io___api___core___v1__NamespacePhase {
  Active
  Terminating
}

enum K8s__io___api___core___v1__NodeSelectorOperator {
  DoesNotExist
  Exists
  Gt
  In
  Lt
  NotIn
}

enum K8s__io___api___core___v1__PersistentVolumeClaimConditionType {
  FileSystemResizePending
  Resizing
}

enum K8s__io___api___core___v1__PersistentVolumeClaimPhase {
  Bound
  Lost
  Pending
}

enum K8s__io___api___core___v1__PersistentVolumePhase {
  Available
  Bound
  Failed
  Pending
  Released
}

enum K8s__io___api___core___v1__PersistentVolumeReclaimPolicy {
  Delete
  Recycle
  Retain
}

enum K8s__io___api___core___v1__TaintEffect {
  NoExecute
  NoSchedule
  PreferNoSchedule
}

enum K8s__io___api___core___v1__TolerationOperator {
  Equal
  Exists
}

enum K8s__io___apimachinery___pkg___api___resource__Format {
  BinarySI
  DecimalExponent
  DecimalSI
}

enum K8s__io___apimachinery___pkg___apis___meta___v1__LabelSelectorOperator {
  DoesNotExist
  Exists
  In
  NotIn
}

