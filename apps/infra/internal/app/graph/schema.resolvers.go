package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.55

import (
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"

	"github.com/kloudlite/api/pkg/errors"

	"github.com/kloudlite/api/apps/infra/internal/app/graph/generated"
	"github.com/kloudlite/api/apps/infra/internal/app/graph/model"
	"github.com/kloudlite/api/apps/infra/internal/domain"
	"github.com/kloudlite/api/apps/infra/internal/entities"
	fc "github.com/kloudlite/api/apps/infra/internal/entities/field-constants"
	"github.com/kloudlite/api/common/fields"
	fn "github.com/kloudlite/api/pkg/functions"
	"github.com/kloudlite/api/pkg/repos"
)

// ClusterDNSSuffix is the resolver for the clusterDNSSuffix field.
func (r *bYOKClusterResolver) ClusterDNSSuffix(ctx context.Context, obj *entities.BYOKCluster) (string, error) {
	return fmt.Sprintf("%s.local", obj.Name), nil
}

// AdminKubeconfig is the resolver for the adminKubeconfig field.
func (r *clusterResolver) AdminKubeconfig(ctx context.Context, obj *entities.Cluster) (*model.EncodedValue, error) {
	ictx, err := toInfraContext(ctx)
	if err != nil {
		return nil, errors.NewE(err)
	}
	s, err := r.Domain.GetClusterAdminKubeconfig(ictx, obj.Name)
	if err != nil {
		return nil, errors.NewE(err)
	}

	if s == nil {
		return nil, errors.Newf("kubeconfig could not be found")
	}

	return &model.EncodedValue{
		Value:    base64.StdEncoding.EncodeToString([]byte(*s)),
		Encoding: "base64",
	}, nil
}

// ClusterDNSSuffix is the resolver for the clusterDNSSuffix field.
func (r *clusterResolver) ClusterDNSSuffix(ctx context.Context, obj *entities.Cluster) (string, error) {
	return fmt.Sprintf("%s.local", obj.Name), nil
}

// WireguardConfig is the resolver for the wireguardConfig field.
func (r *globalVPNDeviceResolver) WireguardConfig(ctx context.Context, obj *entities.GlobalVPNDevice) (*model.EncodedValue, error) {
	ictx, err := toInfraContext(ctx)
	if err != nil {
		return nil, errors.NewE(err)
	}
	wgconfig, err := r.Domain.GetGlobalVPNDeviceWgConfig(ictx, obj.GlobalVPNName, obj.Name)
	if err != nil {
		return nil, err
	}

	return &model.EncodedValue{
		Value:    base64.StdEncoding.EncodeToString([]byte(wgconfig)),
		Encoding: "base64",
	}, nil
}

// InfraCreateCluster is the resolver for the infra_createCluster field.
func (r *mutationResolver) InfraCreateCluster(ctx context.Context, cluster entities.Cluster) (*entities.Cluster, error) {
	ictx, err := toInfraContext(ctx)
	if err != nil {
		return nil, errors.NewE(err)
	}
	return r.Domain.CreateCluster(ictx, cluster)
}

// InfraUpdateCluster is the resolver for the infra_updateCluster field.
func (r *mutationResolver) InfraUpdateCluster(ctx context.Context, cluster entities.Cluster) (*entities.Cluster, error) {
	ictx, err := toInfraContext(ctx)
	if err != nil {
		return nil, errors.NewE(err)
	}

	return r.Domain.UpdateCluster(ictx, cluster)
}

// InfraDeleteCluster is the resolver for the infra_deleteCluster field.
func (r *mutationResolver) InfraDeleteCluster(ctx context.Context, name string) (bool, error) {
	ictx, err := toInfraContext(ctx)
	if err != nil {
		return false, errors.NewE(err)
	}
	if err := r.Domain.DeleteCluster(ictx, name); err != nil {
		return false, errors.NewE(err)
	}
	return true, nil
}

// InfraCreateGlobalVpn is the resolver for the infra_createGlobalVPN field.
func (r *mutationResolver) InfraCreateGlobalVpn(ctx context.Context, gvpn entities.GlobalVPN) (*entities.GlobalVPN, error) {
	ictx, err := toInfraContext(ctx)
	if err != nil {
		return nil, errors.NewE(err)
	}
	return r.Domain.CreateGlobalVPN(ictx, gvpn)
}

// InfraUpdateGlobalVpn is the resolver for the infra_updateGlobalVPN field.
func (r *mutationResolver) InfraUpdateGlobalVpn(ctx context.Context, gvpn entities.GlobalVPN) (*entities.GlobalVPN, error) {
	ictx, err := toInfraContext(ctx)
	if err != nil {
		return nil, errors.NewE(err)
	}

	return r.Domain.UpdateGlobalVPN(ictx, gvpn)
}

// InfraDeleteGlobalVpn is the resolver for the infra_deleteGlobalVPN field.
func (r *mutationResolver) InfraDeleteGlobalVpn(ctx context.Context, name string) (bool, error) {
	ictx, err := toInfraContext(ctx)
	if err != nil {
		return false, errors.NewE(err)
	}
	if err := r.Domain.DeleteGlobalVPN(ictx, name); err != nil {
		return false, errors.NewE(err)
	}
	return true, nil
}

// InfraCreateGlobalVPNDevice is the resolver for the infra_createGlobalVPNDevice field.
func (r *mutationResolver) InfraCreateGlobalVPNDevice(ctx context.Context, gvpnDevice entities.GlobalVPNDevice) (*entities.GlobalVPNDevice, error) {
	ictx, err := toInfraContext(ctx)
	if err != nil {
		return nil, errors.NewE(err)
	}

	return r.Domain.CreateGlobalVPNDevice(ictx, gvpnDevice)
}

// InfraUpdateGlobalVPNDevice is the resolver for the infra_updateGlobalVPNDevice field.
func (r *mutationResolver) InfraUpdateGlobalVPNDevice(ctx context.Context, gvpnDevice entities.GlobalVPNDevice) (*entities.GlobalVPNDevice, error) {
	ictx, err := toInfraContext(ctx)
	if err != nil {
		return nil, errors.NewE(err)
	}
	return r.Domain.UpdateGlobalVPNDevice(ictx, gvpnDevice)
}

// InfraDeleteGlobalVPNDevice is the resolver for the infra_deleteGlobalVPNDevice field.
func (r *mutationResolver) InfraDeleteGlobalVPNDevice(ctx context.Context, gvpn string, deviceName string) (bool, error) {
	ictx, err := toInfraContext(ctx)
	if err != nil {
		return false, errors.NewE(err)
	}
	if err := r.Domain.DeleteGlobalVPNDevice(ictx, gvpn, deviceName); err != nil {
		return false, errors.NewE(err)
	}
	return true, nil
}

// InfraCreateBYOKCluster is the resolver for the infra_createBYOKCluster field.
func (r *mutationResolver) InfraCreateBYOKCluster(ctx context.Context, cluster entities.BYOKCluster) (*entities.BYOKCluster, error) {
	ictx, err := toInfraContext(ctx)
	if err != nil {
		return nil, errors.NewE(err)
	}
	return r.Domain.CreateBYOKCluster(ictx, cluster)
}

// InfraUpdatebYOKCluster is the resolver for the infra_updatebYOKCluster field.
func (r *mutationResolver) InfraUpdateBYOKCluster(ctx context.Context, clusterName string, displayName string) (*entities.BYOKCluster, error) {
	ictx, err := toInfraContext(ctx)
	if err != nil {
		return nil, errors.NewE(err)
	}
	return r.Domain.UpdateBYOKCluster(ictx, clusterName, displayName)
}

// InfraDeleteBYOKCluster is the resolver for the infra_deleteBYOKCluster field.
func (r *mutationResolver) InfraDeleteBYOKCluster(ctx context.Context, name string) (bool, error) {
	ictx, err := toInfraContext(ctx)
	if err != nil {
		return false, errors.NewE(err)
	}
	if err := r.Domain.DeleteBYOKCluster(ictx, name); err != nil {
		return false, err
	}

	return true, nil
}

// InfraCreateProviderSecret is the resolver for the infra_createProviderSecret field.
func (r *mutationResolver) InfraCreateProviderSecret(ctx context.Context, secret entities.CloudProviderSecret) (*entities.CloudProviderSecret, error) {
	ictx, err := toInfraContext(ctx)
	if err != nil {
		return nil, errors.NewE(err)
	}

	return r.Domain.CreateProviderSecret(ictx, secret)
}

// InfraUpdateProviderSecret is the resolver for the infra_updateProviderSecret field.
func (r *mutationResolver) InfraUpdateProviderSecret(ctx context.Context, secret entities.CloudProviderSecret) (*entities.CloudProviderSecret, error) {
	ictx, err := toInfraContext(ctx)
	if err != nil {
		return nil, errors.NewE(err)
	}

	return r.Domain.UpdateProviderSecret(ictx, secret)
}

// InfraDeleteProviderSecret is the resolver for the infra_deleteProviderSecret field.
func (r *mutationResolver) InfraDeleteProviderSecret(ctx context.Context, secretName string) (bool, error) {
	ictx, err := toInfraContext(ctx)
	if err != nil {
		return false, errors.NewE(err)
	}

	if err := r.Domain.DeleteProviderSecret(ictx, secretName); err != nil {
		return false, errors.NewE(err)
	}
	return true, nil
}

// InfraCreateDomainEntry is the resolver for the infra_createDomainEntry field.
func (r *mutationResolver) InfraCreateDomainEntry(ctx context.Context, domainEntry entities.DomainEntry) (*entities.DomainEntry, error) {
	ictx, err := toInfraContext(ctx)
	if err != nil {
		return nil, errors.NewE(err)
	}
	return r.Domain.CreateDomainEntry(ictx, domainEntry)
}

// InfraUpdateDomainEntry is the resolver for the infra_updateDomainEntry field.
func (r *mutationResolver) InfraUpdateDomainEntry(ctx context.Context, domainEntry entities.DomainEntry) (*entities.DomainEntry, error) {
	ictx, err := toInfraContext(ctx)
	if err != nil {
		return nil, errors.NewE(err)
	}
	return r.Domain.UpdateDomainEntry(ictx, domainEntry)
}

// InfraDeleteDomainEntry is the resolver for the infra_deleteDomainEntry field.
func (r *mutationResolver) InfraDeleteDomainEntry(ctx context.Context, domainName string) (bool, error) {
	ictx, err := toInfraContext(ctx)
	if err != nil {
		return false, errors.NewE(err)
	}
	if err := r.Domain.DeleteDomainEntry(ictx, domainName); err != nil {
		return false, errors.NewE(err)
	}
	return true, nil
}

// InfraCreateNodePool is the resolver for the infra_createNodePool field.
func (r *mutationResolver) InfraCreateNodePool(ctx context.Context, clusterName string, pool entities.NodePool) (*entities.NodePool, error) {
	ictx, err := toInfraContext(ctx)
	if err != nil {
		return nil, errors.NewE(err)
	}

	return r.Domain.CreateNodePool(ictx, clusterName, pool)
}

// InfraUpdateNodePool is the resolver for the infra_updateNodePool field.
func (r *mutationResolver) InfraUpdateNodePool(ctx context.Context, clusterName string, pool entities.NodePool) (*entities.NodePool, error) {
	ictx, err := toInfraContext(ctx)
	if err != nil {
		return nil, errors.NewE(err)
	}

	return r.Domain.UpdateNodePool(ictx, clusterName, pool)
}

// InfraDeleteNodePool is the resolver for the infra_deleteNodePool field.
func (r *mutationResolver) InfraDeleteNodePool(ctx context.Context, clusterName string, poolName string) (bool, error) {
	ictx, err := toInfraContext(ctx)
	if err != nil {
		return false, errors.NewE(err)
	}

	if err := r.Domain.DeleteNodePool(ictx, clusterName, poolName); err != nil {
		return false, errors.NewE(err)
	}
	return true, nil
}

// InfraDeletePv is the resolver for the infra_deletePV field.
func (r *mutationResolver) InfraDeletePv(ctx context.Context, clusterName string, pvName string) (bool, error) {
	ictx, err := toInfraContext(ctx)
	if err != nil {
		return false, errors.NewE(err)
	}

	if err := r.Domain.DeletePV(ictx, clusterName, pvName); err != nil {
		return false, errors.NewE(err)
	}
	return true, nil
}

// InfraCreateWorkspace is the resolver for the infra_createWorkspace field.
func (r *mutationResolver) InfraCreateWorkspace(ctx context.Context, workmachineName string, clusterName string, workspace entities.Workspace) (*entities.Workspace, error) {
	ictx, err := toInfraContext(ctx)
	if err != nil {
		return nil, errors.NewE(err)
	}
	return r.Domain.CreateWorkspace(ictx, workmachineName, clusterName, workspace)
}

// InfraUpdateWorkspace is the resolver for the infra_updateWorkspace field.
func (r *mutationResolver) InfraUpdateWorkspace(ctx context.Context, workmachineName string, clusterName string, workspace entities.Workspace) (*entities.Workspace, error) {
	ictx, err := toInfraContext(ctx)
	if err != nil {
		return nil, errors.NewE(err)
	}

	return r.Domain.UpdateWorkspace(ictx, workmachineName, clusterName, workspace)
}

// InfraDeleteWorkspace is the resolver for the infra_deleteWorkspace field.
func (r *mutationResolver) InfraDeleteWorkspace(ctx context.Context, workmachineName string, clusterName string, name string) (bool, error) {
	ictx, err := toInfraContext(ctx)
	if err != nil {
		return false, errors.NewE(err)
	}
	if err := r.Domain.DeleteWorkspace(ictx, workmachineName, clusterName, name); err != nil {
		return false, errors.NewE(err)
	}
	return true, nil
}

// InfraUpdateWorkspaceStatus is the resolver for the infra_updateWorkspaceStatus field.
func (r *mutationResolver) InfraUpdateWorkspaceStatus(ctx context.Context, workmachineName string, clusterName string, status bool, name string) (bool, error) {
	ictx, err := toInfraContext(ctx)
	if err != nil {
		return false, errors.NewE(err)
	}
	return r.Domain.UpdateWorkspaceStatus(ictx, workmachineName, clusterName, status, name)
}

// InfraCreateWorkMachine is the resolver for the infra_createWorkMachine field.
func (r *mutationResolver) InfraCreateWorkMachine(ctx context.Context, clusterName string, workmachine entities.Workmachine) (*entities.Workmachine, error) {
	ictx, err := toInfraContext(ctx)
	if err != nil {
		return nil, errors.NewE(err)
	}
	// For temporary purpose, we are hardcoding the cluster name
	workmachine.ClusterName = "tenant-cluster"
	return r.Domain.CreateWorkMachine(ictx, clusterName, workmachine)
}

// InfraUpdateWorkMachine is the resolver for the infra_updateWorkMachine field.
func (r *mutationResolver) InfraUpdateWorkMachine(ctx context.Context, clusterName string, workmachine entities.Workmachine) (*entities.Workmachine, error) {
	ictx, err := toInfraContext(ctx)
	if err != nil {
		return nil, errors.NewE(err)
	}

	return r.Domain.UpdateWorkMachine(ictx, clusterName, workmachine)
}

// InfraUpdateWorkMachineStatus is the resolver for the infra_updateWorkMachineStatus field.
func (r *mutationResolver) InfraUpdateWorkMachineStatus(ctx context.Context, clusterName string, status bool, name string) (bool, error) {
	ictx, err := toInfraContext(ctx)
	if err != nil {
		return false, errors.NewE(err)
	}
	return r.Domain.UpdateWorkmachineStatus(ictx, clusterName, status, name)
}

// InfraCheckNameAvailability is the resolver for the infra_checkNameAvailability field.
func (r *queryResolver) InfraCheckNameAvailability(ctx context.Context, resType domain.ResType, clusterName *string, name string) (*domain.CheckNameAvailabilityOutput, error) {
	ictx, err := toInfraContext(ctx)
	if err != nil {
		return nil, errors.NewE(err)
	}

	return r.Domain.CheckNameAvailability(ictx, resType, clusterName, name)
}

// InfraListClusters is the resolver for the infra_listClusters field.
func (r *queryResolver) InfraListClusters(ctx context.Context, search *model.SearchCluster, pagination *repos.CursorPagination) (*model.ClusterPaginatedRecords, error) {
	ictx, err := toInfraContext(ctx)
	if err != nil {
		return nil, errors.NewE(err)
	}

	if pagination == nil {
		pagination = &repos.DefaultCursorPagination
	}

	filter := map[string]repos.MatchFilter{}

	if search != nil {
		if search.IsReady != nil {
			filter["status.isReady"] = *search.IsReady
		}

		if search.CloudProviderName != nil {
			filter["spec.cloudProvider"] = *search.CloudProviderName
		}

		if search.Region != nil {
			filter["spec.region"] = *search.Region
		}

		if search.Text != nil {
			filter[fields.MetadataName] = *search.Text
		}

		if search.AllClusters == nil {
			filter[fc.ClusterOwnedBy] = repos.MatchFilter{
				MatchType: repos.MatchTypeArray,
				Array: []any{
					ictx.UserId,
					nil,
				},
			}
		}
	}

	pClusters, err := r.Domain.ListClusters(ictx, filter, *pagination)
	if err != nil {
		return nil, errors.NewE(err)
	}

	return fn.JsonConvertP[model.ClusterPaginatedRecords](pClusters)
}

// InfraGetCluster is the resolver for the infra_getCluster field.
func (r *queryResolver) InfraGetCluster(ctx context.Context, name string) (*entities.Cluster, error) {
	ictx, err := toInfraContext(ctx)
	if err != nil {
		return nil, errors.NewE(err)
	}

	return r.Domain.GetCluster(ictx, name)
}

// InfraListBYOKClusters is the resolver for the infra_listBYOKClusters field.
func (r *queryResolver) InfraListBYOKClusters(ctx context.Context, search *model.SearchCluster, pagination *repos.CursorPagination) (*model.BYOKClusterPaginatedRecords, error) {
	ictx, err := toInfraContext(ctx)
	if err != nil {
		return nil, errors.NewE(err)
	}

	if pagination == nil {
		pagination = &repos.DefaultCursorPagination
	}

	filter := map[string]repos.MatchFilter{}

	if search != nil {
		if search.Text != nil {
			filter[fields.MetadataName] = *search.Text
		}
	}

	if search == nil || search.AllClusters == nil {
		filter[fc.ClusterOwnedBy] = repos.MatchFilter{
			MatchType: repos.MatchTypeArray,
			Array: []any{
				ictx.UserId,
				nil,
			},
		}
	}

	globalVPNs, err := r.Domain.ListBYOKCluster(ictx, filter, *pagination)
	if err != nil {
		return nil, errors.NewE(err)
	}
	res, err := fn.JsonConvertP[model.BYOKClusterPaginatedRecords](globalVPNs)
	return res, err
}

// InfraGetBYOKCluster is the resolver for the infra_getBYOKCluster field.
func (r *queryResolver) InfraGetBYOKCluster(ctx context.Context, name string) (*entities.BYOKCluster, error) {
	ictx, err := toInfraContext(ctx)
	if err != nil {
		return nil, errors.NewE(err)
	}

	return r.Domain.GetBYOKCluster(ictx, name)
}

// InfratGetBYOKClusterSetupInstructions is the resolver for the infrat_getBYOKClusterSetupInstructions field.
func (r *queryResolver) InfratGetBYOKClusterSetupInstructions(ctx context.Context, name string, onlyHelmValues *bool) ([]*model.BYOKSetupInstruction, error) {
	ictx, err := toInfraContext(ctx)
	if err != nil {
		return nil, errors.NewE(err)
	}

	bcsi, err := r.Domain.GetBYOKClusterSetupInstructions(ictx, name, fn.DefaultIfNil(onlyHelmValues, false))
	if err != nil {
		return nil, err
	}

	m := make([]*model.BYOKSetupInstruction, len(bcsi))
	for i, v := range bcsi {
		m[i], err = fn.JsonConvertP[model.BYOKSetupInstruction](v)
		if err != nil {
			return nil, err
		}
	}

	return m, nil
}

// InfraListGlobalVPNs is the resolver for the infra_listGlobalVPNs field.
func (r *queryResolver) InfraListGlobalVPNs(ctx context.Context, search *model.SearchGlobalVPNs, pagination *repos.CursorPagination) (*model.GlobalVPNPaginatedRecords, error) {
	ictx, err := toInfraContext(ctx)
	if err != nil {
		return nil, errors.NewE(err)
	}

	if pagination == nil {
		pagination = &repos.DefaultCursorPagination
	}

	filter := map[string]repos.MatchFilter{}

	if search != nil {
		if search.Text != nil {
			filter[fields.MetadataName] = *search.Text
		}
	}

	globalVPNs, err := r.Domain.ListGlobalVPN(ictx, filter, *pagination)
	if err != nil {
		return nil, errors.NewE(err)
	}

	return fn.JsonConvertP[model.GlobalVPNPaginatedRecords](globalVPNs)
}

// InfraGetGlobalVpn is the resolver for the infra_getGlobalVPN field.
func (r *queryResolver) InfraGetGlobalVpn(ctx context.Context, name string) (*entities.GlobalVPN, error) {
	ictx, err := toInfraContext(ctx)
	if err != nil {
		return nil, errors.NewE(err)
	}

	return r.Domain.GetGlobalVPN(ictx, name)
}

// InfraListGlobalVPNDevices is the resolver for the infra_listGlobalVPNDevices field.
func (r *queryResolver) InfraListGlobalVPNDevices(ctx context.Context, gvpn string, search *model.SearchGlobalVPNDevices, pagination *repos.CursorPagination) (*model.GlobalVPNDevicePaginatedRecords, error) {
	ictx, err := toInfraContext(ctx)
	if err != nil {
		return nil, errors.NewE(err)
	}

	if pagination == nil {
		pagination = &repos.DefaultCursorPagination
	}

	filter := map[string]repos.MatchFilter{}

	if search != nil {
		if search.Text != nil {
			filter["metadata.name"] = *search.Text
		}
		if search.CreationMethod != nil {
			filter["creationMethod"] = *search.CreationMethod
		}
	}

	records, err := r.Domain.ListGlobalVPNDevice(ictx, gvpn, filter, *pagination)
	if err != nil {
		return nil, errors.NewE(err)
	}

	return fn.JsonConvertP[model.GlobalVPNDevicePaginatedRecords](records)
}

// InfraGetGlobalVPNDevice is the resolver for the infra_getGlobalVPNDevice field.
func (r *queryResolver) InfraGetGlobalVPNDevice(ctx context.Context, gvpn string, deviceName string) (*entities.GlobalVPNDevice, error) {
	ictx, err := toInfraContext(ctx)
	if err != nil {
		return nil, errors.NewE(err)
	}

	return r.Domain.GetGlobalVPNDevice(ictx, gvpn, deviceName)
}

// InfraListNodePools is the resolver for the infra_listNodePools field.
func (r *queryResolver) InfraListNodePools(ctx context.Context, clusterName string, search *model.SearchNodepool, pagination *repos.CursorPagination) (*model.NodePoolPaginatedRecords, error) {
	ictx, err := toInfraContext(ctx)
	if err != nil {
		return nil, errors.NewE(err)
	}

	if pagination == nil {
		pagination = &repos.DefaultCursorPagination
	}

	filter := map[string]repos.MatchFilter{}

	if search != nil {
		if search.Text != nil {
			filter["metadata.name"] = *search.Text
		}
	}

	pNodePools, err := r.Domain.ListNodePools(ictx, clusterName, filter, *pagination)
	if err != nil {
		return nil, errors.NewE(err)
	}

	return fn.JsonConvertP[model.NodePoolPaginatedRecords](pNodePools)
}

// InfraGetNodePool is the resolver for the infra_getNodePool field.
func (r *queryResolver) InfraGetNodePool(ctx context.Context, clusterName string, poolName string) (*entities.NodePool, error) {
	ictx, err := toInfraContext(ctx)
	if err != nil {
		return nil, errors.NewE(err)
	}

	return r.Domain.GetNodePool(ictx, clusterName, poolName)
}

// InfraListProviderSecrets is the resolver for the infra_listProviderSecrets field.
func (r *queryResolver) InfraListProviderSecrets(ctx context.Context, search *model.SearchProviderSecret, pagination *repos.CursorPagination) (*model.CloudProviderSecretPaginatedRecords, error) {
	ictx, err := toInfraContext(ctx)
	if err != nil {
		return nil, errors.NewE(err)
	}

	if pagination == nil {
		pagination = &repos.DefaultCursorPagination
	}

	filter := map[string]repos.MatchFilter{}

	if search != nil {
		if search.Text != nil {
			filter["metadata.name"] = *search.Text
		}

		if search.CloudProviderName != nil {
			filter["cloudProviderName"] = *search.CloudProviderName
		}
	}

	pSecrets, err := r.Domain.ListProviderSecrets(ictx, filter, *pagination)
	if err != nil {
		return nil, errors.NewE(err)
	}

	return fn.JsonConvertP[model.CloudProviderSecretPaginatedRecords](pSecrets)
}

// InfraGetProviderSecret is the resolver for the infra_getProviderSecret field.
func (r *queryResolver) InfraGetProviderSecret(ctx context.Context, name string) (*entities.CloudProviderSecret, error) {
	ictx, err := toInfraContext(ctx)
	if err != nil {
		return nil, errors.NewE(err)
	}

	return r.Domain.GetProviderSecret(ictx, name)
}

// InfraListDomainEntries is the resolver for the infra_listDomainEntries field.
func (r *queryResolver) InfraListDomainEntries(ctx context.Context, search *model.SearchDomainEntry, pagination *repos.CursorPagination) (*model.DomainEntryPaginatedRecords, error) {
	ictx, err := toInfraContext(ctx)
	if err != nil {
		return nil, errors.NewE(err)
	}

	filter := map[string]repos.MatchFilter{}

	if search != nil {
		if search.Text != nil {
			filter["domainName"] = *search.Text
		}

		if search.ClusterName != nil {
			filter["clusterName"] = *search.ClusterName
		}
	}

	dEntries, err := r.Domain.ListDomainEntries(ictx, filter, fn.DefaultIfNil(pagination, repos.DefaultCursorPagination))
	if err != nil {
		return nil, errors.NewE(err)
	}

	return fn.JsonConvertP[model.DomainEntryPaginatedRecords](dEntries)
}

// InfraGetDomainEntry is the resolver for the infra_getDomainEntry field.
func (r *queryResolver) InfraGetDomainEntry(ctx context.Context, domainName string) (*entities.DomainEntry, error) {
	ictx, err := toInfraContext(ctx)
	if err != nil {
		return nil, errors.NewE(err)
	}

	return r.Domain.GetDomainEntry(ictx, domainName)
}

// InfraCheckAWSAccess is the resolver for the infra_checkAwsAccess field.
func (r *queryResolver) InfraCheckAWSAccess(ctx context.Context, cloudproviderName string) (*model.CheckAWSAccessOutput, error) {
	panic(fmt.Errorf("not implemented: InfraCheckAWSAccess - infra_checkAwsAccess"))
}

// InfraListManagedServiceTemplates is the resolver for the infra_listManagedServiceTemplates field.
func (r *queryResolver) InfraListManagedServiceTemplates(ctx context.Context) ([]*entities.MsvcTemplate, error) {
	data, err := r.Domain.ListManagedSvcTemplates()
	return data, err
}

// InfraGetManagedServiceTemplate is the resolver for the infra_getManagedServiceTemplate field.
func (r *queryResolver) InfraGetManagedServiceTemplate(ctx context.Context, category string, name string) (*entities.MsvcTemplateEntry, error) {
	return r.Domain.GetManagedSvcTemplate(category, name)
}

// InfraListPVCs is the resolver for the infra_listPVCs field.
func (r *queryResolver) InfraListPVCs(ctx context.Context, clusterName string, search *model.SearchPersistentVolumeClaims, pq *repos.CursorPagination) (*model.PersistentVolumeClaimPaginatedRecords, error) {
	filter := map[string]repos.MatchFilter{}
	if search != nil {
		if search.Text != nil {
			filter["metadata.name"] = *search.Text
		}
	}

	cc, err := toInfraContext(ctx)
	if err != nil {
		return nil, errors.NewE(err)
	}

	pvcs, err := r.Domain.ListPVCs(cc, clusterName, filter, fn.DefaultIfNil(pq, repos.DefaultCursorPagination))
	if err != nil {
		return nil, errors.NewE(err)
	}

	return fn.JsonConvertP[model.PersistentVolumeClaimPaginatedRecords](pvcs)
}

// InfraGetPvc is the resolver for the infra_getPVC field.
func (r *queryResolver) InfraGetPvc(ctx context.Context, clusterName string, name string) (*entities.PersistentVolumeClaim, error) {
	cc, err := toInfraContext(ctx)
	if err != nil {
		return nil, errors.NewE(err)
	}

	return r.Domain.GetPVC(cc, clusterName, name)
}

// InfraListNamespaces is the resolver for the infra_listNamespaces field.
func (r *queryResolver) InfraListNamespaces(ctx context.Context, clusterName string, search *model.SearchNamespaces, pq *repos.CursorPagination) (*model.NamespacePaginatedRecords, error) {
	filter := map[string]repos.MatchFilter{}
	if search != nil {
		if search.Text != nil {
			filter["metadata.name"] = *search.Text
		}
	}

	cc, err := toInfraContext(ctx)
	if err != nil {
		return nil, errors.NewE(err)
	}

	namespaces, err := r.Domain.ListNamespaces(cc, clusterName, filter, fn.DefaultIfNil(pq, repos.DefaultCursorPagination))
	if err != nil {
		return nil, errors.NewE(err)
	}

	return fn.JsonConvertP[model.NamespacePaginatedRecords](namespaces)
}

// InfraGetNamespace is the resolver for the infra_getNamespace field.
func (r *queryResolver) InfraGetNamespace(ctx context.Context, clusterName string, name string) (*entities.Namespace, error) {
	cc, err := toInfraContext(ctx)
	if err != nil {
		return nil, errors.NewE(err)
	}
	return r.Domain.GetNamespace(cc, clusterName, name)
}

// InfraListPVs is the resolver for the infra_listPVs field.
func (r *queryResolver) InfraListPVs(ctx context.Context, clusterName string, search *model.SearchPersistentVolumes, pq *repos.CursorPagination) (*model.PersistentVolumePaginatedRecords, error) {
	filter := map[string]repos.MatchFilter{}
	if search != nil {
		if search.Text != nil {
			filter["metadata.name"] = *search.Text
		}
	}

	cc, err := toInfraContext(ctx)
	if err != nil {
		return nil, errors.NewE(err)
	}

	pvs, err := r.Domain.ListPVs(cc, clusterName, filter, fn.DefaultIfNil(pq, repos.DefaultCursorPagination))
	if err != nil {
		return nil, errors.NewE(err)
	}

	return fn.JsonConvertP[model.PersistentVolumePaginatedRecords](pvs)
}

// InfraGetPv is the resolver for the infra_getPV field.
func (r *queryResolver) InfraGetPv(ctx context.Context, clusterName string, name string) (*entities.PersistentVolume, error) {
	cc, err := toInfraContext(ctx)
	if err != nil {
		return nil, errors.NewE(err)
	}
	return r.Domain.GetPV(cc, clusterName, name)
}

// InfraListVolumeAttachments is the resolver for the infra_listVolumeAttachments field.
func (r *queryResolver) InfraListVolumeAttachments(ctx context.Context, clusterName string, search *model.SearchVolumeAttachments, pq *repos.CursorPagination) (*model.VolumeAttachmentPaginatedRecords, error) {
	filter := map[string]repos.MatchFilter{}
	if search != nil {
		if search.Text != nil {
			filter["metadata.name"] = *search.Text
		}
	}

	cc, err := toInfraContext(ctx)
	if err != nil {
		return nil, errors.NewE(err)
	}

	volatt, err := r.Domain.ListVolumeAttachments(cc, clusterName, filter, fn.DefaultIfNil(pq, repos.DefaultCursorPagination))
	if err != nil {
		return nil, errors.NewE(err)
	}

	return fn.JsonConvertP[model.VolumeAttachmentPaginatedRecords](volatt)
}

// InfraGetVolumeAttachment is the resolver for the infra_getVolumeAttachment field.
func (r *queryResolver) InfraGetVolumeAttachment(ctx context.Context, clusterName string, name string) (*entities.VolumeAttachment, error) {
	cc, err := toInfraContext(ctx)
	if err != nil {
		return nil, errors.NewE(err)
	}
	return r.Domain.GetVolumeAttachment(cc, clusterName, name)
}

// InfraListWorkspaces is the resolver for the infra_listWorkspaces field.
func (r *queryResolver) InfraListWorkspaces(ctx context.Context, workmachineName string, clusterName string, search *model.SearchWorkspaces, pagination *repos.CursorPagination) (*model.WorkspacePaginatedRecords, error) {
	ictx, err := toInfraContext(ctx)
	if err != nil {
		return nil, errors.NewE(err)
	}

	if pagination == nil {
		pagination = &repos.DefaultCursorPagination
	}

	filter := map[string]repos.MatchFilter{}

	if search != nil {
		if search.Text != nil {
			filter["name"] = *search.Text
		}
	}

	pWorkspaces, err := r.Domain.ListWorkspaces(ictx, workmachineName, clusterName, filter, *pagination)
	if err != nil {
		return nil, errors.NewE(err)
	}
	d, _ := fn.JsonConvertP[model.WorkspacePaginatedRecords](pWorkspaces)
	data, err := json.Marshal(d)
	fmt.Println("pWorkspaces", string(data))
	return d, err
}

// InfraGetWorkspace is the resolver for the infra_getWorkspace field.
func (r *queryResolver) InfraGetWorkspace(ctx context.Context, workmachineName string, clusterName string, name string) (*entities.Workspace, error) {
	ictx, err := toInfraContext(ctx)
	if err != nil {
		return nil, errors.NewE(err)
	}

	return r.Domain.GetWorkspace(ictx, workmachineName, clusterName, name)
}

// InfraGetWorkmachine is the resolver for the infra_getWorkmachine field.
func (r *queryResolver) InfraGetWorkmachine(ctx context.Context, clusterName string, name string) (*entities.Workmachine, error) {
	fmt.Println("HERE")
	ictx, err := toInfraContext(ctx)
	if err != nil {
		return nil, errors.NewE(err)
	}
	return r.Domain.GetWorkmachine(ictx, "tenant-cluster", name)
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
