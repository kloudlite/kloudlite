name: 'build kloudlite operator action'
description: 'builds kloudlite Operators'

inputs:
  github_token:
    description: 'GitHub Token'
    required: true

  use_cachix:
    description: "use cachix"
    default: "false"

  cachix_auth_token:
    description: "cachix auth token"

  git_directory:
    description: 'git directory'
    default: "."

  cache_prefix:
    description: 'cache prefix'
    default: ""

  go_mod_download:
    description: 'go mod download'
    default: false

  platform-operator:
    description: 'build platform operator'
    default: false

  agent-operator:
    description: 'build agent operator'
    default: false

  networking_ip-manager:
    description: 'build networking/ip-manager'
    default: false

  networking_ip-binding-controller:
    description: 'build networking/ip-binding-controller'
    default: false

  networking_dns:
    description: 'build networking/dns'
    default: false

  networking_webhook:
    description: 'build networking/webhook'
    default: false

runs:
  using: 'composite'
  steps:
    - name: setup ENV Variables
      shell: bash
      id: env-vars
      working-directory: ${{ inputs.git_directory }}
      run: |+
        GOMODCACHE=${{github.workspace}}/actions/go-mod-cache
        GOCACHE=${{github.workspace}}/actions/go-cache
        echo "GOMODCACHE=$GOMODCACHE" >> $GITHUB_OUTPUT
        echo "GOCACHE=$GOCACHE" >> $GITHUB_OUTPUT

        echo "GOMODCACHE=$GOMODCACHE" >> $GITHUB_ENV
        echo "GOCACHE=$GOCACHE" >> $GITHUB_ENV

        echo "GOPKG_HASH=${{ hashFiles(format('{0}/go.mod', inputs.git_directory), format('{0}/go.sum', inputs.git_directory)) }}" >> $GITHUB_OUTPUT

    - name: ensures path to setup action exists
      shell: bash
      run: |+
        mkdir -p $GOMODCACHE
        ln -sf ${{ inputs.git_directory }}/.github/actions ./operator-github-actions

    - name: Setup Caches
      uses: actions/cache@v4
      with:
        path: |+
          ${{ env.GOMODCACHE }}
          ${{ env.GOCACHE }}
        key: go-${{ runner.os }}-${{github.repository_id}}-${{ steps.env-vars.outputs.GOPKG_HASH }}-${{ inputs.cache_prefix }}
        save-always: true
        restore-keys: go-${{ runner.os }}-${{github.repository_id}}-${{ steps.env-vars.outputs.GOPKG_HASH }}-

    - name: setup
      id: setup
      uses: ./operator-github-actions/setup/
      with:
        nix-develop-arguments: "${{ inputs.git_directory }}#default"
        flake-lock: ${{ inputs.git_directory }}/flake.lock
        github_token: ${{ inputs.github_token }}
        use_cachix: ${{ inputs.use_cachix }}
        cachix_auth_token: ${{ inputs.cachix_auth_token }}
        enable_docker: true

        # cache_key: go-${{ runner.os }}-${{github.repository_id}}-${{ steps.env-vars.outputs.GOPKG_HASH }}-${{ inputs.cache_prefix }}
        # cache_restore_key: go-${{ runner.os }}-${{github.repository_id}}-${{ steps.env-vars.outputs.GOPKG_HASH }}-
        # cache_paths: |+

    - name: go mod download
      if: ${{ inputs.go_mod_download == 'true' }}
      working-directory: ${{ inputs.git_directory }}
      shell: bash
      run: |+
        echo "### STARTING go mod download ###"
        go mod download -x
        echo "### FINSIHED go mod download ###"

        ls -al ${{ env.GOMODCACHE }}

    - name: platform operator
      if: ${{ inputs.platform-operator == 'true' }}
      # if: ${{ startsWith(github.ref, 'refs/heads/release') || startsWith(github.ref, 'refs/tags/') }}
      working-directory: ${{ inputs.git_directory }}/cmd/platform-operator
      env:
        IMAGE_TAG: ${{steps.setup.outputs.image_tag}}
        OVERRIDE_PUSHED_IMAGE: ${{steps.setup.outputs.override_pushed_image}}
      shell: bash
      run: |
        set +e
        image_name="ghcr.io/${{ github.repository }}/platform"

        IMAGE_TAG=${IMAGE_TAG:-latest}
        docker manifest inspect "$image_name:$IMAGE_TAG"
        exit_status=$?
        if [ $exit_status -eq 0 ]; then
          [ "$OVERRIDE_PUSHED_IMAGE" = "false" ] && echo "image ($image_name:$IMAGE_TAG) already exists, and override image is disable, exiting" && exit 0
          echo "image exists, but override pushed image is set to true. proceeding with building image"
        fi
        set -e

        task container:build-and-push Image=$image_name:$IMAGE_TAG

    - name: agent operator
      if: ${{ inputs.agent-operator == 'true' }}
      working-directory: ${{ inputs.git_directory }}/cmd/agent-operator
      env:
        IMAGE_TAG: ${{steps.setup.outputs.image_tag}}
        OVERRIDE_PUSHED_IMAGE: ${{steps.setup.outputs.override_pushed_image}}
      shell: bash
      run: |
        set +e
        image_name="ghcr.io/${{ github.repository }}/agent"

        IMAGE_TAG=${IMAGE_TAG:-latest}
        docker manifest inspect "$image_name:$IMAGE_TAG"
        exit_status=$?
        if [ $exit_status -eq 0 ]; then
          [ "$OVERRIDE_PUSHED_IMAGE" = "false" ] && echo "image ($image_name:$IMAGE_TAG) already exists, and override image is disable, exiting" && exit 0
          echo "image exists, but override pushed image is set to true. proceeding with building image"
        fi
        set -e

        task local:build-and-push Image=$image_name:$IMAGE_TAG

    - name: networking/ip-manager
      if: ${{ inputs.networking_ip-manager == 'true' }}
      working-directory: ${{ inputs.git_directory }}/operators/networking/internal/cmd/ip-manager
      env:
        IMAGE_TAG: ${{steps.setup.outputs.image_tag}}
        OVERRIDE_PUSHED_IMAGE: ${{steps.setup.outputs.override_pushed_image}}
      shell: bash
      run: |
        echo "GOCACHE=${GOCACHE}"
        echo "GOMODCACHE=${GOMODCACHE}"
        set +e
        image_name="ghcr.io/${{ github.repository }}/networking/cmd/ip-manager"

        IMAGE_TAG=${IMAGE_TAG:-latest}
        docker manifest inspect "$image_name:$IMAGE_TAG"
        exit_status=$?
        if [ $exit_status -eq 0 ]; then
          [ "$OVERRIDE_PUSHED_IMAGE" = "false" ] && echo "image ($image_name:$IMAGE_TAG) already exists, and override image is disable, exiting" && exit 0
          echo "image exists, but override pushed image is set to true. proceeding with building image"
        fi
        set -e

        task local:build-and-push image=$image_name:$IMAGE_TAG

    - name: networking/dns
      if: ${{ inputs.networking_dns == 'true' }}
      working-directory: ${{ inputs.git_directory }}/operators/networking/internal/cmd/dns
      env:
        IMAGE_TAG: ${{steps.setup.outputs.image_tag}}
        OVERRIDE_PUSHED_IMAGE: ${{steps.setup.outputs.override_pushed_image}}
      shell: bash
      run: |
        echo "GOCACHE=${GOCACHE}"
        echo "GOMODCACHE=${GOMODCACHE}"
        set +e
        image_name="ghcr.io/${{ github.repository }}/networking/cmd/dns"

        IMAGE_TAG=${IMAGE_TAG:-latest}
        docker manifest inspect "$image_name:$IMAGE_TAG"
        exit_status=$?
        if [ $exit_status -eq 0 ]; then
          [ "$OVERRIDE_PUSHED_IMAGE" = "false" ] && echo "image ($image_name:$IMAGE_TAG) already exists, and override image is disable, exiting" && exit 0
          echo "image exists, but override pushed image is set to true. proceeding with building image"
        fi
        set -e

        task container:build-and-push image=$image_name:$IMAGE_TAG

    - name: networking/webhook
      if: ${{ inputs.networking_webhook == 'true' }}
      working-directory: ${{ inputs.git_directory }}/operators/networking/internal/cmd/webhook
      env:
        IMAGE_TAG: ${{steps.setup.outputs.image_tag}}
        OVERRIDE_PUSHED_IMAGE: ${{steps.setup.outputs.override_pushed_image}}
      shell: bash
      run: |
        echo "GOCACHE=${GOCACHE}"
        echo "GOMODCACHE=${GOMODCACHE}"
        set +e
        image_name="ghcr.io/${{ github.repository }}/networking/cmd/webhook"

        IMAGE_TAG=${IMAGE_TAG:-latest}
        docker manifest inspect "$image_name:$IMAGE_TAG"
        exit_status=$?
        if [ $exit_status -eq 0 ]; then
          [ "$OVERRIDE_PUSHED_IMAGE" = "false" ] && echo "image ($image_name:$IMAGE_TAG) already exists, and override image is disable, exiting" && exit 0
          echo "image exists, but override pushed image is set to true. proceeding with building image"
        fi
        set -e

        task container:build-and-push image=$image_name:$IMAGE_TAG
