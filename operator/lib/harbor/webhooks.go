package harbor

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"time"

	"operators.kloudlite.io/lib/errors"
)

type Webhook struct {
	Name     string `json:"name"`
	Location string `json:"location"`
}

// WebhookBody : Generated by pasting webhook body, json: DO NOT EDIT by hand
type WebhookBody struct {
	Type      string `json:"type"`
	OccurAt   int    `json:"occur_at"`
	Operator  string `json:"operator"`
	EventData struct {
		Resources []struct {
			Digest      string `json:"digest"`
			Tag         string `json:"tag"`
			ResourceUrl string `json:"resource_url"`
		} `json:"resources"`
		Repository struct {
			DateCreated  int    `json:"date_created"`
			Name         string `json:"name"`
			Namespace    string `json:"namespace"`
			RepoFullName string `json:"repo_full_name"`
			RepoType     string `json:"repo_type"`
		} `json:"repository"`
	} `json:"event_data"`
}

type Event string

const (
	DeleteArtifact    Event = "DELETE_ARTIFACT"
	PullArtifact      Event = "PULL_ARTIFACT"
	PushArtifact      Event = "PUSH_ARTIFACT"
	DeleteChart       Event = "DELETE_CHART"
	DownloadChart     Event = "DOWNLOAD_CHART"
	UploadChart       Event = "UPLOAD_CHART"
	QuotaExceed       Event = "QUOTA_EXCEED"
	QuotaWarning      Event = "QUOTA_WARNING"
	Replication       Event = "REPLICATION"
	ScanningFailed    Event = "SCANNING_FAILED"
	ScanningCompleted Event = "SCANNING_COMPLETED"
	ScanningStopped   Event = "SCANNING_STOPPED"
	TagRetention      Event = "TAG_RETENTION"
)

func (h *Client) CheckWebhookExists(ctx context.Context, webhook *Webhook) (bool, error) {
	if webhook == nil || webhook.Location == "" {
		return false, nil
	}

	req, err := h.NewAuthzRequest(ctx, http.MethodGet, webhook.Location, nil)
	if err != nil {
		return false, nil
	}
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return false, err
	}

	if resp.StatusCode == http.StatusOK {
		return true, nil
	}

	if resp.StatusCode == http.StatusNotFound {
		return false, nil
	}

	if resp.StatusCode == http.StatusConflict {
		return true, nil
	}

	msg, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return false, err
	}
	return false, errors.Newf("bad status code (%d) received, with message %s", resp.StatusCode, msg)
}

type WebhookIn struct {
	Name        string
	Endpoint    string
	Events      []Event
	AuthzSecret string
}

func (h *Client) CreateWebhook(ctx context.Context, projectName string, webhookIn WebhookIn) (*Webhook, error) {
	body := map[string]any{
		"description":   "this webhook is created so that, as soon as an image is pushed, operator receives an event, and can take it calls like restarting an app, etc.",
		"creator":       "kloudlite operator",
		"creation_time": time.Now().Format(time.RFC3339),
		"enabled":       true,
		"targets": []map[string]any{
			{
				"type":             "http",
				"auth_header":      webhookIn.AuthzSecret,
				"skip_cert_verify": true,
				"address":          webhookIn.Endpoint,
			},
		},
		"event_types": webhookIn.Events,
		"name":        webhookIn.Name,
	}

	b, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}

	req, err := h.NewAuthzRequest(ctx, http.MethodPost, fmt.Sprintf("/projects/%s/webhook/policies", projectName), bytes.NewBuffer(b))
	if err != nil {
		return nil, err
	}

	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return nil, err
	}

	if resp.StatusCode == http.StatusCreated {
		return &Webhook{
			Name:     webhookIn.Name,
			Location: resp.Header.Get("Location"),
		}, nil
	}

	msg, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	return nil, errors.Newf("bad status code (%d) received, with error body, %s", resp.StatusCode, msg)
}

func (h *Client) DeleteWebhook(ctx context.Context, webhook *Webhook) error {
	if webhook == nil || webhook.Location == "" {
		return errors.Newf("webhook.Location not provided")
	}

	req, err := h.NewAuthzRequest(ctx, http.MethodDelete, webhook.Location, nil)
	if err != nil {
		return err
	}

	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return err
	}

	if resp.StatusCode == http.StatusOK || resp.StatusCode == http.StatusNotFound {
		return nil
	}

	msg, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return err
	}
	return errors.Newf("bad status code (%d) received, with error body, %s", resp.StatusCode, msg)
}
