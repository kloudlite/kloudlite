package harbor

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"strconv"
	"strings"
	"time"

	"github.com/kloudlite/operator/pkg/errors"
	hTypes "github.com/kloudlite/operator/pkg/harbor/internal/types"
)

type Webhook struct {
	Name     string `json:"name,omitempty"`
	Id       int64  `json:"id,omitempty"`
	Location string `json:"location,omitempty"`
}

// WebhookBody : Generated by pasting webhook body, json: DO NOT EDIT by hand
type WebhookBody struct {
	Type      string `json:"type"`
	OccurAt   int    `json:"occur_at"`
	Operator  string `json:"operator"`
	EventData struct {
		Resources []struct {
			Digest      string `json:"digest"`
			Tag         string `json:"tag"`
			ResourceUrl string `json:"resource_url"`
		} `json:"resources"`
		Repository struct {
			DateCreated  int    `json:"date_created"`
			Name         string `json:"name"`
			Namespace    string `json:"namespace"`
			RepoFullName string `json:"repo_full_name"`
			RepoType     string `json:"repo_type"`
		} `json:"repository"`
	} `json:"event_data"`
}

type Event string

const (
	DeleteArtifact    Event = "DELETE_ARTIFACT"
	PullArtifact      Event = "PULL_ARTIFACT"
	PushArtifact      Event = "PUSH_ARTIFACT"
	DeleteChart       Event = "DELETE_CHART"
	DownloadChart     Event = "DOWNLOAD_CHART"
	UploadChart       Event = "UPLOAD_CHART"
	QuotaExceed       Event = "QUOTA_EXCEED"
	QuotaWarning      Event = "QUOTA_WARNING"
	Replication       Event = "REPLICATION"
	ScanningFailed    Event = "SCANNING_FAILED"
	ScanningCompleted Event = "SCANNING_COMPLETED"
	ScanningStopped   Event = "SCANNING_STOPPED"
	TagRetention      Event = "TAG_RETENTION"
)

func (h *Client) GetWebhook(ctx context.Context, projectName string, webhookId int64) (*Webhook, error) {
	req, err := h.NewAuthzRequest(ctx, http.MethodGet, fmt.Sprintf("/projects/%s/webhook/policies/%d", projectName, webhookId), nil)
	if err != nil {
		return nil, nil
	}
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return nil, err
	}

	msg, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	if resp.StatusCode != http.StatusOK {
		return nil, errors.NewHttpError(resp.StatusCode, msg)
	}

	var webhook hTypes.Webhook
	if err := json.Unmarshal(msg, &webhook); err != nil {
		return nil, err
	}
	return &Webhook{
		Name: webhook.Name,
		Id:   int64(webhook.Id),
	}, nil
}

type WebhookIn struct {
	Name        string
	Endpoint    string
	Events      []Event
	AuthzSecret string
}

func (h *Client) CreateWebhook(ctx context.Context, projectName string, webhookIn WebhookIn) (*Webhook, error) {
	body := map[string]any{
		"description":   "this webhook is created so that, as soon as an image is pushed, operator receives an event, and can take it calls like restarting an app, etc.",
		"creator":       "kloudlite operator",
		"creation_time": time.Now().Format(time.RFC3339),
		"enabled":       true,
		"targets": []map[string]any{
			{
				"type":             "http",
				"auth_header":      webhookIn.AuthzSecret,
				"skip_cert_verify": true,
				"address":          webhookIn.Endpoint,
			},
		},
		"event_types": webhookIn.Events,
		"name":        webhookIn.Name,
	}

	b, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}

	req, err := h.NewAuthzRequest(ctx, http.MethodPost, fmt.Sprintf("/projects/%s/webhook/policies", projectName), bytes.NewBuffer(b))
	if err != nil {
		return nil, err
	}

	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return nil, err
	}

	if resp.StatusCode == http.StatusCreated {
		location := resp.Header.Get("Location")
		sp := strings.Split(location, "/")

		id, err := strconv.ParseInt(sp[len(sp)-1], 10, 64)
		if err != nil {
			return nil, err
		}

		return &Webhook{
			Name:     webhookIn.Name,
			Id:       id,
			Location: location,
		}, nil
	}

	msg, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	return nil, errors.Newf("bad status code (%d) received, with error body, %s", resp.StatusCode, msg)
}

func (h *Client) DeleteWebhook(ctx context.Context, projectName string, webhookId int64) error {
	req, err := h.NewAuthzRequest(ctx, http.MethodDelete, fmt.Sprintf("/projects/%s/webhook/policies/%d", projectName, webhookId), nil)
	if err != nil {
		return err
	}

	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return err
	}

	if resp.StatusCode == http.StatusOK || resp.StatusCode == http.StatusNotFound {
		return nil
	}

	msg, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return err
	}
	return errors.Newf("bad status code (%d) received, with error body, %s", resp.StatusCode, msg)
}

func (h *Client) FindWebhookByName(ctx context.Context, projectName, hookName string) (webhook *Webhook, err error) {
	req, err := h.NewAuthzRequest(ctx, http.MethodGet, fmt.Sprintf("/projects/%s/webhook/policies", projectName), nil)
	if err != nil {
		return nil, err
	}

	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return nil, errors.NewHttpError(resp.StatusCode, err.Error())
	}

	msg, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	if resp.StatusCode != http.StatusOK {
		return nil, errors.Newf("bad status code (%d) received, with error body, %s", resp.StatusCode, msg)
	}

	var webhooks []hTypes.Webhook
	if err := json.Unmarshal(msg, &webhooks); err != nil {
		return nil, err
	}

	for i := range webhooks {
		if webhooks[i].Name == hookName {
			return &Webhook{
				Name:     webhooks[i].Name,
				Id:       int64(webhooks[i].Id),
				Location: fmt.Sprintf("/projects/%s/webhook/policies/%d", projectName, webhooks[i].Id),
			}, nil
		}
	}

	return nil, errors.NewHttpError(http.StatusNotFound, fmt.Sprintf("could not find any webhook policies by (name=%s)", hookName))
}
