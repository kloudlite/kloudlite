// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.3
//   protoc               v4.25.4
// source: auth.v2.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";

export const protobufPackage = "";

export interface LoginWithOAuthRequest {
  email: string;
  name: string;
  provider: string;
}

export interface LoginWithOAuthResponse {
  userId: string;
}

export interface LoginWithSSORequest {
  email: string;
  name: string;
}

export interface LoginWithSSOResponse {
  userId: string;
}

export interface GetUserDetailsRequest {
  userId: string;
}

export interface GetUserDetailsResponse {
  userId: string;
  name: string;
  email: string;
  emailVerified: boolean;
}

export interface LoginRequest {
  email: string;
  password: string;
}

export interface LoginResponse {
  userId: string;
}

export interface SignupRequest {
  name: string;
  email: string;
  password: string;
}

export interface SignupResponse {
  userId: string;
}

export interface ResetPasswordRequest {
  resetToken: string;
  newPassword: string;
}

export interface ResetPasswordResponse {
  success: boolean;
}

export interface RequestResetPasswordRequest {
  email: string;
}

export interface RequestResetPasswordResponse {
  success: boolean;
  /** e.g., "Reset link sent to email" */
  resetToken: string;
}

export interface VerifyEmailRequest {
  verificationToken: string;
}

export interface VerifyEmailResponse {
  success: boolean;
  /** e.g., "User ID after email verification" */
  userId: string;
}

export interface ResendEmailVerificationRequest {
  email: string;
}

export interface ResendEmailVerificationResponse {
  success: boolean;
  /** e.g., "Verification email resent" */
  message: string;
}

function createBaseLoginWithOAuthRequest(): LoginWithOAuthRequest {
  return { email: "", name: "", provider: "" };
}

export const LoginWithOAuthRequest: MessageFns<LoginWithOAuthRequest> = {
  encode(message: LoginWithOAuthRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.provider !== "") {
      writer.uint32(26).string(message.provider);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoginWithOAuthRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoginWithOAuthRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.provider = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoginWithOAuthRequest {
    return {
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      provider: isSet(object.provider) ? globalThis.String(object.provider) : "",
    };
  },

  toJSON(message: LoginWithOAuthRequest): unknown {
    const obj: any = {};
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.provider !== "") {
      obj.provider = message.provider;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoginWithOAuthRequest>, I>>(base?: I): LoginWithOAuthRequest {
    return LoginWithOAuthRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoginWithOAuthRequest>, I>>(object: I): LoginWithOAuthRequest {
    const message = createBaseLoginWithOAuthRequest();
    message.email = object.email ?? "";
    message.name = object.name ?? "";
    message.provider = object.provider ?? "";
    return message;
  },
};

function createBaseLoginWithOAuthResponse(): LoginWithOAuthResponse {
  return { userId: "" };
}

export const LoginWithOAuthResponse: MessageFns<LoginWithOAuthResponse> = {
  encode(message: LoginWithOAuthResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoginWithOAuthResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoginWithOAuthResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoginWithOAuthResponse {
    return { userId: isSet(object.userId) ? globalThis.String(object.userId) : "" };
  },

  toJSON(message: LoginWithOAuthResponse): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoginWithOAuthResponse>, I>>(base?: I): LoginWithOAuthResponse {
    return LoginWithOAuthResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoginWithOAuthResponse>, I>>(object: I): LoginWithOAuthResponse {
    const message = createBaseLoginWithOAuthResponse();
    message.userId = object.userId ?? "";
    return message;
  },
};

function createBaseLoginWithSSORequest(): LoginWithSSORequest {
  return { email: "", name: "" };
}

export const LoginWithSSORequest: MessageFns<LoginWithSSORequest> = {
  encode(message: LoginWithSSORequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoginWithSSORequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoginWithSSORequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoginWithSSORequest {
    return {
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: LoginWithSSORequest): unknown {
    const obj: any = {};
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoginWithSSORequest>, I>>(base?: I): LoginWithSSORequest {
    return LoginWithSSORequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoginWithSSORequest>, I>>(object: I): LoginWithSSORequest {
    const message = createBaseLoginWithSSORequest();
    message.email = object.email ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseLoginWithSSOResponse(): LoginWithSSOResponse {
  return { userId: "" };
}

export const LoginWithSSOResponse: MessageFns<LoginWithSSOResponse> = {
  encode(message: LoginWithSSOResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoginWithSSOResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoginWithSSOResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoginWithSSOResponse {
    return { userId: isSet(object.userId) ? globalThis.String(object.userId) : "" };
  },

  toJSON(message: LoginWithSSOResponse): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoginWithSSOResponse>, I>>(base?: I): LoginWithSSOResponse {
    return LoginWithSSOResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoginWithSSOResponse>, I>>(object: I): LoginWithSSOResponse {
    const message = createBaseLoginWithSSOResponse();
    message.userId = object.userId ?? "";
    return message;
  },
};

function createBaseGetUserDetailsRequest(): GetUserDetailsRequest {
  return { userId: "" };
}

export const GetUserDetailsRequest: MessageFns<GetUserDetailsRequest> = {
  encode(message: GetUserDetailsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUserDetailsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserDetailsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUserDetailsRequest {
    return { userId: isSet(object.userId) ? globalThis.String(object.userId) : "" };
  },

  toJSON(message: GetUserDetailsRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUserDetailsRequest>, I>>(base?: I): GetUserDetailsRequest {
    return GetUserDetailsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUserDetailsRequest>, I>>(object: I): GetUserDetailsRequest {
    const message = createBaseGetUserDetailsRequest();
    message.userId = object.userId ?? "";
    return message;
  },
};

function createBaseGetUserDetailsResponse(): GetUserDetailsResponse {
  return { userId: "", name: "", email: "", emailVerified: false };
}

export const GetUserDetailsResponse: MessageFns<GetUserDetailsResponse> = {
  encode(message: GetUserDetailsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.email !== "") {
      writer.uint32(26).string(message.email);
    }
    if (message.emailVerified !== false) {
      writer.uint32(32).bool(message.emailVerified);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUserDetailsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserDetailsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.emailVerified = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUserDetailsResponse {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      emailVerified: isSet(object.emailVerified) ? globalThis.Boolean(object.emailVerified) : false,
    };
  },

  toJSON(message: GetUserDetailsResponse): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.emailVerified !== false) {
      obj.emailVerified = message.emailVerified;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUserDetailsResponse>, I>>(base?: I): GetUserDetailsResponse {
    return GetUserDetailsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUserDetailsResponse>, I>>(object: I): GetUserDetailsResponse {
    const message = createBaseGetUserDetailsResponse();
    message.userId = object.userId ?? "";
    message.name = object.name ?? "";
    message.email = object.email ?? "";
    message.emailVerified = object.emailVerified ?? false;
    return message;
  },
};

function createBaseLoginRequest(): LoginRequest {
  return { email: "", password: "" };
}

export const LoginRequest: MessageFns<LoginRequest> = {
  encode(message: LoginRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    if (message.password !== "") {
      writer.uint32(18).string(message.password);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoginRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoginRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.password = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoginRequest {
    return {
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
    };
  },

  toJSON(message: LoginRequest): unknown {
    const obj: any = {};
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoginRequest>, I>>(base?: I): LoginRequest {
    return LoginRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoginRequest>, I>>(object: I): LoginRequest {
    const message = createBaseLoginRequest();
    message.email = object.email ?? "";
    message.password = object.password ?? "";
    return message;
  },
};

function createBaseLoginResponse(): LoginResponse {
  return { userId: "" };
}

export const LoginResponse: MessageFns<LoginResponse> = {
  encode(message: LoginResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoginResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoginResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoginResponse {
    return { userId: isSet(object.userId) ? globalThis.String(object.userId) : "" };
  },

  toJSON(message: LoginResponse): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoginResponse>, I>>(base?: I): LoginResponse {
    return LoginResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoginResponse>, I>>(object: I): LoginResponse {
    const message = createBaseLoginResponse();
    message.userId = object.userId ?? "";
    return message;
  },
};

function createBaseSignupRequest(): SignupRequest {
  return { name: "", email: "", password: "" };
}

export const SignupRequest: MessageFns<SignupRequest> = {
  encode(message: SignupRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.email !== "") {
      writer.uint32(18).string(message.email);
    }
    if (message.password !== "") {
      writer.uint32(26).string(message.password);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SignupRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignupRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.password = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignupRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
    };
  },

  toJSON(message: SignupRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SignupRequest>, I>>(base?: I): SignupRequest {
    return SignupRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SignupRequest>, I>>(object: I): SignupRequest {
    const message = createBaseSignupRequest();
    message.name = object.name ?? "";
    message.email = object.email ?? "";
    message.password = object.password ?? "";
    return message;
  },
};

function createBaseSignupResponse(): SignupResponse {
  return { userId: "" };
}

export const SignupResponse: MessageFns<SignupResponse> = {
  encode(message: SignupResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SignupResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignupResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignupResponse {
    return { userId: isSet(object.userId) ? globalThis.String(object.userId) : "" };
  },

  toJSON(message: SignupResponse): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SignupResponse>, I>>(base?: I): SignupResponse {
    return SignupResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SignupResponse>, I>>(object: I): SignupResponse {
    const message = createBaseSignupResponse();
    message.userId = object.userId ?? "";
    return message;
  },
};

function createBaseResetPasswordRequest(): ResetPasswordRequest {
  return { resetToken: "", newPassword: "" };
}

export const ResetPasswordRequest: MessageFns<ResetPasswordRequest> = {
  encode(message: ResetPasswordRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.resetToken !== "") {
      writer.uint32(10).string(message.resetToken);
    }
    if (message.newPassword !== "") {
      writer.uint32(18).string(message.newPassword);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResetPasswordRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResetPasswordRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.resetToken = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.newPassword = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResetPasswordRequest {
    return {
      resetToken: isSet(object.resetToken) ? globalThis.String(object.resetToken) : "",
      newPassword: isSet(object.newPassword) ? globalThis.String(object.newPassword) : "",
    };
  },

  toJSON(message: ResetPasswordRequest): unknown {
    const obj: any = {};
    if (message.resetToken !== "") {
      obj.resetToken = message.resetToken;
    }
    if (message.newPassword !== "") {
      obj.newPassword = message.newPassword;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResetPasswordRequest>, I>>(base?: I): ResetPasswordRequest {
    return ResetPasswordRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResetPasswordRequest>, I>>(object: I): ResetPasswordRequest {
    const message = createBaseResetPasswordRequest();
    message.resetToken = object.resetToken ?? "";
    message.newPassword = object.newPassword ?? "";
    return message;
  },
};

function createBaseResetPasswordResponse(): ResetPasswordResponse {
  return { success: false };
}

export const ResetPasswordResponse: MessageFns<ResetPasswordResponse> = {
  encode(message: ResetPasswordResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResetPasswordResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResetPasswordResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResetPasswordResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: ResetPasswordResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResetPasswordResponse>, I>>(base?: I): ResetPasswordResponse {
    return ResetPasswordResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResetPasswordResponse>, I>>(object: I): ResetPasswordResponse {
    const message = createBaseResetPasswordResponse();
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseRequestResetPasswordRequest(): RequestResetPasswordRequest {
  return { email: "" };
}

export const RequestResetPasswordRequest: MessageFns<RequestResetPasswordRequest> = {
  encode(message: RequestResetPasswordRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RequestResetPasswordRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestResetPasswordRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RequestResetPasswordRequest {
    return { email: isSet(object.email) ? globalThis.String(object.email) : "" };
  },

  toJSON(message: RequestResetPasswordRequest): unknown {
    const obj: any = {};
    if (message.email !== "") {
      obj.email = message.email;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RequestResetPasswordRequest>, I>>(base?: I): RequestResetPasswordRequest {
    return RequestResetPasswordRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RequestResetPasswordRequest>, I>>(object: I): RequestResetPasswordRequest {
    const message = createBaseRequestResetPasswordRequest();
    message.email = object.email ?? "";
    return message;
  },
};

function createBaseRequestResetPasswordResponse(): RequestResetPasswordResponse {
  return { success: false, resetToken: "" };
}

export const RequestResetPasswordResponse: MessageFns<RequestResetPasswordResponse> = {
  encode(message: RequestResetPasswordResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.resetToken !== "") {
      writer.uint32(18).string(message.resetToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RequestResetPasswordResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestResetPasswordResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.resetToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RequestResetPasswordResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      resetToken: isSet(object.resetToken) ? globalThis.String(object.resetToken) : "",
    };
  },

  toJSON(message: RequestResetPasswordResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.resetToken !== "") {
      obj.resetToken = message.resetToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RequestResetPasswordResponse>, I>>(base?: I): RequestResetPasswordResponse {
    return RequestResetPasswordResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RequestResetPasswordResponse>, I>>(object: I): RequestResetPasswordResponse {
    const message = createBaseRequestResetPasswordResponse();
    message.success = object.success ?? false;
    message.resetToken = object.resetToken ?? "";
    return message;
  },
};

function createBaseVerifyEmailRequest(): VerifyEmailRequest {
  return { verificationToken: "" };
}

export const VerifyEmailRequest: MessageFns<VerifyEmailRequest> = {
  encode(message: VerifyEmailRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.verificationToken !== "") {
      writer.uint32(10).string(message.verificationToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VerifyEmailRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVerifyEmailRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.verificationToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VerifyEmailRequest {
    return { verificationToken: isSet(object.verificationToken) ? globalThis.String(object.verificationToken) : "" };
  },

  toJSON(message: VerifyEmailRequest): unknown {
    const obj: any = {};
    if (message.verificationToken !== "") {
      obj.verificationToken = message.verificationToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VerifyEmailRequest>, I>>(base?: I): VerifyEmailRequest {
    return VerifyEmailRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VerifyEmailRequest>, I>>(object: I): VerifyEmailRequest {
    const message = createBaseVerifyEmailRequest();
    message.verificationToken = object.verificationToken ?? "";
    return message;
  },
};

function createBaseVerifyEmailResponse(): VerifyEmailResponse {
  return { success: false, userId: "" };
}

export const VerifyEmailResponse: MessageFns<VerifyEmailResponse> = {
  encode(message: VerifyEmailResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VerifyEmailResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVerifyEmailResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VerifyEmailResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
    };
  },

  toJSON(message: VerifyEmailResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VerifyEmailResponse>, I>>(base?: I): VerifyEmailResponse {
    return VerifyEmailResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VerifyEmailResponse>, I>>(object: I): VerifyEmailResponse {
    const message = createBaseVerifyEmailResponse();
    message.success = object.success ?? false;
    message.userId = object.userId ?? "";
    return message;
  },
};

function createBaseResendEmailVerificationRequest(): ResendEmailVerificationRequest {
  return { email: "" };
}

export const ResendEmailVerificationRequest: MessageFns<ResendEmailVerificationRequest> = {
  encode(message: ResendEmailVerificationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResendEmailVerificationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResendEmailVerificationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResendEmailVerificationRequest {
    return { email: isSet(object.email) ? globalThis.String(object.email) : "" };
  },

  toJSON(message: ResendEmailVerificationRequest): unknown {
    const obj: any = {};
    if (message.email !== "") {
      obj.email = message.email;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResendEmailVerificationRequest>, I>>(base?: I): ResendEmailVerificationRequest {
    return ResendEmailVerificationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResendEmailVerificationRequest>, I>>(
    object: I,
  ): ResendEmailVerificationRequest {
    const message = createBaseResendEmailVerificationRequest();
    message.email = object.email ?? "";
    return message;
  },
};

function createBaseResendEmailVerificationResponse(): ResendEmailVerificationResponse {
  return { success: false, message: "" };
}

export const ResendEmailVerificationResponse: MessageFns<ResendEmailVerificationResponse> = {
  encode(message: ResendEmailVerificationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResendEmailVerificationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResendEmailVerificationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResendEmailVerificationResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: ResendEmailVerificationResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResendEmailVerificationResponse>, I>>(base?: I): ResendEmailVerificationResponse {
    return ResendEmailVerificationResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResendEmailVerificationResponse>, I>>(
    object: I,
  ): ResendEmailVerificationResponse {
    const message = createBaseResendEmailVerificationResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    return message;
  },
};

export type AuthV2Service = typeof AuthV2Service;
export const AuthV2Service = {
  login: {
    path: "/AuthV2/Login",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: LoginRequest): Buffer => Buffer.from(LoginRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): LoginRequest => LoginRequest.decode(value),
    responseSerialize: (value: LoginResponse): Buffer => Buffer.from(LoginResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): LoginResponse => LoginResponse.decode(value),
  },
  loginWithSso: {
    path: "/AuthV2/LoginWithSSO",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: LoginWithSSORequest): Buffer => Buffer.from(LoginWithSSORequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): LoginWithSSORequest => LoginWithSSORequest.decode(value),
    responseSerialize: (value: LoginWithSSOResponse): Buffer =>
      Buffer.from(LoginWithSSOResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): LoginWithSSOResponse => LoginWithSSOResponse.decode(value),
  },
  loginWithOAuth: {
    path: "/AuthV2/LoginWithOAuth",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: LoginWithOAuthRequest): Buffer =>
      Buffer.from(LoginWithOAuthRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): LoginWithOAuthRequest => LoginWithOAuthRequest.decode(value),
    responseSerialize: (value: LoginWithOAuthResponse): Buffer =>
      Buffer.from(LoginWithOAuthResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): LoginWithOAuthResponse => LoginWithOAuthResponse.decode(value),
  },
  getUserDetails: {
    path: "/AuthV2/GetUserDetails",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetUserDetailsRequest): Buffer =>
      Buffer.from(GetUserDetailsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetUserDetailsRequest => GetUserDetailsRequest.decode(value),
    responseSerialize: (value: GetUserDetailsResponse): Buffer =>
      Buffer.from(GetUserDetailsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetUserDetailsResponse => GetUserDetailsResponse.decode(value),
  },
  signup: {
    path: "/AuthV2/Signup",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SignupRequest): Buffer => Buffer.from(SignupRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): SignupRequest => SignupRequest.decode(value),
    responseSerialize: (value: SignupResponse): Buffer => Buffer.from(SignupResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SignupResponse => SignupResponse.decode(value),
  },
  requestResetPassword: {
    path: "/AuthV2/RequestResetPassword",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RequestResetPasswordRequest): Buffer =>
      Buffer.from(RequestResetPasswordRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): RequestResetPasswordRequest => RequestResetPasswordRequest.decode(value),
    responseSerialize: (value: RequestResetPasswordResponse): Buffer =>
      Buffer.from(RequestResetPasswordResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): RequestResetPasswordResponse => RequestResetPasswordResponse.decode(value),
  },
  resetPassword: {
    path: "/AuthV2/ResetPassword",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ResetPasswordRequest): Buffer => Buffer.from(ResetPasswordRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ResetPasswordRequest => ResetPasswordRequest.decode(value),
    responseSerialize: (value: ResetPasswordResponse): Buffer =>
      Buffer.from(ResetPasswordResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ResetPasswordResponse => ResetPasswordResponse.decode(value),
  },
  verifyEmail: {
    path: "/AuthV2/VerifyEmail",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: VerifyEmailRequest): Buffer => Buffer.from(VerifyEmailRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): VerifyEmailRequest => VerifyEmailRequest.decode(value),
    responseSerialize: (value: VerifyEmailResponse): Buffer => Buffer.from(VerifyEmailResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): VerifyEmailResponse => VerifyEmailResponse.decode(value),
  },
  resendEmailVerification: {
    path: "/AuthV2/ResendEmailVerification",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ResendEmailVerificationRequest): Buffer =>
      Buffer.from(ResendEmailVerificationRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ResendEmailVerificationRequest => ResendEmailVerificationRequest.decode(value),
    responseSerialize: (value: ResendEmailVerificationResponse): Buffer =>
      Buffer.from(ResendEmailVerificationResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ResendEmailVerificationResponse =>
      ResendEmailVerificationResponse.decode(value),
  },
} as const;

export interface AuthV2Server extends UntypedServiceImplementation {
  login: handleUnaryCall<LoginRequest, LoginResponse>;
  loginWithSso: handleUnaryCall<LoginWithSSORequest, LoginWithSSOResponse>;
  loginWithOAuth: handleUnaryCall<LoginWithOAuthRequest, LoginWithOAuthResponse>;
  getUserDetails: handleUnaryCall<GetUserDetailsRequest, GetUserDetailsResponse>;
  signup: handleUnaryCall<SignupRequest, SignupResponse>;
  requestResetPassword: handleUnaryCall<RequestResetPasswordRequest, RequestResetPasswordResponse>;
  resetPassword: handleUnaryCall<ResetPasswordRequest, ResetPasswordResponse>;
  verifyEmail: handleUnaryCall<VerifyEmailRequest, VerifyEmailResponse>;
  resendEmailVerification: handleUnaryCall<ResendEmailVerificationRequest, ResendEmailVerificationResponse>;
}

export interface AuthV2Client extends Client {
  login(
    request: LoginRequest,
    callback: (error: ServiceError | null, response: LoginResponse) => void,
  ): ClientUnaryCall;
  login(
    request: LoginRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: LoginResponse) => void,
  ): ClientUnaryCall;
  login(
    request: LoginRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: LoginResponse) => void,
  ): ClientUnaryCall;
  loginWithSso(
    request: LoginWithSSORequest,
    callback: (error: ServiceError | null, response: LoginWithSSOResponse) => void,
  ): ClientUnaryCall;
  loginWithSso(
    request: LoginWithSSORequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: LoginWithSSOResponse) => void,
  ): ClientUnaryCall;
  loginWithSso(
    request: LoginWithSSORequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: LoginWithSSOResponse) => void,
  ): ClientUnaryCall;
  loginWithOAuth(
    request: LoginWithOAuthRequest,
    callback: (error: ServiceError | null, response: LoginWithOAuthResponse) => void,
  ): ClientUnaryCall;
  loginWithOAuth(
    request: LoginWithOAuthRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: LoginWithOAuthResponse) => void,
  ): ClientUnaryCall;
  loginWithOAuth(
    request: LoginWithOAuthRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: LoginWithOAuthResponse) => void,
  ): ClientUnaryCall;
  getUserDetails(
    request: GetUserDetailsRequest,
    callback: (error: ServiceError | null, response: GetUserDetailsResponse) => void,
  ): ClientUnaryCall;
  getUserDetails(
    request: GetUserDetailsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetUserDetailsResponse) => void,
  ): ClientUnaryCall;
  getUserDetails(
    request: GetUserDetailsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetUserDetailsResponse) => void,
  ): ClientUnaryCall;
  signup(
    request: SignupRequest,
    callback: (error: ServiceError | null, response: SignupResponse) => void,
  ): ClientUnaryCall;
  signup(
    request: SignupRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SignupResponse) => void,
  ): ClientUnaryCall;
  signup(
    request: SignupRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SignupResponse) => void,
  ): ClientUnaryCall;
  requestResetPassword(
    request: RequestResetPasswordRequest,
    callback: (error: ServiceError | null, response: RequestResetPasswordResponse) => void,
  ): ClientUnaryCall;
  requestResetPassword(
    request: RequestResetPasswordRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: RequestResetPasswordResponse) => void,
  ): ClientUnaryCall;
  requestResetPassword(
    request: RequestResetPasswordRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: RequestResetPasswordResponse) => void,
  ): ClientUnaryCall;
  resetPassword(
    request: ResetPasswordRequest,
    callback: (error: ServiceError | null, response: ResetPasswordResponse) => void,
  ): ClientUnaryCall;
  resetPassword(
    request: ResetPasswordRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ResetPasswordResponse) => void,
  ): ClientUnaryCall;
  resetPassword(
    request: ResetPasswordRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ResetPasswordResponse) => void,
  ): ClientUnaryCall;
  verifyEmail(
    request: VerifyEmailRequest,
    callback: (error: ServiceError | null, response: VerifyEmailResponse) => void,
  ): ClientUnaryCall;
  verifyEmail(
    request: VerifyEmailRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: VerifyEmailResponse) => void,
  ): ClientUnaryCall;
  verifyEmail(
    request: VerifyEmailRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: VerifyEmailResponse) => void,
  ): ClientUnaryCall;
  resendEmailVerification(
    request: ResendEmailVerificationRequest,
    callback: (error: ServiceError | null, response: ResendEmailVerificationResponse) => void,
  ): ClientUnaryCall;
  resendEmailVerification(
    request: ResendEmailVerificationRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ResendEmailVerificationResponse) => void,
  ): ClientUnaryCall;
  resendEmailVerification(
    request: ResendEmailVerificationRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ResendEmailVerificationResponse) => void,
  ): ClientUnaryCall;
}

export const AuthV2Client = makeGenericClientConstructor(AuthV2Service, "AuthV2") as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): AuthV2Client;
  service: typeof AuthV2Service;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
